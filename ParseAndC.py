
'''
# ParseAndC #
									 R E A D      M E  


     This tool has 3 BIG main vertical windows in the middle and a 4th horizontal one at the bottom.

      ____________________________________________________________________________
     |               <Interpret>|   <Map>   <data offset>|   <file offset boxes>  |
     |__________________________|________________________|________________________|
     |                          |                        |                        |
     |         Original         |        Interpreted     |       Data             |
     |           Code           |            Code        |     Display            |
     |          Window          |           Window       |     Windows            |
     |                          |                        |(Address, Hex and ASCII)|
     |                          |                        |                        |
     |__________________________|________________________|________________________|
     |  some extra information appears here based on the cursor movement          |
     |____________________________________________________________________________|
     |   Indented variable name | Datatype | AddrStart | AddrEnd | valLE | valBE  |
     |                                                                            |
     |                                                                            |
     |____________________________________________________________________________|
     | some options are here.  Make your choice                                   |
     |____________________________________________________________________________|

    -----------------------
   | Original code window  |
    -----------------------

   Here you either type/paste your C structure or variable declaration statements, or you can choose a code file.
   Do not put a .c file that contain other code that are not declarations (macro declarations are OK) as it will give errors.
   So, sanitize your input. Remove all code that is not related with variable declarations.

   Yes, this means a little more work on your part to figure out where all the declarations happened, where all the #defines are etc.
   But, this tool is not about finding those for you - rather, it depends on you being able to feed it the right declarations.

   (I am currently working on where you can just ANY code, not just header files, and the tool will ignore all the function definitions.
   This will make the tool user's job even easier, but the code is not foolproof yet).
   
    --------------------------
   | Interpreted code window  |
    --------------------------

   Once you are satisfied with the content of the Original Code Window, click on the "Interpret" button on top of it.
   It will then compile the code and give you the interpreted result. The main differences you will see (in contrast to the 
   original code window) are:

   a. All the comments have been removed
   b. All the #define instantiations are now resolved. So, if earlier there were statements like
               #define NUM 2
               #define ADD(x,y) x+y
               int intArray[ADD(NUM,3)];
     Now you will see this instead in the Interpreted code window:
               #define NUM 2
               #define ADD(x,y) x+y
               int intArray[2+3];
     Note that it is deliberately NOT showing intArray[5], but be assured that internally it has computed the value. 
     The reason it displays the expression like that is so that you can know what the macro was actually expanded to, and
     also if there was anything wrong with the evaluation of the macro expansion expression.

    Although Tcl/Tk allows you to write on this Interpret code Window, please DO NOT WRITE here. Treat it as read-only.
    It is a bit of pain to make it read-only (redirecting all the key mappings), and I am researching how to do it.
    The only "magic" in this window is when you bring your cursor over the variable names, but before that the "map" must happen.

   Once you can see the interpreted code in the Interpreted code window, the code will still be black-colored - there is no coloring.
   The Coloring only happens if you "map" the code to the data on the right. So, using your mouse, make a selection.
   For all the variable names that fall within that selection, the tool will choose their global-level variables and map them onto the data. 
   For example, suppose you have structs like these defined below, if you just choose f_b (case 2), automatically the global-level variable varB
   will get selected, along with all the variables under it (basically i_b and f_b). Of course, varB is going to be overlapping the
   storage with both i_b and f_b, but that is essentially how structures work. Bottom line is that, if you select ANY part of the structure,
   the whole structure will get selected. This makes sense programmatically too, since usually you read a whole structure.
   
   Also, this tool will completely ignore all variable declarations inside function definitions. For example, if your code is this,
   variable A is selectable for mapping, while variable B is NOT. This is because we only pick up the Global-level variables, 
   and those declared inside function definitions are NOT at the global level.

   int A;
   int main(){
      int B;
   }

   Next, there can be many, many combinations involving whether:

   - The structure is named or not (case 1,2,3,4 have names, but cases 5,6,7,8 do not). In case no name is specified,
     the tool would create a fake struct name like "Anonymous#n", where n is a number.
   - The structure declares any variables along with the definition or not (cases 2,3,6,7 do, but cases 1,4,5,7 do not).
     If no struct variable declaration is specified, the tool will create a fake struct variable like "DummyVar#n", where n is an integer.
     It will not be there in the Interpreted code window, but when you take the cursor on the token right after the closing
     curly brace, the variable description will show this name. The same name will appear in the bottom window too.
   - The structure declares a new type or not (cases 3,4,7,8 do, but cases 1,2,5,6 do not). Usually, when we just create a type using typedef,
     the compiler does not allocate any space on the memory (it only does when a new variable is declared with that created type).
     However, many of the code in production will just have cases 3 or 7, without any later statements like "varC newVar1" or "varG newVar2".
     We could technically ask the tool users to manually add such statements, but then we will lose out on all the nested struct goodies
     that we intend to show. Hence, we came up with a compromise. By default, the tool will treat the typedef statements as regular
     variable declarations, as if they will create the storage on the stack. This behavior can be modified by clicking on the
     "Mapping typedefs too" button (which will then convert to "Don't map typedefs"), or via the command-line option (-t OFF).


   Also remember that we cannot have typedef statements inside a nested struct definition - it must be at the global level.

   Another thing to remember is that in C, even if we define a named struct within another struct (basically, "nested" declaration),
   Then even that nested struct defition becomes global. You cannot define 2 nested structs with the same name. 
   

	    _________________________________________________________________________________________________________________
	   |                       |                       |                                |                                |
	   |  Case 1               |  Case 2               |  Case 3                        |  Case 4  (not possible)        |
	   |_______________________|_______________________|________________________________|________________________________|
	   |                       |                       |                                |                                |
	   | struct A{             | struct B{             | typedef struct C{              | typedef struct D{              |
	   |          int i_a;     |          int i_b;     |                   int i_c;     |                   int i_d;     |
	   |          float f_a;   |          float f_b;   |                   float f_c;   |                   float f_d;   |
	   |          };           |          } varB;      |                  } varC;       |                  };            |
	   |_______________________|_______________________|________________________________|________________________________|

	    __________________________________________________________________________________________________________________
	   |                       |                       |                                |                                |
	   |  Case 5 (nested only) |  Case 6               |  Case 7                        |  Case 8  (not possible)        |
	   |_______________________|_______________________|________________________________|________________________________|
	   |                       |                       |                                |                                |
	   | struct  {             | struct {              | typedef struct {               | typedef struct {               |
	   |          int i_e;     |          int i_f;     |                   int i_g;     |                   int i_h;     |
	   |          float f_e;   |          float f_f;   |                   float f_g;   |                   float f_h;   |
	   |          };           |          } varF;      |                  } varG;       |                  };            |
	   |_______________________|_______________________|________________________________|________________________________|


   Once you have made your selection, then click on the "Map" button.
   If you do not make a selection before clicking on the "Map" button, the tool will assume that you chose everything.

   Rush fans will know: The lyrics of the song "Free Will" says: 
 
        "You can choose a ready guide
            In some celestial voice
        If you choose not to decide
            You still have made a choice"

   (Neil Peart, their legendary drummer, died last year, hence this tribute)

    ------------------------
   | Data Display windows:  |
    ------------------------

  Here, there are 3 sub-windows. One for the address, one for the Hex data, one for the ASCII data.
  
  Please treat ALL these subwindows as Read-Only, even though you can actually write in them. Writing will mess things up.
  Just like the Interpreted code window, all the "magic" happens when you bring the cursor over some data that is "mapped".
  A mapped data will be colored with some non-black color.

  There are two offsets associated with the data window. One is the File offset, the other is the Data offset. 
  The default value for both these offsets is 0, and blank indicates 0.

  The File Offset indicates which offset of the file you want to display your 512-byte-wide window from.
  The Data Offset indicates which offset of the file you want to "map" your variable declarations from.

  In other words, if you choose file offset of 8, it will display bytes 8 through 519 (inclusive) in the Hex and ASCII windows.
  Similarly, if you choose Data Offset of 0x10 (or 16 in decimal), it will start coloring the data from the seventeenth byte.

  The File display can be changed via two boxes located right above the Hex Data Window: From Offset [box 1] or [box 2]. 
  The first box is actually a spinbox. Treat the first box as Read-Only. 
  For Page Up / Page Down, click on the spinbox to the right of "From Offset" and use you Up or Down Cursor. Or just use Page Up / Page Down.
  
  Also, once you have mapped your intended variables (they appear as colored to you), you can just double-click on any colored variable.
  That will reposition the data windows (Hex and ASCII) in such a way that the data corresponding to that variable is displayed
  smack right in the middle of the data window. Neat, huh?
  
  You can do the same the other way, too. Just click on any colored data item in either the Hex or Ascii data windows.
  It will immediately scroll the Interpreted code window to the variable corresponding to that data. If multiple variables point to the same data item,
  it will intelligently scroll in such a way that most number of such variables are displayed. Ain't that cool?
  
  If you want to display your file from very specific offset, you can also type it in the Text Box to the right of "or".
  Here you can use human-readable expression, like 1MB-20*5KB+0xADE+(1<<10). Once you are done type, press TAB to focusout.
  When the focusout happens, it will populate the Spinbox with the calculated value, so that you know what value it calculated.

  For the Data Offset, there is only ONE box right above the Interpreted Code Window. There you can enter any human-readable expression,
  and the tool will display it right from that offset. You need to TAB out (focusout) to let the tool know when you are done typing.

    ----------------------------------------------------------------
   | Field Information (based on cursor movement in Data window):   |
    ----------------------------------------------------------------

  This is the main usefulness of this tool. This is located right below the 3 main windows.

  When you hover over a mapped data (or its variable declaration in the Interpreted code window), some extra "Field Information"
  starts appearing in frame below the 3 main windows. These are:

  1. Description: This tells precisely what the compiler thinks the variable type is, what size etc.
  2. Address (start and End): This tell exactly where in the data file (basically the offsets) the variable/data appears. End address is inclusive.
  3. Value (Little-Endian and Big-Endian): For every variable/data, it tells the Little-Endian value and the Big-endian value.
  4. Length: How many bytes this variable occupies.

  Sometimes taking the cursor over the variable/data does not display all these fields, or populates them incorrectly. (This is expected behavior.)
  This usually happens when you have a one-variable-to-many-data (array) or many-variables-to-one-data (union/bitfield) mappings.
  E.g., for array variables, if you take your cursor above the array variable in the Interpreted Code Window, you will see the Description, Address and Length
  fields populated, but not the Value. This is because an array variable contains multiple individual array elements, so displaying an
  "overall" value makes no sense. But, you can always take your cursor to the Data Window and place it on an individual array element -
  then it will properly tell exactly which Array element it is, what its value is, what address etc.
  
  Similarly, for Union or Bitfield, if we place the cursor over the data element in the Data window, all the Value/Addres/Length make no sense.
  Because multiple different-length fields maps to the same data byte(s) in Union, whichever variable in Tck/Tk did get to apply the coloring tag last for
  the same data element will have the last laugh. So, for Union/bitfield, do not look at the "field information" from the Data Window.
  Instead, go to the Interpreted Code Window and place your cursor above the variable name.


    --------------------------------------------------------------------
   | Field Information (NOT based on cursor movement in Data window):   |
    --------------------------------------------------------------------
  
  If you do not care about pointing to any specific data item, but rather want ALL the data items to be listed, this is your place.
 
  This window has line-by-line listing of the different data items. And the listing is hierarchical. Look at the first column (Expand/Collapse)
  Which means, for items like Array and Structure, it will first show only one item - the Array or the Structure.  But, if you then double-click on the item, 
  or hit Enter, or press the Right-Arrow key, or click on the "Expand" icon on the first column, it will expand into Array elements or Structure members.
  
  For example, suppose you see a single entry for an Array item intArray[2]. When you hit enter on this, two more lines will appear below,
  the first one giving the details of the intArray[0] and the second one giving the details of intArray[1].
  
  To navigate, you can use the Arrow keys. Use Up or Down Array keys to go previous or next data items displayed on this window.
  Use the Left and Right arrow to Collapse or Expand a Structure or Array. If you are in the middle of a listed-out Structure memberlist /Array elementlist,
  you can use the Left arrow to go up (or jump) to its parent node (the Structure/Array). Pressing the Left arrow once more will collapse the list.

  There is only a few lines that you can see at the same time (the height of this window is only about 8 lines or so). If you want to see a more
  descriptive listing of ALL the selected variables with their internal members unraveled (expanded), look at the Console that will have a nicely
  formatted listing. The same listing is also provided as a CSV file in the same working directory from where you invoked this tool.
  The default name for this file is snapshot.csv, but you can always change the name by modifying the SNAPSHOT_FILE_NAME variable in the tool.

    --------------------------------------------------------------------
   | Option buttons                                                     |
    --------------------------------------------------------------------
  
   There are a few options here.

   - Mapping Typedefs or not - Sometimes, in production there will be big structures that are typedefed, and later there are variable declarations that use that new type. 
     Now, when you just typedef a variable, the compiler does not create any storage for it since it is just a type. For example, look at the code below:
	 
		typedef struct 
		{
			uint32_t HDDsize;    
			uint32_t sectors;       

			union
			{
				struct
				{
					uint32_t enabled:1;     
					uint32_t field24:1;        
					uint32_t field24_en:1;     
					uint32_t field25:1;        
					uint32_t field25_en:1;     
					uint32_t :0;     
					uint32_t field26:1;        
					uint32_t field26_en:1;     
					uint32_t field27:1;        
					uint32_t field27_en:1;     
					uint32_t reserved:22;   
					uint32_t special_en:1; 
				};
				uint64_t manualCommand;
			};
			
			uint8_t  specialConfiguration[20]; 
		} typeOneEntry_t;
	 
	    typeOneEntry_t newVariable;
	 
	 Suppose we want to map this above structure to some data. 
	 
	 If we select the above code segment in the interpreted code window and map it to the data, the variables inside the typedef will NOT get colored since when you
	 just create a typedef, no storage is created by the compiler. The newVariable will indeed get colored, but that will correspon to 32 bytes of data.
	 So, when you will hover the cursor on top of newVariable, it will show those 32 bytes of data in the Hex and ASCII windows, but no value would be shown.
	 This is not the intended outcome, because we want to see value of the individual fields, like HDDsize, manualCommand, etc. Sure, we can alway go to the bottom window
	 and there expand the tree under newVariable, but that's a bit of work. We want the user to just be able to hover the mouse on top of the structure and see their values.
	 
	 To get this intended outcome, we allow the option of mapping typedefs directly. When you choose that (it is enabled by default), it will treat the newly created type
	 just like a variable declaration, and map it. If you do not want to map the typedefs, click on the "Mapping typedefs too" button, and it will change to
	 "Not mapping typedefs".
	 
     Also to remember - maybe you are using some typedefs that come as part of stdint.h (like uint32_t, uint16_t etc.). It is possible that your code uses a lot of
     these. However, the compiler here does not know what to make of those. In those cases, you have two options: 
	 
       option A. Manually add the typedef statement like "typedef unsigned int uint32_t;" in your code.
       option B. If you are loathe to manually type the typedef statements and would rather do it for once and for all, there is a list inside this tool
       called typedefsBuiltin that already covers a few such cases (like int8_t, int16_t, int32_t, int64_t, uint8_t, uint16_t, uint32_t, uint64_t, intptr_t, uintptr_t).
       If your code uses some other typedefs frequently, maybe you can add them to this list.

   - Debug ON or OFF - when you turn the Debug on, it will start printing a massive amount of debug statements on the console. When you turn it off,
     it will invoke the dumpDetailsForDebug() routine that prints the most important lists and dictionaries used in this tool, and then turns it off.
     So, an easy way to see the internals of this tool for the current code is to turn the Debug ON and OFF one after the other.

##    Running in BATCH mode           ##
  
  If you do not care about the cursor movement, and just want the data to be mapped either on the console or on the CSV file, you can do that too
  by providing the -b (or --batch) option. Alternatively, if you are running it from a terminal (no X-windows) where it is not possible to show any GUI,
  the tool will automatically default to batch mode. In batch mode, only two things are mandatory inputs for command-line: The code and data files. 
  All other options are optional. For a detailed list of options, use the -h (or --help) button.
 
  The GUI version provides a superior experience compared to the batch mode, except one thing that the batch mode can do but the GUI version cannot.
  In the GUI version, you can only select global variables that are contiguous. So, suppose there are 3 structs (A, B and C) defined in your code and
  you only want to map structs A and C, but not B. Since you select a single area using your mouse, it is impossible to exclude B while including A and C.
  However, in the batch mode, you can specificy exactly which all global level variables you want to map by using --global "A C".

  There is a roundabout way of circumventing this, where you may be able to re-arrange the original code so that your intended global variables are contiguous, 
  but there is no guarantee that you can always do that. For example, if you are continuously defining newer structs using older structs, it may not be possible.

	
	python3 ParseAndC.py --help
	sys.version_info(major=3, minor=9, micro=4, releaselevel='final', serial=0) Python 3.x

	The way to invoke this tool is the following:
	
	> python2/3 ParseAndC.py [options], where the options are:

	-h, --help                Prints the options available
	-i, --include             followed by a single string that contains the include file path(s), separated by semicolon
	-x, --hex                 Prints the integral values in Hex (default is Decimal)
	-d, --datafile            followed by the data file name
	-c, --codefile            followed by the code file name
	-o, --offset              followed by the offset value (from which offset in the data file the struct will start mapping from)
							  Offsets can be numbers or expressions, but must be then double-quoted, like "3KB+0x12*43-(0o62/0b10)"
	-g, --global              followed by the name of the Global-level variables (or typedefs) that will be mapped
							  If providing multiple variable names, then it must be double-quoted (like "var1 var2")
							  If no variable names are provided, every variable at the global level in the code file will be automatically selected
	-t, --typedef             followed by Yes/No to indicate if typedefs will be mapped as regular variables or not
	-v, --verbose, --debug    to indicate if debug messages will be printed or not
	-b, --batch               to indicate that the tool will run in the non-interactive, non-GUI, terminal batch mode


##     CROSS-PLATFORM STATUS:		##

  This tool is designed to be cross-platform. It is supposed to work anywhere. Since it has minimal dependency, it is not supposed to break.
  
  But the proof of pudding is eating thereof, so we cannot really claim that it works everywhere unless we have actually tested it.

  I have tested it on the following configurations:
  Window 10 Python 2.7
  Window 10 Python 3.8
  Window 7 Python 3.8
  Linux Python 2.7

  For Mac, I could only test it for a few seconds on a colleague's work laptop. For proper testing, I need access to a Mac server. Can any kind soul grant me access?
  Also, access to any Linux testing environment with Python 3 would be appreciated.

  The look and feel of the tool changes as per the OS, but the main tool functionality remains the same.

  It was a royal pain in the ummm... neck porting it from Python 2 to Python 3. You see, at my workplace the predominant Python version is 2.7,
  though it is slowly changing. I googled for changes between Python 2 and Python 3, and it seems reasonable. How wrong I was!!

  There are many, many subtle changes in Python 3 that will break your program written in Python 2. Some examples:
  - Your print used to be a statement, now it is a proper function
  - Your unicode and str were pretty much interchangeable. Now unicode is str, and str is bytes (Uggghhhhh!!)
  - Integer division - Python 2 would return an integer, but Python 3 would return a float
  - dict.key() used to generate a list, now it generates <<class dict_keys>>, so any code expecting it to be a list would fail silently

##     ParseAndC 2.0 features:		##

  We introduce the following new features in ParseAndC 2.0:	
  
		1. Dynamic structures with runtime branching	
		2. Variable-length arrays												
		3. Variable-width bitfields
		4. Verification via Initialization
		5. Looping and Dimension-less array
		6. Speculative execution and C strings
		7. Unknown data offset? No problem!									
		
	Rather than	And the best part - we do ALL these while NOT changing the C syntax!!!


	After deployment across company, the most common feedback from the users of ParseAndC 1.0 was that while it was great for parsing C structs and displaying 
	the field values, most of the time users did not work with just one structure. For example, suppose one wants to parse network packet headers. So, after 
	parsing the IPv4 header, the user would need to inspect the protocol value manually, and then manually re-load the appropriate next structure (TCP header, 
	UDP header, etc.) into the tool for parsing the next header. Users wanted to remove ANY manual activity - they wanted something where they could write a parser 
	program once, load it into the tool, and it would automatically figure out at every decision point which next structure to load when. In other words, they 
	wanted the tool to have all the capabilities that a C parsing program has - branching, looping, information flow etc. This created a problem, since the 
	ParseAndC tool accepts only C structures as input, not C programs. So, if we wanted our tool to behave like C parsing programs without any manual intervention,
	the only way to do that was by making our input structures as powerful as full-fledged C programs. This was not possible under the current C language. 
	So, for ParseAndC 2.0 we introduced the "Dynamic" structures, which look and feel just like ordinary C structures (zero syntax change), but have some major 
	new hidden capabilities that are not allowed in "Regular" C structures:


	Feature # 1)	Branching: 
	--------------------------

	While C structure does allow preprocessor (#if-#else-#endif) commands, all such commands happen at compile-time, not during runtime (in reality, they happen 
	even before the actual compilation, but let's not nitpick). Therefore, in a preprocessor command, you cannot put a condition that involves variables whose 
	values would be known only during the runtime. In ParseAndC 2.0, we allow RUNTIME statement that look exactly like the preprocessor statements where the 
	condition will be evaluated during the runtime (not statically during compile-time), and the condition may include runtime variables. So, the struct below 
	will be illegal in C but legal in ParseAndC 2.0:

	struct parentDetails {
		unsigned char parentCount;
	#if parentCount == 2
		char parentName1[30];
		char parentName2[30];
	#else
		char parentName[30];
	#endif
	};

	We want to empasize that we are not "converting" the regular preprocessing statements into runtime statements. We designed our tool in such a way that if a 
	command can be resolved during compile-time, we do it during compile-time. However, if it cannot be resolved statically, it will be resolved dynamically. You 
	can alsolute use both "ordinary" preprocessing commands as well as "runtime" commands in the same structure. See one such example below.

	#define CRYPTO_YEAR 2021
	#define TAX_YEAR    2021

	struct taxDetails {
	   unsigned char filerCount;
	#if filerCount == 2		//  This condition is resolved dynamically, during runtime
	   char filerName1[30];
	   char filerName2[30];
	#else
	   char filerName[30];
	#endif
	#if TAX_YEAR >= CRYPTO_YEAR	//  This condition is resolved statically, during compile-time 
	   int cryptoIncome;
	#endif
	};


	This essentially means that, two instances of the same Dynamic structure can have two different sets of struct members depending on the data during runtime. 
	This is an extremely powerful feature, and by introducing this we have essentially captured the branching behavior of a C program.



	Feature # 2)	Variable-length arrays:
	----------------------------------------


	One of the most common parsing practice is that we first decode the packet-length, which tells us how many more bytes to read for the subsequent packet data. 
	Unfortunately, if we want to read the packet data into a single array variable, then we must have its array dimension coming from the packet-length variable. 
	This is illegal in C struct, but allowed in ParseAndC 2.0:

	struct packet {
	   unsigned char packet_length;
	   // We add 1 to avoid the case of 0-length packets
	   char     packet_data [ packet_length + 1 ] ;
	};

	This is similar to the information-flow feature of imperative programs, where latter variables are dependent on the values of former variables.



	Feature # 3)	Variable-width bitfield:
	-----------------------------------------

	Similar to variable-length arrays, we can also have variable-width bitfields where the bitfield width will only be known during the runtime. 
	This is illegal in C struct, but allowed in ParseAndC 2.0:

	struct  variableFlags {
		  unsigned int numFlags: 4 ;
		  unsigned int actualFlags: numFlags ;
	};

	So, using these first three features (runtime branching, variable-length array and variable-width bitfield), we are empowered to dynamically change the data 
	types of the later variables (by using the information from the previous variables at runtime). This pretty much gives us the adequate power to translate all 
	the parsing code in a .c file into a Dynamic structure.

	But wait, there is more!!


	Feature # 4)	Verification via Initialization:
	------------------------------------------------

	In C, while declaring a variable, we can also initialize it to a value (constant or variable). However, for structures that are used for reading in data, 
	that initialization is meaningless (since we are not writing anything). Nonetheless, we turn the tables here in ParseAndC 2.0 - if an initialization condition 
	is supplied, we check if that variable indeed has that value in the parsed data. If not, we flag a warning. This is very, very useful for users since often we 
	want to confirm that certain field has certain expected value. This is akin to the assert statement in C, without introducing any new syntax.

	struct e_ident {
		 unsigned int magic_number = 0x7F454C46;
		unsigned char EI_CLASS;
		unsigned char EI_DATA;	
		unsigned char EI_VERSION;
		unsigned char EI_OSABI;
		unsigned char EI_ABIVERSION;
		unsigned char EI_PAD[7];	
	} elf_identifier;

	In the above example, if magic_number does not have the value of 0x7F454C46 in the parsed data, the tool will flag it. This initialization (or verification) has 
	yet another use, that we will soon see.


	Feature # 5)	Looping and Dimension-less array:
	-------------------------------------------------


	In C, when declaring an array, one must tell the compiler the array dimensions. The first dimension is allowed to be blank, but in reality it is not blank - 
	it must be accompanied by an initialization statement so that the compiler can infer at compile-time exactly what the actual dimension is. The C99 does allow 
	flexible arrays, but puts a constrint that it must be the last member in a C struct. In ParseAndC 2.0, we allow dimension-less array ANYWHERE, where the array 
	dimension is treated as infinity, until some optional termination condition happens. We did not want to introduce any new syntax for providing the termination 
	condition, so the lexically closest subsequent initialization statement serves as the termination criteria for the infinite loop (we will explain this in detail 
	later). If there is no termination condition, it will loop endlessly until there is no more data to map (end of file reached). 

	Suppose a datastream is simply many packets coming one after another, where each packet contains a simple "packet_length" field followed by that many bytes of data. 
	In ParseAndC 2.0, the following code is akin to an infinite loop until the datastream is exhausted.

	struct packet {
	   unsigned char        packet_length;
	   char     packet_data  [  packet_length +1 ] ;
	} packetArray [ ] ;    // Dimension-less array

	With this, the looping behavior of the C program is captured.


	Feature # 6)	Speculative execution and C strings:
	----------------------------------------------------

	C does not have any special type for strings (character arrays ending with the null character). However, we have C strings in nearly every real-life data 
	(section names, program names, variable names etc.). So, if there is a C string field in the incoming datastream, but we do not know its length beforehand, 
	then we cannot capture it via a regular C structure. On the other hand, we observe that the way C strings are constructed (a stream of non-null characters 
	followed by the null character) makes it a tailor-made case for dimensionless array with termination criteria.
	 
	As mentioned earlier, if there is no termination criteria, a dimension-less array will be treated as an infinite array, but if there is any initialization 
	statement provided after that, it will serve as the termination condition for the infinite loop. ParseAndC 2.0 will speculatively try all different values (1,2,3,...) 
	of the array size until the termination condition gets satisfied. 

	struct C_String {
		 char Char[ ] ;         // Dimensionless array
		 char nullChar = '\0';  // Termination condition for the speculative execution
	} C_string;

	This way, the tool will speculatively try all possible values (1,2,3,...) of dimension for the array variable Char[] until the subsequent nullChar gets a 
	value of '\0' in the datastream. So, we can use this to map C strings whose length we do not know beforehand. In the example below, it will properly identify 
	the 3 null characters in the datastream, and populate the C strings for Name1, Name2, and Name3. You can NOT do it in a C structure.

	struct C_String {
		 char Char [ ] ;         // Dimensionless array
		 char nullChar = '\0';  // Termination condition for the speculative execution
	} Name1, Name2, Name3;


	Feature # 7)	Unknown Data Offset? No problem! Parsing without knowing which data offset to parse from:
	---------------------------------------------------------------------------------------------------------

	Another really neat use case for Speculative execution is that when you do not know beforehand what exact offset you should start doing the mapping from, 
	but you know some key fields' values (what they should look like). ParseAndC 2.0 allows you to do proper parsing even in that case, as seen below.

	char filler [ ];        // Dimensionless array
	struct Packet {
		 int version;
		 int signature;
		 long magic_figure;
		 int length;
	} packet = { .signature = 0x67681233, .magic_figure = 0x34F2323B};     // termination criteria

	In this case above, the ParseAndC 2.0 tool will speculatively try all different values (1,2,3,...) of the array dimension for filler until the condition 
	(packet.signature = 0x67681233 and  packet.magic_figure = 0x34F2323B) gets satisfied. This is a really cool feature, where you can parse without even 
	knowing beforehand exactly which offset to parse from.

	Since it tries all possible values one by one, this is currently slow (and the current time complexity is sum(1+2+3+...+n) = O(n^2)). 
	However, this speculative execution feature is currently in the Beta stage and I am testing various other approximation algorithms that will definitely make it faster.



	In summary, ParseAndC 2.0 is an extremely powerful tool that allows you do write a complete parser using structures alone (no C programs needed). 
	And the best part of it is that it achieves it without changing the C syntax in any way. This is very, very important, because the moment you tell 
	people that we are introducing these new keywords or syntaxes, the existing C community often lose interest. I designed this extension so that a person 
	who understands C code but has never heard of ParseAndC will still be able to look at ParseAndC 2.0 structures and immediately tell what what it is doing.

	This tool is extremely portable - it is a single 1MB Python text file, supports all versions of Python (2/3), is cross-platform (Windows/Mac/Unix), 
	and also works in the terminal /batch mode without GUI. For multi-byte datatypes (e.g. integer or float) it supports both endianness (little/big) and 
	displays value in both decimal and Hex formats. The tool needs no internet connection and works fully offline. It is self-contained - it doesn't import 
	almost anything (uses only lists and dictionaries), to the extent that it implements its own C compiler (front-end) from scratch!!

	This tool is useful for both security- and non-security testing alike (reverse engineering, network traffic analyzing, packet processing etc.). 
	The author of this tool led many security hackathons at Intel and there this tool was found to be very useful.

	You can see all that just by clicking the "Run Demo" button on the tool.


##     CURRENTLY WORK-IN-PROGRESS:		##
  
  I am currently working on a few items. These items are not fully ready yet:
  - sizeof()	
  - Bitfield behavior with different combincation of packed, aligned and #pragma pack. I found that while the various top compilers have consistent behavior in terms of 
    where to insert the padding for non-bitfield structs (even with different combincations of packed, aligned and #pragma pack), it is not consistent when you take 
	structs with bitfields and deal with different combincation of packed, aligned and #pragma pack. And this is by design - K & R mentioned it in their C Bible that 
	alignment of bitfields is very much implemenation-dependent. So, I am yet to figure out which is the best "common" method used by various compilers when it comes to
	handle bitfields and deal with different combincation of packed, aligned and #pragma pack. Usually this is not a problem, because very rarely individual struct member 
	variables in a struct will have their individual attribute statements. So, the tool currently does not implement the attribute handling (packed, aligned and #pragma pack)
	for bitfields. It will do it in future, for sure.

##     KNOWN ISSUES:		##
  
  This tool is first for me in many ways. 

      - This is my first Python program. 
      - This is my first compiler-writing. 
      - This is my first GUI development of any kind.

  This program has been used extensively by various teams at Intel, and as per their feedback, they are pretty happy.
  
  Still, for a program that contains 12K lines of code,  you can imagine the number of bugs it has!!!

  But, it is the age of outsourcing. So, ALL of you - the potential users - are my testers. I coded this FREE for you, you test this FREE for me. Win-Win!!
  Use it with your own test structures, and report to me anytime anything breaks (see below on how to report a bug).

  I know of an issue. For example, currently it does not handle the const/volatile/static etc. storage qualifier keywords very well.
  However, these storage qualifiers have absolutely no relevance for this too. So, feel free to delete them from your code and rerun it.

##     HOW  TO  REPORT  A  BUG:		##

  Please email me with a subject line of "ParseAndC bug/feature request" along with the following information/attachments:

  1. Your running environment (Windows / Unix / Mac), Python version.
  2. The input files you used for code and data. If the Data file is large, at least send the Code file. If you typed in the code, copy what you typed.
  3. your Data Offset and File Offset values for which it is breaking.
  4. Turn on the debug setting on this tool by clicking on the "Debug" button . When you do that, the tool will become slow, and it will print a
     whole lot of debug messages on the background console. This is the most useful debugging information, so please capture that and attach it.


##     FEEDBACK PLEASE!!!!		##

  if you like this tool, I want to hear about it.
  If you feel that this tool sucks, I still want to hear about it.
  If you have some feature in mind that you feel would make the tool better, I want to hear about it.

  Please email me with any feedback: ThisToolName AT emailProviderSoundingLikeJeeMel
  
 ##   FREQUENTLY ASKED QUESTIONS      ##
 
  Q. Why did you need to write your own parser/compiler when open-source solutions (Lex, Yacc, LLVM, Clang) already exist?
  A. Great question. I do admit that I was very much tempted to use them. But then I wanted my tool to be completely self-contained with no dependency.
     If my tool is dependent on other tools, the moment they chnage their API, it will break my tool. I didn't want that to happen.
	 And if you think they will never change their API because so many other tools rely on them, you are sorely mistaken.
	 Just look at what Python did when they moved from 2.x to 3.x - it broke countless Python tools.
	 
  Q. Your Python code does not look very "Pythonic" and looks like C code in many places. Why?
  A. Because it indeed is. I am a C guy, and this is my very first Python program.
  
  Q. Now that you have Open-Sourced it, can I start sending you patches?
  A. I request you to hold off just for a little bit longer for the following reasons:
       a. The tool is still in the Beta stage, and it is not feature-complete. Please allow me some time to add all the other features.
	   b. I have plans to refactor the code.
	   c. I need some more time for doing unit-testing and bug fixes.

'''

################################################################################################################################
# Changelog :   
################################################################################################################################
#
# 2019-09-05 - findTokenListInLines() now working for match occurring over multiline inputLine
#				Also macro substitution seems to be working OK
# 2019-09-06 - Now added '##' operator
# 2019-09-06 - fixed a bug in the parseArithmeticExpression that did not handle the Right-to-Left associativity
# 2019-09-16 - Realized that we cannot ERROR out for the AST-->String routine in case the output string does not parse into the same input AST
#              (because the input AST may not be properly parenthesized). So changed it to a WARNING instead.
# 2019-09-23 - Added code on how to interpret a variable declaration
# 2019-10-13 - This version has the GUI integration done, and interpretation is happening properly. This is before I attempt to add the Focus part.
# 2019-10-18 - This version has the mapping working, typedef done. Before I try to remove the encoding stuff.
# 2019-10-19 - Now the selection part is working. Before adding messagebox
# 2019-10-23 - Did upto parseArithmeticExpression (including evaluateArithmeticExpression), outputTextArithmeticExpressionFromAST
# 2019-11-28 - Now added cursor movement on data window too.
# 2019-12-03 - Split the variableDescription into a dictionary named variableDescriptionExtended, with various keys of "description", "signedOrUnsigned", "datatype", "arrayDimensions", "arrayElementSize" 
# 2019-12-04 - Now added bitwise field support in internal value calculations (not in variable declaration yet)
# 2019-12-15 - Now added highlighting of individual array elements
# 2019-12-15 - Split the value into Little-Endian and Big-Endian parts
# 2019-12-17 - Added highligthing all around, fixed bugs regarding enum and function declarations. Next up: typedef resolution (properly)
# 2019-12-22 - This is the version after which we will split the structure defining part completely. Not that the current form works completely.
# 2019-12-23 - Nested structure now seem to be working. Next need to work on the Union.
# 2019-12-24 - Included new fields added to the variableDescriptionExtended. This is just after we removed the 6-th element of variableDescription, which is now variableDescriptionExtended["globalTokenListIndex"] (recall variableDescriptionExtended itself is item[4])
# 2019-12-24 - Now we are going to change the coloring based on self.dataOffsetsDetail rather than self.dataOffsetsDetail.
# 2019-12-24 - I think Union is now working.
# 2019-12-28 - Now the compiler padding addition is working. For size, we need to use the base datatype for array variables.
# 2019-12-29 - Now typedef is working, but the global index of variable (globalTokenListIndex) is only correct if we have a single variable declared within the declaration statement.
# 2019-12-29 - Now typedef is working, but only if the original typedef statement created a single type. Now going to change that
# 2019-12-30 - Typedef now works for multiple-variable declarations, as well as multiple-type-creation-in-a-single-typedef statement
# 2019-12-31 - Transitioned to PRINT, revamped the type specifier part (no conflicting float/int/char etc.) now going to implement bitfields.
# 2020-01-01 - Added code to convert human-readable (GB/MB) etc. to decimal. Next intend to change the offset entry variables.
# 2020-01-02 - Added currentDeclarationSegmentStartIndex, currentDeclarationSegmentEndIndexInclusive, and initializationStartIndex to variableDescriptionExtended{} so that declaration segment identification is easier.
# 2020-01-02 - Before we start changing the way the validate and focusout routines work
# 2020-01-03 - Before we split up the Interpreted code display
# 2020-01-04 - Fixed a bunch of bugs regarding changing the data offset (causes the self.dataOffsetsDetail need to be redone) and file offset (causes the block to be re-read)
# 2020-01-05 - Fixed the operator precedence bug in parseArithmeticExpression() where - should have higher precedence than +
# 2020-01-05 - Fixed enum variable declaration bug (still not ready for typedef enum)
# 2020-01-09 - Just added the bitfield information dictionary into the sruct component and did the overall size calculation. Now will work on the display etc.
# 2020-01-13 - Bitfield now working for LE packing
# 2020-01-14 - replaced all checks for isinstance( -x-, basestring) with checkIfString( -x- ) since basestring is no longer available in Python 3
# 2020-01-18 - Before replacing *.keys() with getDictKeyList(*). This is because Python 2 gets *.keys() as a list, but Python 3 gets *.keys as class dict_keys (Ugghhh!)
# 2020-01-18 - Now the "Interpret" is working. But map is failing due to byte-vs-Str mismatch (various invocation of ord() function)
# 2020-01-19 - Now the map is working too, because earlier it was failing due to Integer division not working in Python 3. 
# 2020-01-20 - Added README. After fixing the multi-window display data
# 2020-01-23 - Before adding the fourth Window (created a barebone unraveled list). Next going to add the TreeView
# 2020-01-23 - Now treeview is working somewhat.
# 2020-01-27 - Before trying to use the same offsets from the offsetDetails. Now this fixed some bugs regarding functions.
# 2020-01-27 - After trying to use the same offsets from the offsetDetails. Also fixed the bug in mapStructure where populateDataMap() was getting called before performInterpretedCodeColoring()
# 2020-01-28 - The Address start and end in the 4th Window now working. Also, fixed the bug in previously not using removeColorTags() so that if we now re-choose, previous colors remain.
# 2020-01-28 - Now the inserting-into-typedef part has been moved into where it should belong (parseVariableDeclaration() function). Corresponding code in parseStructre() and parseCodeSnippet() are now commented out.
# 2020-01-28 - Fixed the bug where I was not deducting the offset while reading from the blockRead in populateDataMap(). Previous versions would give wrong result.
# 2020-01-29 - Now even struct members can use derived type declarations.
# 2020-01-29 - Now variable description is also part of unravel, so it can decode any kind of value. Next will display the bytes for each field.
# 2020-01-29 - Now byte values are showing too in the tree view. Next optional Hex display and pretty printing.
# 2020-01-29 - mandatory Pretty printing of unraveled done. Also fixed small cosmetic bug of extra period on struct name.
# 2020-01-30 - Now optional ability to display all integral values in Hex is added.
# 2020-02-02 - BitField now working. Before merging the Big-endian and Little-endian.
# 2020-02-03 - Merged the Big-endian and Little-endian, and also fixed the bug where a single field might be broken at the beginning or the end of the block.
# 2020-02-10 - Now it supports sizeof() for simple expressions.
# 2020-02-12 - Before changing the code so that unraveling doesn't happen only for a file offset change
# 2020-02-12 - Now unraveling doesn't happen only for a file offset change. Now going to clear up the dataOffset and fileOffset naming mess.
# 2020-02-13 - Renamed self.dataOffsets to self.variableOffsets and self.dataOffsetsDetail to self.variableOffsetsDetail.
# 2020-02-14 - Fixed many small things to make sure it runs on both Python 2 and 3.
# 2020-02-21 - Added the second (faster) routine for findTokenListInLines. Now going to fix the problem of the Data windows getting double-written. 
# 2020-02-24 - Fixed the bug of Interpreted Code Window variable highlighting remaining in case of Page Up and Down.
# 2020-02-29 - Added code to support builtin typedefs.
# 2020-03-02 - Now showing addresses for bitfields.
# 2020-03-04 - Fixed enum bug where it was not halding expressions. Also added handling of storage qualifiers like volatile.
# 2020-03-06 - After adding the Hex / Dec toggle feature.
# 2020-03-07 - After adding Command line parser, and before preparing for the batch mode.
# 2020-03-08 - From GUI variables, made these variables global: dataLocationOffset, dataFileName, dataFileSizeInBytes, and block
# 2020-03-09 - From GUI variables, made these variables global: variableOffsets, variableOffsetsDetail
# 2020-03-09 - From GUI variables, made these variables global: inputIsHexChar, binaryArray, hexCharArray, totalBytesToReadFromDataFile
# 2020-03-09 - Removed commented out lines due to all those Global-making endeavor.
# 2020-03-13 - Before doing the massive restructuring.
# 2020-03-15 - After doing the massive restructuring. Still, when self.fileOffset changes, excess things are happening. 
# 2020-03-15 - Before committing to use fileDisplayOffset instead of self.fileOffset.
# 2020-03-16 - After adding code to selectively choose whether to display typedefs or not. Before adding bottom line of options.
# 2020-03-17 - Everything seems to be working. Removed the inefficient version of findTokenListInLines().
# 2020-03-18 - Now Help option and batch mode are working.
# 2020-03-22 - Fixed padding bug. Added more content to README. Removed a lot of commented out lines.
# 2020-03-25 - Added support for #pragma pack. Just parsed __attribute__(( options )), but yet to take any action.
# 2020-03-27 - Before processing packed and aligned __attribute__.
# 2020-03-29 - Added a lot of comments and illustrations regarding packed and aligned __attribute__. Yet to add the code for detecting __attribute__ properly.
# 2020-04-10 - Now it parses the aligned and packed properly, but yet to take action on those attributes.
# 2020-04-23 - Now it properly implements the packed and aligned attributes. Next we will implement the bitfields correctly (previous implementation was incorrect).
# 2020-04-27 - Previous implementation was wrong. Re-did the packed, aligned, and pragma pack. Bitfield still not done.
# 2021-03-19 - Fixed bug that was causing the program to crash when trying to tab out of the data offset with a blank datablock.
# 2021-03-29 - Changed tokenizeLines to also create precise token locations. Now going to return both items instead of just tokenList.
# 2021-03-29 - The new code now gets both tokenList and precise token locations from tokenlizeLines(). It does not use the latter though. Next we will handle ifdefs.
# 2021-04-04 - After handling preprocessing directives. But going to rewrite the tokenizeLines(), so this backup is just before that.
# 2021-04-05 - Reimplemented tokenizeLines() that correctly handles all preprocessing directives. This is before handing <include "filename"> statements.
# 2021-04-05 - Reimplemented preProcess() that now handles <include "filename"> statements.
# 2021-04-06 - Added feature of centering Data window based on double-clicked variable name.
# 2021-04-06 - Added routine displayDataWindowFromOffset(), which is used by page up/down and doubleclick (refactored the code)
# 2021-04-06 - Added more stuff into displayDataWindowFromOffset(), by taking commong things away from page up/down and doubleclick (refactored the code)
# 2021-04-08 - Added support for variadic macro. Next going to add support for INCLUDE_FILE_PATH
# 2021-04-19 - Before putting in a "Demo" mode
# 2021-04-21 - Before renaming the Compiler Padding on to Demo
# 2021-04-22 - Before adding the Expand/Collapse buttons on the bottom TreeView window
# 2021-04-26 - After adding code to handle function definitions (not declarations), and removing structure-end-padding button. Before removing extra refernces.
# 2021-04-28 - Changed the builtin code used for Demo.
# 2021-04-29 - Added Double-click feature for the Hex and Ascii data windows.
# 2021-05-05 - Added zero-width bitfield variable (alignment reset) handling
# 2021-05-09 - Changed the way preProcess() works
# 2021-06-10 - Before separating the preprocessing directive symbol (#) from all the preprocessing directives.
# 2021-08-02 - Rearrange the code a little bit, put Changelog at the top
# 2021-10-21 - Changed calculateSizeOffsetsBatch() so that it can now operate on any subset of variablesAtGlobalScopeSelected[] rather than the whole of it.
# 2021-10-22 - Before changing how to read the data file incrementally.
# 2021-10-27 - After changing how to read the data file incrementally.
# 2021-11-03 - Before renaming routines so that we know exactly what routine does what. This is a working version.
# 2021-11-03 - Renamed populateDataMap() to displayBottomTreeWindow(). Also renamed populateDataMap() to displayBottomTreeWindow(). 
#              Earlier performInterpretedCodeColoring() used to call showDataBlock() at its end. Now took it out and made sure it gets explicitly called by 
#			   the callers of performInterpretedCodeColoring(), which are fileOffsetChange() and mapStructureToData(). Renamed showDataBlock() to displayAndColorDataWindows().
#			   Created calculateSizeOffsetsAndReadDataBlockAndPopulateUnraveled(variablesAtGlobalScopeSelected) that is common to both GUI and batch. This version is still working. 
# 2021-11-04 - Renamed openDataFileRoutineBatch() to checkIfDataFileIsValidAndGetItsLength()
# 2021-11-05 - Fixed the bug that when Data file is changed the Data mapping was not being redone.
# 2021-11-05 - This version processes the variablesAtGlobalScopeSelected[] list one by one (calculates sizeOffsets, reads dataBlock, and populates unraveled).
# 2021-11-05 - Renamed currentLineIsHashDefine to currentLineIsPreProcessorDirective.
# 2021-11-12 - Before splitting parseStructure() into parseStructureDefinition() and calculateStructureLength()
# 2021-11-13 - After splitting parseStructure() into parseStructureDefinition() and calculateStructureLength(), before allowing Runtime directives in struct definition.
#              Also, right now changed the input parameter to parseStructureDefinition() from tokenList to tokenListInformation, since we now also need the line information.
# 2021-11-24 - Now addVariableToUnraveled() is working fine (before populating the values)
# 2021-11-27 - Now addVariableToUnraveled() is populating the values one record at a time (and possibly recursively).
# 2021-11-30 - Now addVariableToUnraveled() is returning the same result as populateUnraveled(), making populateUnraveled() and unravelNestedStruct() redundant.
# 2021-12-03 - Now evaluateArithmeticExpression() can extract runtime values from unraveled
# 2021-12-07 - Now added printAllArrayVariableNames(), also fixed a bug of array of struc.
# 2021-12-28 - Rewrote the bitfiled handling with mixed container types so that it can iterate over one record at a time.
# 2021-12-28 - Brought together the new and old methods of bitfiled handling so that it can iterate over one record at a time.
# 2021-12-30 - Now the struct member handling is just one loop, and removed a lot of garbage.
# 2022-01-01 - Implemented code that can handle dynamic struct members, but the #RUNTIME condition can now only handle static conditions. 
#			 - Unfortunately, now sizeOffsets is getting out of sync with unraveled since they get calculated at different times.
# 2022-01-02 - Before adding ancestry in unraveled.
# 2022-01-02 - After adding ancestry in unraveled. Now you can recreate sizeOffsets from unraveled itself, without having to create it independently.
# 2022-01-11 - Just before removing the calculateSizeOffsetsBatch(), getOffsetsRecursively() etc. so that unraveled would be populated first, and from there, sizeOffsets
# 2022-02-09 - Commented out calculateSizeOffsetsBatch(), getOffsetsRecursively(), unravelNestedStruct(), and populateUnraveled().
# 2022-02-09 - Completely removed commented out code calculateSizeOffsetsBatch(), getOffsetsRecursively(), unravelNestedStruct(), and populateUnraveled().
# 2022-02-09 - Replaced the term sizeOffsets with coloredVarsIdOffsetSize so that one can understand better what it is.
# 2022-02-12 - Simple cases of Dynamic structs seem to be working. Before reimplementing the [] operator properly.
# 2022-02-13 - Changed flattenList and some other tweaks. Now it seems to be working fine.
# 2022-02-13 - Added code to check during Interpret time itself if variable redeclaration happened for Dynamic structs.
# 2022-02-14 - Before making sure that unraveled is the sole source of all the data.
# 2022-02-16 - Implemented variable array dimensions. Now going to implement variable bitfields.
# 2022-02-18 - Now working. Before changing the coloredVarsIdOffsetSize (adding the unraveled line #)
# 2022-02-20 - Before changing the routine createColoredVarsIdOffsetSizeFromUnraveled(), basically the way coloredVarsIdOffsetSize gets created.
# 2022-02-22 - After completely rewriting how the Code and Data windows get colored.
# 2022-02-24 - Now it works. Highlighting both sides.
# 2022-02-26 - Introduced #RUNTIME statements in the global scope (not just within struct definitions). It does not evaluate them though.
# 2022-02-27 - Before adding the capability to have global-scoped runtime statements evaluated during map.
# 2022-03-01 - Now working properly. Also introduced deepCopy-or-not in various places like calculateStructureLength().
# 2022-03-03 - Lots of bug fixes. Now working properly.
# 2022-03-03 - Before making structuresAndUnionsDictionary an array.
# 2022-03-03 - After making structuresAndUnionsDictionary an array.
# 2022-03-03 - After renaming structuresAndUnionsDictionary to structuresAndUnions.
# 2022-03-15 - After implementing ability to have multiple definitions of the same structure under different #RUNTIME statements. 
#			   But before changing runtimeStatementOrGlobalScopedVariableId to also include Global struct definitions.
# 2022-03-16 - After changing runtimeStatementOrGlobalScopedVariableId to runtimeStatementOrGlobalScopedVariableIdOrStructIdSelected (also includes Global struct definitions).
# 2022-03-17 - After implementing single-value initialization checking for non-array variables.
# 2022-04-05 - After implementing verifyInitialization()
# 2022-04-07 - Before starting to add save/restore options.
# 2022-04-09 - Before taking out components repetitions.
# 2022-04-12 - Before taking out bitFieldInfo.
# 2022-04-12 - After taking out bitFieldInfo.
# 2022-04-15 - After rewriting the calculateStructureLength() for handling the bitfield/regular part.
# 2022-04-16 - After putting in the code to return the initialization status from addVariableToUnraveled() and calculateStructureLength().
# 2022-04-18 - After putting in speculativeArrayDimensions to pass as the parameters.
# 2022-04-20 - Now speculative thing working in calculateStructureLength(). Also removed all reference to allPossibleQualifiedNames and printAllArrayVariableNames since they were redundant.
# 2022-04-20 - Before changing preProcess() to carve out a function for macro invocation.
# 2022-04-20 - After changing preProcess() to carve out a function for macro invocation (fixed the bug).
# 2022-04-24 - Fixed the way bitfields addresses are shown and calculated (especially the end-address).
# 2022-04-25 - Fixed bugs regarding variableNameIndex (item[3]) being different variableDeclarations[] and structuresAndUnions[ components[]].
# 2022-04-25 - Before changing the way we might load internal data.
# 2022-04-25 - Before passing variableDescription to addVariableToUnraveled().
# 2022-04-26 - Added the demo part.
# 2022-04-26 - Before removing the #RUNTIME.
# 2022-04-30 - After removing the #RUNTIME. Now there is zero change in C syntax.
# 2022-05-06 - Small bug fix for using checkIfIntegral() instead of isinstance(item, int) for Python 2.
# 2022-05-10 - Introduced typecasting.
# 2022-05-11 - encodeValue now working
# 2022-05-12 - Now we can search for an encoded value in a file using findHardcodedDataInFile.
# 2022-08-25 - Small Bug fix regarding #ifndef handling.
# 2022-08-30 - Small Bug fix regarding #include handling in invokeMacrosOnLine(), indentation issue.
# 2022-08-31 - Small Bug fix regarding #include handling in invokeMacrosOnLine(), forgot to declare lines as global.
# 2022-09-01 - Bug fix regarding #include handling in invokeMacrosOnLine() and preProcess()
# 2022-09-06 - Bug fix for #pragma pack() being the last statement, plus feature addition of being able to set the dummy variable name prefix
# 2022-09-07 - Added capability to show the enum literals instead of just values by introducing the PRINT_ENUM_LITERALS
# 2022-09-09 - Before separating macro definition handling out of preProcess()
# 2022-09-09 - After separating macro definition handling out of preProcess()
# 2022-09-13 - Now displays enum literals while displaying the variable's value
# 2022-09-14 - Fixed bugs regarding tree window values not populating for bitfields, and evaluateArithmeticExpression() failing for runtime variables when Hex
##################################################################################################################################
##################################################################################################################################


#!/usr/bin/python
# -*- coding: utf-8 -*-
import os
import sys
#reload(sys)
#sys.setdefaultencoding('utf-8')
import re
from collections import OrderedDict 


# Global settings

IN_DEMO = False			# Runs a demo using some fixed code and data
BATCHMODE = False
PRINT_DEBUG_MSG = False		# use True or False ony
HIGHLIGHT_COLOR = "black"	# "black" or "yellow" works better
COMPILER_PADDING_ON = True
STRUCT_END_PADDING_ON = True	# Whether to add additional padding at the end of a structure to make to align to a word boundary
DISPLAY_INTEGRAL_VALUES_IN_HEX = False	#If True, -17 would now be displayed as -0x11
SNAPSHOT_FILE_NAME = "snapshot.csv"		# This is the output file name where the formatted data snapshot would be written in the current folder
MAP_TYPEDEFS_TOO = True	# Usually, we do not create any storage for typedef (so no mapping), but if that's all your structure has and you do not want to create extra declaration, turn it to True
PRINT_UNDEF_WARNING = True		# If the code wants to undefine a variable that is not defined yet, it throws a warning. But if there are many such instances, you can turn it off
PRINT_ENUM_LITERALS = True	# When set, it will print enum literals rather than value. Viz, for enum DAYS {SUN, MON, TUE} day=0; it will print day's value as "SUN" rather than 0.
PRINT_ENUM_LITERALS_MAX_SIZE_CHAR = 20	# When displaying enums, we cannot display it fully if the enum literals are too big. So we display only the first these many chars.
WARN_FOR_HASH_ERROR_DIRECTIVES = True	# The tool currently ignores all #error preprocessor commands. Whether it shows a warning in that regard is controlled by this.
EMULATE_GCC_COMPILATION_ENVIRONMENT = False	# This loads the builtin macros that GCC has
VERIFICATION_WARNING_COUNT_MAX = 1000000000000000000000000000	# It will show maximum these many warnings after verification fails

anonymousStructPrefix = "Anonymous#"
dummyVariableNamePrefix = "DummyVar#"
dummyUnnamedBitfieldNamePrefix = "dummyUnnamedBitfieldVar#"
dummyUnnamedBitfieldCount = 0
preProcessorSymbol = '#'

CHAR_SIZE = 1
SHORT_SIZE = 2
INT_SIZE = 4
LONG_SIZE = 4
LONG_LONG_SIZE = 8
POINTER_SIZE = 4
FLOAT_SIZE = 4
DOUBLE_SIZE = 8
BITS_IN_BYTE = 8

ALIGNED_DEFAULT_VALUE = 4

LITTLE_ENDIAN = 0
BIG_ENDIAN = 1

# For initialization value and other stuff, this is the value we check
DEFAULT_ENDIANNESS = LITTLE_ENDIAN		
#DEFAULT_ENDIANNESS = BIG_ENDIAN		


# The start and end addresses (byte numbers) for bitfields change based on whether we are packing LE or BE. Change it accordingly.
BITFIELD_DEFAULT_ENDIANNESS = LITTLE_ENDIAN		
#BITFIELD_DEFAULT_ENDIANNESS = BIG_ENDIAN		


# Global variables

TOOL_NAME = "ParseAndC by Parbati Kumar Manna"
DISPLAY_BLOCK_WIDTH = 16
DISPLAY_BLOCK_HEIGHT = 32
BLOCK_SIZE = DISPLAY_BLOCK_WIDTH * DISPLAY_BLOCK_HEIGHT
ENCODINGS = ("ASCII", "CP037", "CP850", "CP1140", "CP1252", "Latin1", "ISO8859_15", "Mac_Roman", "UTF-8", "UTF-8-sig", "UTF-16", "UTF-32")
#When you have no more than 10 colors, use this
COLORS_10 = ['red2','SkyBlue1', 'magenta2','saddle brown', 'cornflower blue','dark green', 'deep pink', 'purple','chocolate1','gold']
COLORS_20 = ['red2','SkyBlue1', 'magenta2','saddle brown', 'cornflower blue','dark green', 'deep pink', 'purple','chocolate1','gold',
'DarkGoldenrod2', 'DarkOrange1', 'plum1','DarkOrchid1', 'DeepPink2', 'DeepSkyBlue2', 'orange', 'DodgerBlue2','turquoise','indian red']
COLORS_ALL = ['DarkGoldenrod2', 'DarkOrange1', 'DarkOrchid1', 'DeepPink2', 'DeepSkyBlue2', 'DodgerBlue2', 
'HotPink1', 'IndianRed1', 'LightPink1', 'LightSalmon2', 'MediumOrchid1', 'MediumPurple1', 'OrangeRed2', 
'PaleVioletRed1', 'RoyalBlue1', 'SeaGreen1', 'SkyBlue1', 'SlateBlue1', 'SpringGreen2', 'SteelBlue1', 'VioletRed1', 
'blue', 'blue violet', 'brown1', 'cadet blue', 'chartreuse2', 'chocolate1', 
'coral', 'cornflower blue', 'cornsilk2', 'cyan', 'dark goldenrod', 'dark green', 'dark khaki', 'dark olive green', 'dark orange', 'dark orchid', 'dark salmon', 
'dark sea green', 'dark slate blue', 'dark slate gray', 'dark turquoise', 'dark violet', 'deep pink', 'deep sky blue', 'dim gray', 'dodger blue', 'firebrick1', 
'forest green', 'gainsboro', 'gold', 'goldenrod', 'gray', 'green yellow', 'honeydew2', 'hot pink', 'indian red', 'ivory2', 'khaki', 'lavender', 'lawn green', 
'lemon chiffon', 'light blue', 'light coral', 'light cyan', 'light goldenrod', 'light goldenrod yellow', 'light grey', 'light pink', 'light salmon', 'light sea green', 
'light sky blue', 'light slate blue', 'light slate gray', 'light steel blue', 'light yellow', 'lime green', 'linen', 'magenta2', 'maroon', 'medium aquamarine', 
'medium blue', 'medium orchid', 'medium purple', 'medium sea green', 'medium slate blue', 'medium spring green', 'medium turquoise', 'medium violet red', 'midnight blue', 
'misty rose', 'navajo white', 'navy', 'olive drab', 'orange', 'orange red', 'orchid1', 'pale goldenrod', 'pale green', 'pale turquoise', 'pale violet red', 'papaya whip', 
'peach puff', 'pink', 'pink1', 'plum1', 'powder blue', 'purple', 'red', 'rosy brown', 'royal blue', 'saddle brown', 'salmon', 'sandy brown', 'sea green', 'seashell2', 
'sienna1', 'sky blue', 'slate blue', 'slate gray', 'snow', 'spring green', 'steel blue', 'tan1', 'thistle', 'tomato', 'turquoise', 'violet red', 'wheat1', 'yellow', 'yellow green']
preprocessingDirectives = ('include', 'if', 'ifdef', 'ifndef', 'else', 'elif', 'endif', 'define', 'undef', 'line', 'error', 'pragma', '...', '__VA_ARGS__', '__VA_OPT__')
runtimeDirectives = ('if','elif','else','endif','loop','endloop')
oneCharOperatorList = ('.','+','-','*','/','%', '&', '|', '<', '>', '!', '^', '~', '?', ':', '=', ',','#')
twoCharOperatorList = ('##','++', '--','()','[]','->','>>', '<<', '<=', '>=', '==', '!=', '&&', '||', '+=', '-=', '*=', '/=', '%=', '&=', '^=', '|=')
threeCharOperatorList = ('<<=', '>>=')
derivedOperatorList = ("function()","typecast")
bracesDict = 		{	"(":")",	"{":"}",	"[":"]",	"<":">",	"?":":"}
bracesDictReverse = {	")":"(",	"}":"{",	"]":"[",	">":"<",	":":"?"}
primitiveDatatypeLength = {"char":CHAR_SIZE,"short":SHORT_SIZE,"int":INT_SIZE, "long":LONG_SIZE, "long long":LONG_LONG_SIZE,"pointer":POINTER_SIZE, "float":FLOAT_SIZE,"double":DOUBLE_SIZE}

cDataTypes = ["char","double","float","int", "long","short","void","signed","unsigned"]
cKeywords = ["auto", "break", "case", "char", "const", "continue", "default", "do", "double", "else", "enum", 
				"extern", "float", "for", "goto", "if", "inline", "int", "long", "register", "return", "short", "signed", 
				"sizeof", "static", "struct", "switch", "typedef", "union", "unsigned", "void", "volatile", "while"]
integralDataTypes = ["char","short","int","long","long long"]
treeViewHeadings = ["Variable Name", "Data Type", "Addr Start", "Addr End", "Raw Hex Bytes", "Value (LE)", "Value (BE)"]

PACKED_STRING 		= "__packed__"
ALIGNED_STRING 		= "__aligned__"
ATTRIBUTE_STRING 	= "__attribute__"

illegalVariableNames = list(preprocessingDirectives) + list(oneCharOperatorList) + list(twoCharOperatorList) + list(threeCharOperatorList) + cDataTypes + cKeywords + integralDataTypes

lines = []
enums = {}		# This is a dictionary that holds yet another dictionary inside {enumDataType,{enumLiteral,enumValue}}
enumFieldValues = {}	# This is a dictionary of ALL enum fields and their values. We can do this because enum field names are globally unique. We keep this separate to cache the enum values
typedefs = {}
suDict = {}	# Dictionary that maps a struct or union name (which may not be unique thanks to #RUNTIME statements) to a unique suId (struct or union id number)
structuresAndUnions = []	# Each value of this array is a dictionary itself, where the key is its suId. The dictionary is of this format: 
							# "type" : "struct/union", "name": name, "size":size, "components":[[variable1 name, variable size, variable declaration statement, Extended variable description],...]}
# Below is a list of 6-Tuple. Each list item is pretty much same as the structuresAndUnions["components"] 5-tuple, plus another item which tells where this var name occurs.
# [variable1 name, variable size, variable declaration statement, variable name relative index within declaration, Extended variable description, absolute Index of variable name in tokenList]							
variableDeclarations = []
macroDefinitions = []		# The ordered dictionary for holding all Macro definitions. This changes over time, as we keep on parsing line by line.
currentMacroNames = []		# Just a cache of macro names
# This is just the sizes of the selected variables that would be colored
gTokenLocationLinesChars = []
unraveled = []
fileDisplayOffset = 0 	# This is the offset from which the file display window starts
dataLocationOffset = 0	# This is the offset from which the variables under variablesAtGlobalScopeSelected start to map
codeFileName = None
dataFileName = None
dataFileSizeInBytes = None
displayBlock = []	# This is the block that holds the data for the display window only, starting at fileDisplayOffset
dataBlock = []		# This is the block that holds the data for the variablesAtGlobalScopeSelected[], starting at dataLocationOffset
inputIsHexChar = False
binaryArray = ""
hexCharArray = []
totalBytesToReadFromDataFile = 0
window = None
dummyVariableCount = 0
dummyZeroWidthBitfieldVariableCount = 0
totalVariableCount = 0


srcFileDetails = []	# Each entry contains a list [ ["src file name","full path"],[segment1StartLine#,segment1EndLine#], [segment2StartLine#,segment2EndLine#], ...]
					# Basically, as we keep on including more and more header files, it becomes impossible to track which line of code came from where.
					# This list keeps track of that. Everytime we insert a file, all the entries need to get updated.

runtimeStatementLineNumbers = []	# The runtime statement line numbers
runtimeStatementLocationsInGlobalScope = [] # These are the runtime statements that are OUTSIDE any struct definition. 
											# Every row = [line#, globalTokenNumberStart, globalTokenNumberEnd, [runtime token list] ] 
runtimeStatementOrGlobalScopedVariableIdOrStructId = [] # Each row is either [lineNum, variableId], or [lineNum, [Runtime tokens]], or [lineNum, ['struct'/'union', structId]]
variableIdsInGlobalScope = []	# These are the variables that are at the global scope, depending on the user selection
globalScopedBuddies = []	# The list of sets of variableId of global scoped variables that must be selected together (if user selects any of them, select ALL of them).
							# This mostly happens because of using #RUNTIME statements. It goes in sync with globalScopedRuntimeBlocks[].
globalScopedRuntimeBlocks = [] # Each entry in a <start line#, end line#> of independent #RUNTIME blocks in runtimeStatementLocationsInGlobalScope. It goes in sync with globalScopedBuddies.
							# So, the first entry will correspond to the first #RUNTIME block, which will enclose the global-scoped variables in first entry of globalScopedBuddies
#allPossibleQualifiedNames = [] # These are all the possible fully qualified names. For example, suppose we have a struct S{int i; float f;} S1, S2[2]; 
#                               # Then these are all the possible names: S1, S1.i, S1.f, S2[0], S2[0].i, S2[0].f, S2[1], S2[1].i, and S2[1].f. 
globalScopesSelected = []	# These are the variables that are at the global scope, depending on the user selection and the MAP_TYPEDEFS_TOO
variableSelectedIndices = [] # These are the indices of variables that have been selected after the user presses the "Map" button
variablesAtGlobalScopeSelected = [] # These are the variables that are at the global scope, AND are the top-level parents of variables that have been selected by the user
coloredVarsIdOffsetSize = []	# These tell the beginning offset (absolute, not relative) and length for ALL the variables under variablesAtGlobalScopeSelected[], beginning at dataLocationOffset.
coloredDataIdOffsetSize	= []	# Each row in coloredVarsIdOffsetSize and coloredDataIdOffsetSize is [variableId,beginOffset,variableSize, unraveledRowNumber]
inputVariables = []	# For batch, the list of the Global variables the user wants to map
blankArraysAndTerminationInfo = {}	# The dictionary that provides all the related data. It gets created during Interpret, and is only read during Map (no write). Its format is:
									# blankArraysAndTerminationInfo[k]={"blankDimensionArrayVariableId":k, "partnerVariableId":partner, "siblingAncestors":siblingAncestors}
blankArrayDimensionStack = []	# This stack contains entries like {"blankDimensionArrayVariableId":variableId,"speculativeValue":speculativeValue}
executionStateStack = []	# This stores the execution state
MAINLOOP_STARTED = False
pragmaPackStack = []
pragmaPackCurrentValue = None
pragmaPackDefaultValue = ALIGNED_DEFAULT_VALUE
gVerificationWarningCount = 0	# How many times the tool has displayed the Verfication failure warning message (reset with every map() operation)

LARGE_NEGATIVE_NUMBER = -9999999999999999999999999999999		# A number usually associated with default (erroneous) value of Index in an array
LARGE_POSITIVE_NUMBER = -LARGE_NEGATIVE_NUMBER
LOGICAL_TEST_RESULT_INDETERMINATE = "__LOGICAL_TEST_RESULT_INDETERMINATE__"		# An arbitrary string

RELATIVE_TOLERANCE_FOR_FLOAT = 0.0000001
ABSOLUTE_TOLERANCE_FOR_FLOAT = 0

funcName = ""	# Tells which routine it was executed from

# This thing should be moved out since there is no need to repeat this for every tokenizeLines() invocations
keywordsSorted = list(preprocessingDirectives)
keywordsSorted.extend(list(twoCharOperatorList))
keywordsSorted.extend(list(threeCharOperatorList))
keywordsSorted.sort(key=len)
keywordsSorted.reverse()
#PRINT("sorted keyword list =",keywordsSorted)

# There are two methods of calculating the bitfield offsets - Microsoft-style (Old), and GCC-style (new)
bitFieldOffsetCalculationMethod = "old"
#bitFieldOffsetCalculationMethod = "New"

# These two variables are essentially for telling which execution stage we are in. I didn't use enum beacause of my antipathy towards importing ANYTHING. :-)
lastActionWasInterpret = False
lastActionWasMap = False

storageClassSpecifier = [ 'auto','register','static','extern','typedef']
typeQualifier = ['const','volatile']

# These are the typedefs that will be used if the user fails to explicitly typedef them.
typedefsBuiltin = {
					'int8_t'	:	['typedef', 'char', 'int8_t', ';'],
					'int16_t'	:	['typedef', 'short', 'int16_t', ';'],
					'int32_t'	: 	['typedef', 'int', 'int32_t', ';'],
					'int64_t'	: 	['typedef', 'long long', 'int64_t', ';'],

					'uint8_t'	:	['typedef', 'unsigned', 'char', 'uint8_t', ';'],
					'uint16_t'	:	['typedef', 'unsigned', 'short', 'uint16_t', ';'],
					'uint32_t'	: 	['typedef', 'unsigned', 'int', 'uint32_t', ';'],
					'uint64_t'	: 	['typedef', 'unsigned', 'long long', 'uint64_t', ';'],

					'size_t'	:	['typedef', 'unsigned', 'int', 'size_t', ';'],
					'ptrdiff_t'	:	['typedef', 'unsigned', 'int', 'ptrdiff_t', ';'],
					
					'intptr_t'	:	['typedef', 'int', '*', 'intptr_t', ';'],
					'uintptr_t'	:	['typedef', 'unsigned', 'int', '*', 'uintptr_t', ';']
					}

builtinMacroDefinitions = [
	'#define _GNU_SOURCE',
	'#define __SSP_STRONG__ 3',
	'#define __DBL_MIN_EXP__ (-1021)',
	'#define __FLT32X_MAX_EXP__ 1024',
	'#define __UINT_LEAST16_MAX__ 0xffff',
	'#define __ATOMIC_ACQUIRE 2',
	'#define __FLT128_MAX_10_EXP__ 4932',
	'#define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F',
	'#define __GCC_IEC_559_COMPLEX 2',
	'#define __UINT_LEAST8_TYPE__ unsigned char',
	'#define __SIZEOF_FLOAT80__ 16',
	'#define __INTMAX_C(c) c ## L',
	'#define __CHAR_BIT__ 8',
	'#define __UINT8_MAX__ 0xff',
	'#define __WINT_MAX__ 0xffffffffU',
	'#define __FLT32_MIN_EXP__ (-125)',
	'#define __ORDER_LITTLE_ENDIAN__ 1234',
	'#define __SIZE_MAX__ 0xffffffffffffffffUL',
	'#define __WCHAR_MAX__ 0x7fffffff',
	'#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1',
	'#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1',
	'#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1',
	'#define __DBL_DENORM_MIN__ ((double)4.94065645841246544176568792868221372e-324L)',
	'#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1',
	'#define __GCC_ATOMIC_CHAR_LOCK_FREE 2',
	'#define __GCC_IEC_559 2',
	'#define __FLT32X_DECIMAL_DIG__ 17',
	'#define __FLT_EVAL_METHOD__ 0',
	'#define __unix__ 1',
	'#define __FLT64_DECIMAL_DIG__ 17',
	'#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2',
	'#define __x86_64 1',
	'#define __UINT_FAST64_MAX__ 0xffffffffffffffffUL',
	'#define __SIG_ATOMIC_TYPE__ int',
	'#define __DBL_MIN_10_EXP__ (-307)',
	'#define __FINITE_MATH_ONLY__ 0',
	'#define __GNUC_PATCHLEVEL__ 0',
	'#define __FLT32_HAS_DENORM__ 1',
	'#define __UINT_FAST8_MAX__ 0xff',
	'#define __has_include(STR) __has_include__(STR)',
	'#define __DEC64_MAX_EXP__ 385',
	'#define __INT8_C(c) c',
	'#define __INT_LEAST8_WIDTH__ 8',
	'#define __UINT_LEAST64_MAX__ 0xffffffffffffffffUL',
	'#define __SHRT_MAX__ 0x7fff',
	'#define __LDBL_MAX__ 1.18973149535723176502126385303097021e+4932L',
	'#define __FLT64X_MAX_10_EXP__ 4932',
	'#define __UINT_LEAST8_MAX__ 0xff',
	'#define __GCC_ATOMIC_BOOL_LOCK_FREE 2',
	'#define __FLT128_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F128',
	'#define __UINTMAX_TYPE__ long unsigned int',
	'#define __linux 1',
	'#define __DEC32_EPSILON__ 1E-6DF',
	'#define __FLT_EVAL_METHOD_TS_18661_3__ 0',
	'#define __unix 1',
	'#define __UINT32_MAX__ 0xffffffffU',
	'#define __LDBL_MAX_EXP__ 16384',
	'#define __FLT128_MIN_EXP__ (-16381)',
	'#define __WINT_MIN__ 0U',
	'#define __linux__ 1',
	'#define __FLT128_MIN_10_EXP__ (-4931)',
	'#define __INT_LEAST16_WIDTH__ 16',
	'#define __SCHAR_MAX__ 0x7f',
	'#define __FLT128_MANT_DIG__ 113',
	'#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)',
	'#define __INT64_C(c) c ## L',
	'#define __DBL_DIG__ 15',
	'#define __GCC_ATOMIC_POINTER_LOCK_FREE 2',
	'#define __FLT64X_MANT_DIG__ 64',
	'#define __SIZEOF_INT__ 4',
	'#define __SIZEOF_POINTER__ 8',
	'#define __USER_LABEL_PREFIX__',
	'#define __FLT64X_EPSILON__ 1.08420217248550443400745280086994171e-19F64x',
	'#define __STDC_HOSTED__ 1',
	'#define __LDBL_HAS_INFINITY__ 1',
	'#define __FLT32_DIG__ 6',
	'#define __FLT_EPSILON__ 1.19209289550781250000000000000000000e-7F',
	'#define __SHRT_WIDTH__ 16',
	'#define __LDBL_MIN__ 3.36210314311209350626267781732175260e-4932L',
	'#define __STDC_UTF_16__ 1',
	'#define __DEC32_MAX__ 9.999999E96DF',
	'#define __FLT64X_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951F64x',
	'#define __FLT32X_HAS_INFINITY__ 1',
	'#define __INT32_MAX__ 0x7fffffff',
	'#define __INT_WIDTH__ 32',
	'#define __SIZEOF_LONG__ 8',
	'#define __STDC_IEC_559__ 1',
	'#define __STDC_ISO_10646__ 201706L',
	'#define __UINT16_C(c) c',
	'#define __PTRDIFF_WIDTH__ 64',
	'#define __DECIMAL_DIG__ 21',
	'#define __FLT64_EPSILON__ 2.22044604925031308084726333618164062e-16F64',
	'#define __gnu_linux__ 1',
	'#define __INTMAX_WIDTH__ 64',
	'#define __has_include_next(STR) __has_include_next__(STR)',
	'#define __FLT64X_MIN_10_EXP__ (-4931)',
	'#define __LDBL_HAS_QUIET_NAN__ 1',
	'#define __FLT64_MANT_DIG__ 53',
	'#define __GNUC__ 7',
	'#define __pie__ 2',
	'#define __MMX__ 1',
	'#define __FLT_HAS_DENORM__ 1',
	'#define __SIZEOF_LONG_DOUBLE__ 16',
	'#define __BIGGEST_ALIGNMENT__ 16',
	'#define __FLT64_MAX_10_EXP__ 308',
	'#define __DBL_MAX__ ((double)1.79769313486231570814527423731704357e+308L)',
	'#define __INT_FAST32_MAX__ 0x7fffffffffffffffL',
	'#define __DBL_HAS_INFINITY__ 1',
	'#define __DEC32_MIN_EXP__ (-94)',
	'#define __INTPTR_WIDTH__ 64',
	'#define __FLT32X_HAS_DENORM__ 1',
	'#define __INT_FAST16_TYPE__ long int',
	'#define __LDBL_HAS_DENORM__ 1',
	'#define __FLT128_HAS_INFINITY__ 1',
	'#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL',
	'#define __INT_LEAST32_MAX__ 0x7fffffff',
	'#define __DEC32_MIN__ 1E-95DF',
	'#define __DBL_MAX_EXP__ 1024',
	'#define __WCHAR_WIDTH__ 32',
	'#define __FLT32_MAX__ 3.40282346638528859811704183484516925e+38F32',
	'#define __DEC128_EPSILON__ 1E-33DL',
	'#define __SSE2_MATH__ 1',
	'#define __ATOMIC_HLE_RELEASE 131072',
	'#define __PTRDIFF_MAX__ 0x7fffffffffffffffL',
	'#define __amd64 1',
	'#define __STDC_NO_THREADS__ 1',
	'#define __ATOMIC_HLE_ACQUIRE 65536',
	'#define __FLT32_HAS_QUIET_NAN__ 1',
	'#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL',
	'#define __SIZEOF_SIZE_T__ 8',
	'#define __FLT64X_MIN_EXP__ (-16381)',
	'#define __SIZEOF_WINT_T__ 4',
	'#define __LONG_LONG_WIDTH__ 64',
	'#define __FLT32_MAX_EXP__ 128',
	'#define __GCC_HAVE_DWARF2_CFI_ASM 1',
	'#define __GXX_ABI_VERSION 1011',
	'#define __FLT_MIN_EXP__ (-125)',
	'#define __FLT64X_HAS_QUIET_NAN__ 1',
	'#define __INT_FAST64_TYPE__ long int',
	'#define __FLT64_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F64',
	'#define __DBL_MIN__ ((double)2.22507385850720138309023271733240406e-308L)',
	'#define __PIE__ 2',
	'#define __LP64__ 1',
	'#define __FLT32X_EPSILON__ 2.22044604925031308084726333618164062e-16F32x',
	'#define __DECIMAL_BID_FORMAT__ 1',
	'#define __FLT64_MIN_EXP__ (-1021)',
	'#define __FLT64_MIN_10_EXP__ (-307)',
	'#define __FLT64X_DECIMAL_DIG__ 21',
	'#define __DEC128_MIN__ 1E-6143DL',
	'#define __REGISTER_PREFIX__',
	'#define __UINT16_MAX__ 0xffff',
	'#define __DBL_HAS_DENORM__ 1',
	'#define __FLT32_MIN__ 1.17549435082228750796873653722224568e-38F32',
	'#define __UINT8_TYPE__ unsigned char',
	'#define __NO_INLINE__ 1',
	'#define __FLT_MANT_DIG__ 24',
	'#define __LDBL_DECIMAL_DIG__ 21',
	'#define __VERSION__ "7.4.0"',
	'#define __UINT64_C(c) c ## UL',
	'#define _STDC_PREDEF_H 1',
	'#define __GCC_ATOMIC_INT_LOCK_FREE 2',
	'#define __FLT128_MAX_EXP__ 16384',
	'#define __FLT32_MANT_DIG__ 24',
	'#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__',
	'#define __STDC_IEC_559_COMPLEX__ 1',
	'#define __FLT128_HAS_DENORM__ 1',
	'#define __FLT128_DIG__ 33',
	'#define __SCHAR_WIDTH__ 8',
	'#define __INT32_C(c) c',
	'#define __DEC64_EPSILON__ 1E-15DD',
	'#define __ORDER_PDP_ENDIAN__ 3412',
	'#define __DEC128_MIN_EXP__ (-6142)',
	'#define __FLT32_MAX_10_EXP__ 38',
	'#define __INT_FAST32_TYPE__ long int',
	'#define __UINT_LEAST16_TYPE__ short unsigned int',
	'#define __FLT64X_HAS_INFINITY__ 1',
	'#define unix 1',
	'#define __INT16_MAX__ 0x7fff',
	'#define __SIZE_TYPE__ long unsigned int',
	'#define __UINT64_MAX__ 0xffffffffffffffffUL',
	'#define __FLT64X_DIG__ 18',
	'#define __INT8_TYPE__ signed char',
	'#define __ELF__ 1',
	'#define __GCC_ASM_FLAG_OUTPUTS__ 1',
	'#define __FLT_RADIX__ 2',
	'#define __INT_LEAST16_TYPE__ short int',
	'#define __LDBL_EPSILON__ 1.08420217248550443400745280086994171e-19L',
	'#define __UINTMAX_C(c) c ## UL',
	'#define __SSE_MATH__ 1',
	'#define __k8 1',
	'#define __SIG_ATOMIC_MAX__ 0x7fffffff',
	'#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2',
	'#define __SIZEOF_PTRDIFF_T__ 8',
	'#define __FLT32X_MANT_DIG__ 53',
	'#define __x86_64__ 1',
	'#define __FLT32X_MIN_EXP__ (-1021)',
	'#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF',
	'#define __INT_FAST16_MAX__ 0x7fffffffffffffffL',
	'#define __FLT64_DIG__ 15',
	'#define __UINT_FAST32_MAX__ 0xffffffffffffffffUL',
	'#define __UINT_LEAST64_TYPE__ long unsigned int',
	'#define __FLT_HAS_QUIET_NAN__ 1',
	'#define __FLT_MAX_10_EXP__ 38',
	'#define __LONG_MAX__ 0x7fffffffffffffffL',
	'#define __FLT64X_HAS_DENORM__ 1',
	'#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL',
	'#define __FLT_HAS_INFINITY__ 1',
	'#define __UINT_FAST16_TYPE__ long unsigned int',
	'#define __DEC64_MAX__ 9.999999999999999E384DD',
	'#define __INT_FAST32_WIDTH__ 64',
	'#define __CHAR16_TYPE__ short unsigned int',
	'#define __PRAGMA_REDEFINE_EXTNAME 1',
	'#define __SIZE_WIDTH__ 64',
	'#define __SEG_FS 1',
	'#define __INT_LEAST16_MAX__ 0x7fff',
	'#define __DEC64_MANT_DIG__ 16',
	'#define __INT64_MAX__ 0x7fffffffffffffffL',
	'#define __UINT_LEAST32_MAX__ 0xffffffffU',
	'#define __SEG_GS 1',
	'#define __FLT32_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F32',
	'#define __GCC_ATOMIC_LONG_LOCK_FREE 2',
	'#define __SIG_ATOMIC_WIDTH__ 32',
	'#define __INT_LEAST64_TYPE__ long int',
	'#define __INT16_TYPE__ short int',
	'#define __INT_LEAST8_TYPE__ signed char',
	'#define __STDC_VERSION__ 201112L',
	'#define __DEC32_MAX_EXP__ 97',
	'#define __INT_FAST8_MAX__ 0x7f',
	'#define __FLT128_MAX__ 1.18973149535723176508575932662800702e+4932F128',
	'#define __INTPTR_MAX__ 0x7fffffffffffffffL',
	'#define linux 1',
	'#define __FLT64_HAS_QUIET_NAN__ 1',
	'#define __FLT32_MIN_10_EXP__ (-37)',
	'#define __SSE2__ 1',
	'#define __FLT32X_DIG__ 15',
	'#define __LDBL_MANT_DIG__ 64',
	'#define __DBL_HAS_QUIET_NAN__ 1',
	'#define __FLT64_HAS_INFINITY__ 1',
	'#define __FLT64X_MAX__ 1.18973149535723176502126385303097021e+4932F64x',
	'#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)',
	'#define __code_model_small__ 1',
	'#define __k8__ 1',
	'#define __INTPTR_TYPE__ long int',
	'#define __UINT16_TYPE__ short unsigned int',
	'#define __WCHAR_TYPE__ int',
	'#define __SIZEOF_FLOAT__ 4',
	'#define __pic__ 2',
	'#define __UINTPTR_MAX__ 0xffffffffffffffffUL',
	'#define __INT_FAST64_WIDTH__ 64',
	'#define __DEC64_MIN_EXP__ (-382)',
	'#define __FLT32_DECIMAL_DIG__ 9',
	'#define __INT_FAST64_MAX__ 0x7fffffffffffffffL',
	'#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1',
	'#define __FLT_DIG__ 6',
	'#define __FLT32_HAS_INFINITY__ 1',
	'#define __FLT64X_MAX_EXP__ 16384',
	'#define __UINT_FAST64_TYPE__ long unsigned int',
	'#define __INT_MAX__ 0x7fffffff',
	'#define __amd64__ 1',
	'#define __INT64_TYPE__ long int',
	'#define __FLT_MAX_EXP__ 128',
	'#define __ORDER_BIG_ENDIAN__ 4321',
	'#define __DBL_MANT_DIG__ 53',
	'#define __SIZEOF_FLOAT128__ 16',
	'#define __INT_LEAST64_MAX__ 0x7fffffffffffffffL',
	'#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2',
	'#define __DEC64_MIN__ 1E-383DD',
	'#define __WINT_TYPE__ unsigned int',
	'#define __UINT_LEAST32_TYPE__ unsigned int',
	'#define __SIZEOF_SHORT__ 2',
	'#define __SSE__ 1',
	'#define __LDBL_MIN_EXP__ (-16381)',
	'#define __FLT64_MAX__ 1.79769313486231570814527423731704357e+308F64',
	'#define __WINT_WIDTH__ 32',
	'#define __INT_LEAST8_MAX__ 0x7f',
	'#define __FLT32X_MAX_10_EXP__ 308',
	'#define __SIZEOF_INT128__ 16',
	'#define __LDBL_MAX_10_EXP__ 4932',
	'#define __ATOMIC_RELAXED 0',
	'#define __DBL_EPSILON__ ((double)2.22044604925031308084726333618164062e-16L)',
	'#define __FLT128_MIN__ 3.36210314311209350626267781732175260e-4932F128',
	'#define _LP64 1',
	'#define __UINT8_C(c) c',
	'#define __FLT64_MAX_EXP__ 1024',
	'#define __INT_LEAST32_TYPE__ int',
	'#define __SIZEOF_WCHAR_T__ 4',
	'#define __UINT64_TYPE__ long unsigned int',
	'#define __FLT128_HAS_QUIET_NAN__ 1',
	'#define __INT_FAST8_TYPE__ signed char',
	'#define __FLT64X_MIN__ 3.36210314311209350626267781732175260e-4932F64x',
	'#define __GNUC_STDC_INLINE__ 1',
	'#define __FLT64_HAS_DENORM__ 1',
	'#define __FLT32_EPSILON__ 1.19209289550781250000000000000000000e-7F32',
	'#define __DBL_DECIMAL_DIG__ 17',
	'#define __STDC_UTF_32__ 1',
	'#define __INT_FAST8_WIDTH__ 8',
	'#define __FXSR__ 1',
	'#define __DEC_EVAL_METHOD__ 2',
	'#define __FLT32X_MAX__ 1.79769313486231570814527423731704357e+308F32x',
	'#define __UINT32_C(c) c ## U',
	'#define __INTMAX_MAX__ 0x7fffffffffffffffL',
	'#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__',
	'#define __FLT_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F',
	'#define __INT8_MAX__ 0x7f',
	'#define __LONG_WIDTH__ 64',
	'#define __PIC__ 2',
	'#define __UINT_FAST32_TYPE__ long unsigned int',
	'#define __CHAR32_TYPE__ unsigned int',
	'#define __FLT_MAX__ 3.40282346638528859811704183484516925e+38F',
	'#define __INT32_TYPE__ int',
	'#define __SIZEOF_DOUBLE__ 8',
	'#define __FLT_MIN_10_EXP__ (-37)',
	'#define __FLT64_MIN__ 2.22507385850720138309023271733240406e-308F64',
	'#define __INT_LEAST32_WIDTH__ 32',
	'#define __INTMAX_TYPE__ long int',
	'#define __DEC128_MAX_EXP__ 6145',
	'#define __FLT32X_HAS_QUIET_NAN__ 1',
	'#define __ATOMIC_CONSUME 1',
	'#define __GNUC_MINOR__ 4',
	'#define __INT_FAST16_WIDTH__ 64',
	'#define __UINTMAX_MAX__ 0xffffffffffffffffUL',
	'#define __DEC32_MANT_DIG__ 7',
	'#define __FLT32X_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F32x',
	'#define __DBL_MAX_10_EXP__ 308',
	'#define __LDBL_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951L',
	'#define __INT16_C(c) c',
	'#define __STDC__ 1',
	'#define __PTRDIFF_TYPE__ long int',
	'#define __ATOMIC_SEQ_CST 5',
	'#define __UINT32_TYPE__ unsigned int',
	'#define __FLT32X_MIN_10_EXP__ (-307)',
	'#define __UINTPTR_TYPE__ long unsigned int',
	'#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD',
	'#define __DEC128_MANT_DIG__ 34',
	'#define __LDBL_MIN_10_EXP__ (-4931)',
	'#define __FLT128_EPSILON__ 1.92592994438723585305597794258492732e-34F128',
	'#define __SIZEOF_LONG_LONG__ 8',
	'#define __FLT128_DECIMAL_DIG__ 36',
	'#define __GCC_ATOMIC_LLONG_LOCK_FREE 2',
	'#define __FLT32X_MIN__ 2.22507385850720138309023271733240406e-308F32x',
	'#define __LDBL_DIG__ 18',
	'#define __FLT_DECIMAL_DIG__ 9',
	'#define __UINT_FAST16_MAX__ 0xffffffffffffffffUL',
	'#define __GCC_ATOMIC_SHORT_LOCK_FREE 2',
	'#define __INT_LEAST64_WIDTH__ 64',
	'#define __UINT_FAST8_TYPE__ unsigned char',
	'#define __ATOMIC_ACQ_REL 4',
	'#define __ATOMIC_RELEASE 3'
	]

builtinMacros = {
					'__SSP_STRONG__'  						:  ['#define', '__SSP_STRONG__', '3'],
					'__DBL_MIN_EXP__'  						:  ['#define', '__DBL_MIN_EXP__', '(-1021)'],
					'__FLT32X_MAX_EXP__'  					:  ['#define', '__FLT32X_MAX_EXP__', '1024'],
					'__UINT_LEAST16_MAX__'  				:  ['#define', '__UINT_LEAST16_MAX__', '0xffff'],
					'__ATOMIC_ACQUIRE'  					:  ['#define', '__ATOMIC_ACQUIRE', '2'],
					'__FLT128_MAX_10_EXP__'  				:  ['#define', '__FLT128_MAX_10_EXP__', '4932'],
					'__FLT_MIN__'  							:  ['#define', '__FLT_MIN__', '1.17549435082228750796873653722224568e-38F'],
					'__GCC_IEC_559_COMPLEX'  				:  ['#define', '__GCC_IEC_559_COMPLEX', '2'],
					'__UINT_LEAST8_TYPE__'  				:  ['#define', '__UINT_LEAST8_TYPE__', 'unsigned char'],
					'__SIZEOF_FLOAT80__'  					:  ['#define', '__SIZEOF_FLOAT80__', '16'],
					'__INTMAX_C(c)'  						:  ['#define', '__INTMAX_C','(','c',')', 'c', '##', 'L'],
					'__CHAR_BIT__'  						:  ['#define', '__CHAR_BIT__', '8'],
					'__UINT8_MAX__'  						:  ['#define', '__UINT8_MAX__', '0xff'],
					'__WINT_MAX__'  						:  ['#define', '__WINT_MAX__', '0xffffffffU'],
					'__FLT32_MIN_EXP__'  					:  ['#define', '__FLT32_MIN_EXP__', '(-125)'],
					'__ORDER_LITTLE_ENDIAN__'  				:  ['#define', '__ORDER_LITTLE_ENDIAN__', '1234'],
					'__SIZE_MAX__'  						:  ['#define', '__SIZE_MAX__', '0xffffffffffffffffUL'],
					'__WCHAR_MAX__'  						:  ['#define', '__WCHAR_MAX__', '0x7fffffff'],
					'__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1'  	:  ['#define', '__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1', '1'],
					'__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2'  	:  ['#define', '__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2', '1'],
					'__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4'  	:  ['#define', '__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4', '1'],
					'__DBL_DENORM_MIN__'  					:  ['#define', '__DBL_DENORM_MIN__', '((double)4.94065645841246544176568792868221372e-324L)'],
					'__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8'  	:  ['#define', '__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8', '1'],
					'__GCC_ATOMIC_CHAR_LOCK_FREE'  			:  ['#define', '__GCC_ATOMIC_CHAR_LOCK_FREE', '2'],
					'__GCC_IEC_559'  						:  ['#define', '__GCC_IEC_559', '2'],
					'__FLT32X_DECIMAL_DIG__'  				:  ['#define', '__FLT32X_DECIMAL_DIG__', '17'],
					'__FLT_EVAL_METHOD__'  					:  ['#define', '__FLT_EVAL_METHOD__', '0'],
					'__unix__'  							:  ['#define', '__unix__', '1'],
					'__FLT64_DECIMAL_DIG__'  				:  ['#define', '__FLT64_DECIMAL_DIG__', '17'],
					'__GCC_ATOMIC_CHAR32_T_LOCK_FREE'  		:  ['#define', '__GCC_ATOMIC_CHAR32_T_LOCK_FREE', '2'],
					'__x86_64'  							:  ['#define', '__x86_64', '1'],
					'__UINT_FAST64_MAX__'  					:  ['#define', '__UINT_FAST64_MAX__', '0xffffffffffffffffUL'],
					'__SIG_ATOMIC_TYPE__'  					:  ['#define', '__SIG_ATOMIC_TYPE__', 'int'],
					'__DBL_MIN_10_EXP__'  					:  ['#define', '__DBL_MIN_10_EXP__', '(-307)'],
					'__FINITE_MATH_ONLY__'  				:  ['#define', '__FINITE_MATH_ONLY__', '0'],
					'__GNUC_PATCHLEVEL__'  					:  ['#define', '__GNUC_PATCHLEVEL__', '0'],
					'__FLT32_HAS_DENORM__'  				:  ['#define', '__FLT32_HAS_DENORM__', '1'],
					'__UINT_FAST8_MAX__'  					:  ['#define', '__UINT_FAST8_MAX__', '0xff'],
					'__has_include(STR)'  					:  ['#define', '__has_include(STR)', '__has_include__(STR)'],
					'__DEC64_MAX_EXP__'  					:  ['#define', '__DEC64_MAX_EXP__', '385'],
					'__INT8_C(c)'  							:  ['#define', '__INT8_C','(','c',')', 'c'],
					'__INT_LEAST8_WIDTH__'  				:  ['#define', '__INT_LEAST8_WIDTH__', '8'],
					'__UINT_LEAST64_MAX__'  				:  ['#define', '__UINT_LEAST64_MAX__', '0xffffffffffffffffUL'],
					'__SHRT_MAX__'  						:  ['#define', '__SHRT_MAX__', '0x7fff'],
					'__LDBL_MAX__'  						:  ['#define', '__LDBL_MAX__', '1.18973149535723176502126385303097021e+4932L'],
					'__FLT64X_MAX_10_EXP__'  				:  ['#define', '__FLT64X_MAX_10_EXP__', '4932'],
					'__UINT_LEAST8_MAX__'  					:  ['#define', '__UINT_LEAST8_MAX__', '0xff'],
					'__GCC_ATOMIC_BOOL_LOCK_FREE'  			:  ['#define', '__GCC_ATOMIC_BOOL_LOCK_FREE', '2'],
					'__FLT128_DENORM_MIN__'  				:  ['#define', '__FLT128_DENORM_MIN__', '6.47517511943802511092443895822764655e-4966F128'],
					'__UINTMAX_TYPE__'  					:  ['#define', '__UINTMAX_TYPE__', 'long unsigned int'],
					'__linux'  								:  ['#define', '__linux', '1'],
					'__DEC32_EPSILON__'  					:  ['#define', '__DEC32_EPSILON__', '1E-6DF'],
					'__FLT_EVAL_METHOD_TS_18661_3__'  		:  ['#define', '__FLT_EVAL_METHOD_TS_18661_3__', '0'],
					'__unix'  								:  ['#define', '__unix', '1'],
					'__UINT32_MAX__'  						:  ['#define', '__UINT32_MAX__', '0xffffffffU'],
					'__LDBL_MAX_EXP__'  					:  ['#define', '__LDBL_MAX_EXP__', '16384'],
					'__FLT128_MIN_EXP__'  					:  ['#define', '__FLT128_MIN_EXP__', '(-16381)'],
					'__WINT_MIN__'  						:  ['#define', '__WINT_MIN__', '0U'],
					'__linux__'  							:  ['#define', '__linux__', '1'],
					'__FLT128_MIN_10_EXP__'  				:  ['#define', '__FLT128_MIN_10_EXP__', '(-4931)'],
					'__INT_LEAST16_WIDTH__'  				:  ['#define', '__INT_LEAST16_WIDTH__', '16'],
					'__SCHAR_MAX__'  						:  ['#define', '__SCHAR_MAX__', '0x7f'],
					'__FLT128_MANT_DIG__'  					:  ['#define', '__FLT128_MANT_DIG__', '113'],
					'__WCHAR_MIN__'  						:  ['#define', '__WCHAR_MIN__', '(-__WCHAR_MAX__ - 1)'],
					'__INT64_C(c)'  						:  ['#define', '__INT64_C','(','c',')', 'c', '##', 'L'],
					'__DBL_DIG__'  							:  ['#define', '__DBL_DIG__', '15'],
					'__GCC_ATOMIC_POINTER_LOCK_FREE'  		:  ['#define', '__GCC_ATOMIC_POINTER_LOCK_FREE', '2'],
					'__FLT64X_MANT_DIG__'  					:  ['#define', '__FLT64X_MANT_DIG__', '64'],
					'__SIZEOF_INT__'  						:  ['#define', '__SIZEOF_INT__', '4'],
					'__SIZEOF_POINTER__'  					:  ['#define', '__SIZEOF_POINTER__', '8'],
					'__USER_LABEL_PREFIX__'  				:  ['#define', '__USER_LABEL_PREFIX__', ''],
					'__FLT64X_EPSILON__'  					:  ['#define', '__FLT64X_EPSILON__', '1.08420217248550443400745280086994171e-19F64x'],
					'__STDC_HOSTED__'  						:  ['#define', '__STDC_HOSTED__', '1'],
					'__LDBL_HAS_INFINITY__'  				:  ['#define', '__LDBL_HAS_INFINITY__', '1'],
					'__FLT32_DIG__'  						:  ['#define', '__FLT32_DIG__', '6'],
					'__FLT_EPSILON__'  						:  ['#define', '__FLT_EPSILON__', '1.19209289550781250000000000000000000e-7F'],
					'__SHRT_WIDTH__'  						:  ['#define', '__SHRT_WIDTH__', '16'],
					'__LDBL_MIN__'  						:  ['#define', '__LDBL_MIN__', '3.36210314311209350626267781732175260e-4932L'],
					'__STDC_UTF_16__'  						:  ['#define', '__STDC_UTF_16__', '1'],
					'__DEC32_MAX__'  						:  ['#define', '__DEC32_MAX__', '9.999999E96DF'],
					'__FLT64X_DENORM_MIN__'  				:  ['#define', '__FLT64X_DENORM_MIN__', '3.64519953188247460252840593361941982e-4951F64x'],
					'__FLT32X_HAS_INFINITY__'  				:  ['#define', '__FLT32X_HAS_INFINITY__', '1'],
					'__INT32_MAX__'  						:  ['#define', '__INT32_MAX__', '0x7fffffff'],
					'__INT_WIDTH__'  						:  ['#define', '__INT_WIDTH__', '32'],
					'__SIZEOF_LONG__'  						:  ['#define', '__SIZEOF_LONG__', '8'],
					'__STDC_IEC_559__'  					:  ['#define', '__STDC_IEC_559__', '1'],
					'__STDC_ISO_10646__'  					:  ['#define', '__STDC_ISO_10646__', '201706L'],
					'__UINT16_C(c)'  						:  ['#define', '__UINT16_C(c)', 'c'],
					'__PTRDIFF_WIDTH__'  					:  ['#define', '__PTRDIFF_WIDTH__', '64'],
					'__DECIMAL_DIG__'  						:  ['#define', '__DECIMAL_DIG__', '21'],
					'__FLT64_EPSILON__'  					:  ['#define', '__FLT64_EPSILON__', '2.22044604925031308084726333618164062e-16F64'],
					'__gnu_linux__'  						:  ['#define', '__gnu_linux__', '1'],
					'__INTMAX_WIDTH__'  					:  ['#define', '__INTMAX_WIDTH__', '64'],
					'__has_include_next(STR)'  				:  ['#define', '__has_include_next','(','STR',')', '__has_include_next__', '(', 'STR', ')'],
					'__FLT64X_MIN_10_EXP__'  				:  ['#define', '__FLT64X_MIN_10_EXP__', '(-4931)'],
					'__LDBL_HAS_QUIET_NAN__'  				:  ['#define', '__LDBL_HAS_QUIET_NAN__', '1'],
					'__FLT64_MANT_DIG__'  					:  ['#define', '__FLT64_MANT_DIG__', '53'],
					'__GNUC__'  							:  ['#define', '__GNUC__', '7'],
					'__pie__'  								:  ['#define', '__pie__', '2'],
					'__MMX__'  								:  ['#define', '__MMX__', '1'],
					'__FLT_HAS_DENORM__'  					:  ['#define', '__FLT_HAS_DENORM__', '1'],
					'__SIZEOF_LONG_DOUBLE__'  				:  ['#define', '__SIZEOF_LONG_DOUBLE__', '16'],
					'__BIGGEST_ALIGNMENT__'  				:  ['#define', '__BIGGEST_ALIGNMENT__', '16'],
					'__FLT64_MAX_10_EXP__'  				:  ['#define', '__FLT64_MAX_10_EXP__', '308'],
					'__DBL_MAX__'  							:  ['#define', '__DBL_MAX__', '((double)1.79769313486231570814527423731704357e+308L)'],
					'__INT_FAST32_MAX__'  					:  ['#define', '__INT_FAST32_MAX__', '0x7fffffffffffffffL'],
					'__DBL_HAS_INFINITY__'  				:  ['#define', '__DBL_HAS_INFINITY__', '1'],
					'__DEC32_MIN_EXP__'  					:  ['#define', '__DEC32_MIN_EXP__', '(-94)'],
					'__INTPTR_WIDTH__'  					:  ['#define', '__INTPTR_WIDTH__', '64'],
					'__FLT32X_HAS_DENORM__'  				:  ['#define', '__FLT32X_HAS_DENORM__', '1'],
					'__INT_FAST16_TYPE__'  					:  ['#define', '__INT_FAST16_TYPE__', 'long int'],
					'__LDBL_HAS_DENORM__'  					:  ['#define', '__LDBL_HAS_DENORM__', '1'],
					'__FLT128_HAS_INFINITY__'  				:  ['#define', '__FLT128_HAS_INFINITY__', '1'],
					'__DEC128_MAX__'  						:  ['#define', '__DEC128_MAX__', '9.999999999999999999999999999999999E6144DL'],
					'__INT_LEAST32_MAX__'  					:  ['#define', '__INT_LEAST32_MAX__', '0x7fffffff'],
					'__DEC32_MIN__'  						:  ['#define', '__DEC32_MIN__', '1E-95DF'],
					'__DBL_MAX_EXP__'  						:  ['#define', '__DBL_MAX_EXP__', '1024'],
					'__WCHAR_WIDTH__'  						:  ['#define', '__WCHAR_WIDTH__', '32'],
					'__FLT32_MAX__'  						:  ['#define', '__FLT32_MAX__', '3.40282346638528859811704183484516925e+38F32'],
					'__DEC128_EPSILON__'  					:  ['#define', '__DEC128_EPSILON__', '1E-33DL'],
					'__SSE2_MATH__'  						:  ['#define', '__SSE2_MATH__', '1'],
					'__ATOMIC_HLE_RELEASE'  				:  ['#define', '__ATOMIC_HLE_RELEASE', '131072'],
					'__PTRDIFF_MAX__'  						:  ['#define', '__PTRDIFF_MAX__', '0x7fffffffffffffffL'],
					'__amd64'  								:  ['#define', '__amd64', '1'],
					'__STDC_NO_THREADS__'  					:  ['#define', '__STDC_NO_THREADS__', '1'],
					'__ATOMIC_HLE_ACQUIRE'  				:  ['#define', '__ATOMIC_HLE_ACQUIRE', '65536'],
					'__FLT32_HAS_QUIET_NAN__'  				:  ['#define', '__FLT32_HAS_QUIET_NAN__', '1'],
					'__LONG_LONG_MAX__'  					:  ['#define', '__LONG_LONG_MAX__', '0x7fffffffffffffffLL'],
					'__SIZEOF_SIZE_T__'  					:  ['#define', '__SIZEOF_SIZE_T__', '8'],
					'__FLT64X_MIN_EXP__'  					:  ['#define', '__FLT64X_MIN_EXP__', '(-16381)'],
					'__SIZEOF_WINT_T__'  					:  ['#define', '__SIZEOF_WINT_T__', '4'],
					'__LONG_LONG_WIDTH__'  					:  ['#define', '__LONG_LONG_WIDTH__', '64'],
					'__FLT32_MAX_EXP__'  					:  ['#define', '__FLT32_MAX_EXP__', '128'],
					'__GCC_HAVE_DWARF2_CFI_ASM'  			:  ['#define', '__GCC_HAVE_DWARF2_CFI_ASM', '1'],
					'__GXX_ABI_VERSION'  					:  ['#define', '__GXX_ABI_VERSION', '1011'],
					'__FLT_MIN_EXP__'  						:  ['#define', '__FLT_MIN_EXP__', '(-125)'],
					'__FLT64X_HAS_QUIET_NAN__'  			:  ['#define', '__FLT64X_HAS_QUIET_NAN__', '1'],
					'__INT_FAST64_TYPE__'  					:  ['#define', '__INT_FAST64_TYPE__', 'long int'],
					'__FLT64_DENORM_MIN__'  				:  ['#define', '__FLT64_DENORM_MIN__', '4.94065645841246544176568792868221372e-324F64'],
					'__DBL_MIN__'  							:  ['#define', '__DBL_MIN__', '((double)2.22507385850720138309023271733240406e-308L)'],
					'__PIE__'  								:  ['#define', '__PIE__', '2'],
					'__LP64__'  							:  ['#define', '__LP64__', '1'],
					'__FLT32X_EPSILON__'  					:  ['#define', '__FLT32X_EPSILON__', '2.22044604925031308084726333618164062e-16F32x'],
					'__DECIMAL_BID_FORMAT__'  				:  ['#define', '__DECIMAL_BID_FORMAT__', '1'],
					'__FLT64_MIN_EXP__'  					:  ['#define', '__FLT64_MIN_EXP__', '(-1021)'],
					'__FLT64_MIN_10_EXP__'  				:  ['#define', '__FLT64_MIN_10_EXP__', '(-307)'],
					'__FLT64X_DECIMAL_DIG__'  				:  ['#define', '__FLT64X_DECIMAL_DIG__', '21'],
					'__DEC128_MIN__'  						:  ['#define', '__DEC128_MIN__', '1E-6143DL'],
					'__REGISTER_PREFIX__'  					:  ['#define', '__REGISTER_PREFIX__', ''],
					'__UINT16_MAX__'  						:  ['#define', '__UINT16_MAX__', '0xffff'],
					'__DBL_HAS_DENORM__'  					:  ['#define', '__DBL_HAS_DENORM__', '1'],
					'__FLT32_MIN__'  						:  ['#define', '__FLT32_MIN__', '1.17549435082228750796873653722224568e-38F32'],
					'__UINT8_TYPE__'  						:  ['#define', '__UINT8_TYPE__', 'unsigned char'],
					'__NO_INLINE__'  						:  ['#define', '__NO_INLINE__', '1'],
					'__FLT_MANT_DIG__'  					:  ['#define', '__FLT_MANT_DIG__', '24'],
					'__LDBL_DECIMAL_DIG__'  				:  ['#define', '__LDBL_DECIMAL_DIG__', '21'],
					'__VERSION__'  							:  ['#define', '__VERSION__', '7.4.0'],
					'__UINT64_C(c)'  						:  ['#define', '__UINT64_C','(','c',')', 'c', '##', 'UL'],
					'_STDC_PREDEF_H'  						:  ['#define', '_STDC_PREDEF_H', '1'],
					'__GCC_ATOMIC_INT_LOCK_FREE'  			:  ['#define', '__GCC_ATOMIC_INT_LOCK_FREE', '2'],
					'__FLT128_MAX_EXP__'  					:  ['#define', '__FLT128_MAX_EXP__', '16384'],
					'__FLT32_MANT_DIG__'  					:  ['#define', '__FLT32_MANT_DIG__', '24'],
					'__FLOAT_WORD_ORDER__'  				:  ['#define', '__FLOAT_WORD_ORDER__', '__ORDER_LITTLE_ENDIAN__'],
					'__STDC_IEC_559_COMPLEX__'  			:  ['#define', '__STDC_IEC_559_COMPLEX__', '1'],
					'__FLT128_HAS_DENORM__'  				:  ['#define', '__FLT128_HAS_DENORM__', '1'],
					'__FLT128_DIG__'  						:  ['#define', '__FLT128_DIG__', '33'],
					'__SCHAR_WIDTH__'  						:  ['#define', '__SCHAR_WIDTH__', '8'],
					'__INT32_C(c)'  						:  ['#define', '__INT32_C','(','c',')', 'c'],
					'__DEC64_EPSILON__'  					:  ['#define', '__DEC64_EPSILON__', '1E-15DD'],
					'__ORDER_PDP_ENDIAN__'  				:  ['#define', '__ORDER_PDP_ENDIAN__', '3412'],
					'__DEC128_MIN_EXP__'  					:  ['#define', '__DEC128_MIN_EXP__', '(-6142)'],
					'__FLT32_MAX_10_EXP__'  				:  ['#define', '__FLT32_MAX_10_EXP__', '38'],
					'__INT_FAST32_TYPE__'  					:  ['#define', '__INT_FAST32_TYPE__', 'long int'],
					'__UINT_LEAST16_TYPE__'  				:  ['#define', '__UINT_LEAST16_TYPE__', 'short unsigned int'],
					'__FLT64X_HAS_INFINITY__'  				:  ['#define', '__FLT64X_HAS_INFINITY__', '1'],
					'unix'  								:  ['#define', 'unix', '1'],
					'__INT16_MAX__'  						:  ['#define', '__INT16_MAX__', '0x7fff'],
					'__SIZE_TYPE__'  						:  ['#define', '__SIZE_TYPE__', 'long unsigned int'],
					'__UINT64_MAX__'  						:  ['#define', '__UINT64_MAX__', '0xffffffffffffffffUL'],
					'__FLT64X_DIG__'  						:  ['#define', '__FLT64X_DIG__', '18'],
					'__INT8_TYPE__'  						:  ['#define', '__INT8_TYPE__', 'signed char'],
					'__ELF__'  								:  ['#define', '__ELF__', '1'],
					'__GCC_ASM_FLAG_OUTPUTS__'  			:  ['#define', '__GCC_ASM_FLAG_OUTPUTS__', '1'],
					'__FLT_RADIX__'  						:  ['#define', '__FLT_RADIX__', '2'],
					'__INT_LEAST16_TYPE__'  				:  ['#define', '__INT_LEAST16_TYPE__', 'short int'],
					'__LDBL_EPSILON__'  					:  ['#define', '__LDBL_EPSILON__', '1.08420217248550443400745280086994171e-19L'],
					'__UINTMAX_C(c)'  						:  ['#define', '__UINTMAX_C','(','c',')', 'c', '##', 'UL'],
					'__SSE_MATH__'  						:  ['#define', '__SSE_MATH__', '1'],
					'__k8'  								:  ['#define', '__k8', '1'],
					'__SIG_ATOMIC_MAX__'  					:  ['#define', '__SIG_ATOMIC_MAX__', '0x7fffffff'],
					'__GCC_ATOMIC_WCHAR_T_LOCK_FREE'  		:  ['#define', '__GCC_ATOMIC_WCHAR_T_LOCK_FREE', '2'],
					'__SIZEOF_PTRDIFF_T__'  				:  ['#define', '__SIZEOF_PTRDIFF_T__', '8'],
					'__FLT32X_MANT_DIG__'  					:  ['#define', '__FLT32X_MANT_DIG__', '53'],
					'__x86_64__'  							:  ['#define', '__x86_64__', '1'],
					'__FLT32X_MIN_EXP__'  					:  ['#define', '__FLT32X_MIN_EXP__', '(-1021)'],
					'__DEC32_SUBNORMAL_MIN__'  				:  ['#define', '__DEC32_SUBNORMAL_MIN__', '0.000001E-95DF'],
					'__INT_FAST16_MAX__'  					:  ['#define', '__INT_FAST16_MAX__', '0x7fffffffffffffffL'],
					'__FLT64_DIG__'  						:  ['#define', '__FLT64_DIG__', '15'],
					'__UINT_FAST32_MAX__'  					:  ['#define', '__UINT_FAST32_MAX__', '0xffffffffffffffffUL'],
					'__UINT_LEAST64_TYPE__'  				:  ['#define', '__UINT_LEAST64_TYPE__', 'long unsigned int'],
					'__FLT_HAS_QUIET_NAN__'  				:  ['#define', '__FLT_HAS_QUIET_NAN__', '1'],
					'__FLT_MAX_10_EXP__'  					:  ['#define', '__FLT_MAX_10_EXP__', '38'],
					'__LONG_MAX__'  						:  ['#define', '__LONG_MAX__', '0x7fffffffffffffffL'],
					'__FLT64X_HAS_DENORM__'  				:  ['#define', '__FLT64X_HAS_DENORM__', '1'],
					'__DEC128_SUBNORMAL_MIN__'  			:  ['#define', '__DEC128_SUBNORMAL_MIN__', '0.000000000000000000000000000000001E-6143DL'],
					'__FLT_HAS_INFINITY__'  				:  ['#define', '__FLT_HAS_INFINITY__', '1'],
					'__UINT_FAST16_TYPE__'  				:  ['#define', '__UINT_FAST16_TYPE__', 'long unsigned int'],
					'__DEC64_MAX__'  						:  ['#define', '__DEC64_MAX__', '9.999999999999999E384DD'],
					'__INT_FAST32_WIDTH__'  				:  ['#define', '__INT_FAST32_WIDTH__', '64'],
					'__CHAR16_TYPE__'  						:  ['#define', '__CHAR16_TYPE__', 'short unsigned int'],
					'__PRAGMA_REDEFINE_EXTNAME'  			:  ['#define', '__PRAGMA_REDEFINE_EXTNAME', '1'],
					'__SIZE_WIDTH__'  						:  ['#define', '__SIZE_WIDTH__', '64'],
					'__SEG_FS'  							:  ['#define', '__SEG_FS', '1'],
					'__INT_LEAST16_MAX__'  					:  ['#define', '__INT_LEAST16_MAX__', '0x7fff'],
					'__DEC64_MANT_DIG__'  					:  ['#define', '__DEC64_MANT_DIG__', '16'],
					'__INT64_MAX__'  						:  ['#define', '__INT64_MAX__', '0x7fffffffffffffffL'],
					'__UINT_LEAST32_MAX__'  				:  ['#define', '__UINT_LEAST32_MAX__', '0xffffffffU'],
					'__SEG_GS'  							:  ['#define', '__SEG_GS', '1'],
					'__FLT32_DENORM_MIN__'  				:  ['#define', '__FLT32_DENORM_MIN__', '1.40129846432481707092372958328991613e-45F32'],
					'__GCC_ATOMIC_LONG_LOCK_FREE'  			:  ['#define', '__GCC_ATOMIC_LONG_LOCK_FREE', '2'],
					'__SIG_ATOMIC_WIDTH__'  				:  ['#define', '__SIG_ATOMIC_WIDTH__', '32'],
					'__INT_LEAST64_TYPE__'  				:  ['#define', '__INT_LEAST64_TYPE__', 'long int'],
					'__INT16_TYPE__'  						:  ['#define', '__INT16_TYPE__', 'short int'],
					'__INT_LEAST8_TYPE__'  					:  ['#define', '__INT_LEAST8_TYPE__', 'signed char'],
					'__STDC_VERSION__'  					:  ['#define', '__STDC_VERSION__', '201112L'],
					'__DEC32_MAX_EXP__'  					:  ['#define', '__DEC32_MAX_EXP__', '97'],
					'__INT_FAST8_MAX__'  					:  ['#define', '__INT_FAST8_MAX__', '0x7f'],
					'__FLT128_MAX__'  						:  ['#define', '__FLT128_MAX__', '1.18973149535723176508575932662800702e+4932F128'],
					'__INTPTR_MAX__'  						:  ['#define', '__INTPTR_MAX__', '0x7fffffffffffffffL'],
					'linux'  								:  ['#define', 'linux', '1'],
					'__FLT64_HAS_QUIET_NAN__'  				:  ['#define', '__FLT64_HAS_QUIET_NAN__', '1'],
					'__FLT32_MIN_10_EXP__'  				:  ['#define', '__FLT32_MIN_10_EXP__', '(-37)'],
					'__SSE2__'  							:  ['#define', '__SSE2__', '1'],
					'__FLT32X_DIG__'  						:  ['#define', '__FLT32X_DIG__', '15'],
					'__LDBL_MANT_DIG__'  					:  ['#define', '__LDBL_MANT_DIG__', '64'],
					'__DBL_HAS_QUIET_NAN__'  				:  ['#define', '__DBL_HAS_QUIET_NAN__', '1'],
					'__FLT64_HAS_INFINITY__'  				:  ['#define', '__FLT64_HAS_INFINITY__', '1'],
					'__FLT64X_MAX__'  						:  ['#define', '__FLT64X_MAX__', '1.18973149535723176502126385303097021e+4932F64x'],
					'__SIG_ATOMIC_MIN__'  					:  ['#define', '__SIG_ATOMIC_MIN__', '(-__SIG_ATOMIC_MAX__ - 1)'],
					'__code_model_small__'  				:  ['#define', '__code_model_small__', '1'],
					'__k8__'  								:  ['#define', '__k8__', '1'],
					'__INTPTR_TYPE__'  						:  ['#define', '__INTPTR_TYPE__', 'long int'],
					'__UINT16_TYPE__'  						:  ['#define', '__UINT16_TYPE__', 'short unsigned int'],
					'__WCHAR_TYPE__'  						:  ['#define', '__WCHAR_TYPE__', 'int'],
					'__SIZEOF_FLOAT__'  					:  ['#define', '__SIZEOF_FLOAT__', '4'],
					'__pic__'  								:  ['#define', '__pic__', '2'],
					'__UINTPTR_MAX__'  						:  ['#define', '__UINTPTR_MAX__', '0xffffffffffffffffUL'],
					'__INT_FAST64_WIDTH__'  				:  ['#define', '__INT_FAST64_WIDTH__', '64'],
					'__DEC64_MIN_EXP__'  					:  ['#define', '__DEC64_MIN_EXP__', '(-382)'],
					'__FLT32_DECIMAL_DIG__'  				:  ['#define', '__FLT32_DECIMAL_DIG__', '9'],
					'__INT_FAST64_MAX__'  					:  ['#define', '__INT_FAST64_MAX__', '0x7fffffffffffffffL'],
					'__GCC_ATOMIC_TEST_AND_SET_TRUEVAL'  	:  ['#define', '__GCC_ATOMIC_TEST_AND_SET_TRUEVAL', '1'],
					'__FLT_DIG__'  							:  ['#define', '__FLT_DIG__', '6'],
					'__FLT32_HAS_INFINITY__'  				:  ['#define', '__FLT32_HAS_INFINITY__', '1'],
					'__FLT64X_MAX_EXP__'  					:  ['#define', '__FLT64X_MAX_EXP__', '16384'],
					'__UINT_FAST64_TYPE__'  				:  ['#define', '__UINT_FAST64_TYPE__', 'long unsigned int'],
					'__INT_MAX__'  							:  ['#define', '__INT_MAX__', '0x7fffffff'],
					'__amd64__'  							:  ['#define', '__amd64__', '1'],
					'__INT64_TYPE__'  						:  ['#define', '__INT64_TYPE__', 'long int'],
					'__FLT_MAX_EXP__'  						:  ['#define', '__FLT_MAX_EXP__', '128'],
					'__ORDER_BIG_ENDIAN__'  				:  ['#define', '__ORDER_BIG_ENDIAN__', '4321'],
					'__DBL_MANT_DIG__'  					:  ['#define', '__DBL_MANT_DIG__', '53'],
					'__SIZEOF_FLOAT128__'  					:  ['#define', '__SIZEOF_FLOAT128__', '16'],
					'__INT_LEAST64_MAX__'  					:  ['#define', '__INT_LEAST64_MAX__', '0x7fffffffffffffffL'],
					'__GCC_ATOMIC_CHAR16_T_LOCK_FREE'  		:  ['#define', '__GCC_ATOMIC_CHAR16_T_LOCK_FREE', '2'],
					'__DEC64_MIN__'  						:  ['#define', '__DEC64_MIN__', '1E-383DD'],
					'__WINT_TYPE__'  						:  ['#define', '__WINT_TYPE__', 'unsigned int'],
					'__UINT_LEAST32_TYPE__'  				:  ['#define', '__UINT_LEAST32_TYPE__', 'unsigned int'],
					'__SIZEOF_SHORT__'  					:  ['#define', '__SIZEOF_SHORT__', '2'],
					'__SSE__'  								:  ['#define', '__SSE__', '1'],
					'__LDBL_MIN_EXP__'  					:  ['#define', '__LDBL_MIN_EXP__', '(-16381)'],
					'__FLT64_MAX__'  						:  ['#define', '__FLT64_MAX__', '1.79769313486231570814527423731704357e+308F64'],
					'__WINT_WIDTH__'  						:  ['#define', '__WINT_WIDTH__', '32'],
					'__INT_LEAST8_MAX__'  					:  ['#define', '__INT_LEAST8_MAX__', '0x7f'],
					'__FLT32X_MAX_10_EXP__'  				:  ['#define', '__FLT32X_MAX_10_EXP__', '308'],
					'__SIZEOF_INT128__'  					:  ['#define', '__SIZEOF_INT128__', '16'],
					'__LDBL_MAX_10_EXP__'  					:  ['#define', '__LDBL_MAX_10_EXP__', '4932'],
					'__ATOMIC_RELAXED'  					:  ['#define', '__ATOMIC_RELAXED', '0'],
					'__DBL_EPSILON__'  						:  ['#define', '__DBL_EPSILON__', '((double)2.22044604925031308084726333618164062e-16L)'],
					'__FLT128_MIN__'  						:  ['#define', '__FLT128_MIN__', '3.36210314311209350626267781732175260e-4932F128'],
					'_LP64'  								:  ['#define', '_LP64', '1'],
					'__UINT8_C(c)'  						:  ['#define', '__UINT8_C','(','c',')', 'c'],
					'__FLT64_MAX_EXP__'  					:  ['#define', '__FLT64_MAX_EXP__', '1024'],
					'__INT_LEAST32_TYPE__'  				:  ['#define', '__INT_LEAST32_TYPE__', 'int'],
					'__SIZEOF_WCHAR_T__'  					:  ['#define', '__SIZEOF_WCHAR_T__', '4'],
					'__UINT64_TYPE__'  						:  ['#define', '__UINT64_TYPE__', 'long unsigned int'],
					'__FLT128_HAS_QUIET_NAN__'  			:  ['#define', '__FLT128_HAS_QUIET_NAN__', '1'],
					'__INT_FAST8_TYPE__'  					:  ['#define', '__INT_FAST8_TYPE__', 'signed char'],
					'__FLT64X_MIN__'  						:  ['#define', '__FLT64X_MIN__', '3.36210314311209350626267781732175260e-4932F64x'],
					'__GNUC_STDC_INLINE__'  				:  ['#define', '__GNUC_STDC_INLINE__', '1'],
					'__FLT64_HAS_DENORM__'  				:  ['#define', '__FLT64_HAS_DENORM__', '1'],
					'__FLT32_EPSILON__'  					:  ['#define', '__FLT32_EPSILON__', '1.19209289550781250000000000000000000e-7F32'],
					'__DBL_DECIMAL_DIG__'  					:  ['#define', '__DBL_DECIMAL_DIG__', '17'],
					'__STDC_UTF_32__'  						:  ['#define', '__STDC_UTF_32__', '1'],
					'__INT_FAST8_WIDTH__'  					:  ['#define', '__INT_FAST8_WIDTH__', '8'],
					'__FXSR__'  							:  ['#define', '__FXSR__', '1'],
					'__DEC_EVAL_METHOD__'  					:  ['#define', '__DEC_EVAL_METHOD__', '2'],
					'__FLT32X_MAX__'  						:  ['#define', '__FLT32X_MAX__', '1.79769313486231570814527423731704357e+308F32x'],
					'__UINT32_C(c)'  						:  ['#define', '__UINT32_C(c)', 'c ## U'],
					'__INTMAX_MAX__'  						:  ['#define', '__INTMAX_MAX__', '0x7fffffffffffffffL'],
					'__BYTE_ORDER__'  						:  ['#define', '__BYTE_ORDER__', '__ORDER_LITTLE_ENDIAN__'],
					'__FLT_DENORM_MIN__'  					:  ['#define', '__FLT_DENORM_MIN__', '1.40129846432481707092372958328991613e-45F'],
					'__INT8_MAX__'  						:  ['#define', '__INT8_MAX__', '0x7f'],
					'__LONG_WIDTH__'  						:  ['#define', '__LONG_WIDTH__', '64'],
					'__PIC__'  								:  ['#define', '__PIC__', '2'],
					'__UINT_FAST32_TYPE__'  				:  ['#define', '__UINT_FAST32_TYPE__', 'long unsigned int'],
					'__CHAR32_TYPE__'  						:  ['#define', '__CHAR32_TYPE__', 'unsigned int'],
					'__FLT_MAX__'  							:  ['#define', '__FLT_MAX__', '3.40282346638528859811704183484516925e+38F'],
					'__INT32_TYPE__'  						:  ['#define', '__INT32_TYPE__', 'int'],
					'__SIZEOF_DOUBLE__'  					:  ['#define', '__SIZEOF_DOUBLE__', '8'],
					'__FLT_MIN_10_EXP__'  					:  ['#define', '__FLT_MIN_10_EXP__', '(-37)'],
					'__FLT64_MIN__'  						:  ['#define', '__FLT64_MIN__', '2.22507385850720138309023271733240406e-308F64'],
					'__INT_LEAST32_WIDTH__'  				:  ['#define', '__INT_LEAST32_WIDTH__', '32'],
					'__INTMAX_TYPE__'  						:  ['#define', '__INTMAX_TYPE__', 'long int'],
					'__DEC128_MAX_EXP__'  					:  ['#define', '__DEC128_MAX_EXP__', '6145'],
					'__FLT32X_HAS_QUIET_NAN__'  			:  ['#define', '__FLT32X_HAS_QUIET_NAN__', '1'],
					'__ATOMIC_CONSUME'  					:  ['#define', '__ATOMIC_CONSUME', '1'],
					'__GNUC_MINOR__'  						:  ['#define', '__GNUC_MINOR__', '4'],
					'__INT_FAST16_WIDTH__'  				:  ['#define', '__INT_FAST16_WIDTH__', '64'],
					'__UINTMAX_MAX__'  						:  ['#define', '__UINTMAX_MAX__', '0xffffffffffffffffUL'],
					'__DEC32_MANT_DIG__'  					:  ['#define', '__DEC32_MANT_DIG__', '7'],
					'__FLT32X_DENORM_MIN__'  				:  ['#define', '__FLT32X_DENORM_MIN__', '4.94065645841246544176568792868221372e-324F32x'],
					'__DBL_MAX_10_EXP__'  					:  ['#define', '__DBL_MAX_10_EXP__', '308'],
					'__LDBL_DENORM_MIN__'  					:  ['#define', '__LDBL_DENORM_MIN__', '3.64519953188247460252840593361941982e-4951L'],
					'__INT16_C(c)'  						:  ['#define', '__INT16_C','(','c',')', 'c'],
					'__STDC__'  							:  ['#define', '__STDC__', '1'],
					'__PTRDIFF_TYPE__'  					:  ['#define', '__PTRDIFF_TYPE__', 'long int'],
					'__ATOMIC_SEQ_CST'  					:  ['#define', '__ATOMIC_SEQ_CST', '5'],
					'__UINT32_TYPE__'  						:  ['#define', '__UINT32_TYPE__', 'unsigned int'],
					'__FLT32X_MIN_10_EXP__'  				:  ['#define', '__FLT32X_MIN_10_EXP__', '(-307)'],
					'__UINTPTR_TYPE__'  					:  ['#define', '__UINTPTR_TYPE__', 'long unsigned int'],
					'__DEC64_SUBNORMAL_MIN__'  				:  ['#define', '__DEC64_SUBNORMAL_MIN__', '0.000000000000001E-383DD'],
					'__DEC128_MANT_DIG__'  					:  ['#define', '__DEC128_MANT_DIG__', '34'],
					'__LDBL_MIN_10_EXP__'  					:  ['#define', '__LDBL_MIN_10_EXP__', '(-4931)'],
					'__FLT128_EPSILON__'  					:  ['#define', '__FLT128_EPSILON__', '1.92592994438723585305597794258492732e-34F128'],
					'__SIZEOF_LONG_LONG__'  				:  ['#define', '__SIZEOF_LONG_LONG__', '8'],
					'__FLT128_DECIMAL_DIG__'  				:  ['#define', '__FLT128_DECIMAL_DIG__', '36'],
					'__GCC_ATOMIC_LLONG_LOCK_FREE'  		:  ['#define', '__GCC_ATOMIC_LLONG_LOCK_FREE', '2'],
					'__FLT32X_MIN__'  						:  ['#define', '__FLT32X_MIN__', '2.22507385850720138309023271733240406e-308F32x'],
					'__LDBL_DIG__'  						:  ['#define', '__LDBL_DIG__', '18'],
					'__FLT_DECIMAL_DIG__'  					:  ['#define', '__FLT_DECIMAL_DIG__', '9'],
					'__UINT_FAST16_MAX__'  					:  ['#define', '__UINT_FAST16_MAX__', '0xffffffffffffffffUL'],
					'__GCC_ATOMIC_SHORT_LOCK_FREE'  		:  ['#define', '__GCC_ATOMIC_SHORT_LOCK_FREE', '2'],
					'__INT_LEAST64_WIDTH__'  				:  ['#define', '__INT_LEAST64_WIDTH__', '64'],
					'__UINT_FAST8_TYPE__'  					:  ['#define', '__UINT_FAST8_TYPE__', 'unsigned char'],
					'__ATOMIC_ACQ_REL'  					:  ['#define', '__ATOMIC_ACQ_REL', '4'],
					'__ATOMIC_RELEASE'  					:  ['#define', '__ATOMIC_RELEASE', '3']
				}

##
##
## Below is the input structures that I use for demo:
##
demoCodeIndex = 0
demoCode = [

#
#
#	1.0 features (demoIndex = 0)
#
#

['enum { Sun, Mon, Tue};\n', 
'\n',
'//Observe that right now we are also \n',
'//mapping the typedef (can be turned off\n',
'//by clicking on button at the bottom.)\n',
'typedef struct \n',
'{\n',
'    uint32_t HDDsize;\n',
'    uint32_t sectors;\n',
'\n',
'    union\n',
'    {\n',
'        struct\n',
'        {\n',
'            uint32_t enabled:1;\n',
'            uint32_t field24:1;\n',
'            uint32_t field24_en:1;\n',
'            uint32_t field25:1;\n',
'            uint32_t field25_en:1;\n',
'            uint32_t  :0;\n',
'            uint32_t field26:1;\n',
'            uint32_t field26_en:1;\n',
'            uint32_t field27:1;\n',
'            uint32_t field27_en:1;\n',
'            uint32_t reserved:22;\n',
'            uint32_t special_en:1;\n',
'        };\n',
'        uint64_t manualCommand;\n',
'    };\n',
'    \n',
'    uint8_t  specialConfiguration[20];\n',
'} typeOneEntry_t;\n',
'\n',
'#define concat(x,y) x##y\n',
'int concat(a,b);\n',
'\n',
'#define ADD_ONE(x) x+1\n',
'#define if_less_then_add(x,y) (x<y?x:ADD_ONE(y))\n',
'#define BLANK\n',
'#define QUOTE "qu\\"ote"\n',
'#define SUM_UP( i,j) (i+j)\n',
'\n',
'//Use if-then-else by preprocessor\n',
'#define VERSION 1\n',
'\n',
'#if VERSION == 1\n',
'int oldVersion;\n',
'#else\n',
'int newVersion;\n',
'#endif\n',
'int school[2];\n',
'\n',
'//This example shows the interaction of \n',
'//various attributes and #pragma pack(n)\n',
'//The short s is extended to 8 bytes first, \n',
'//but then again brought down to 4 bytes \n',
'//due to #pragma pack(4)\n',
'// Hence we will have the following pads:\n',
'// 3 bytes after char c, 2 bytes after short s\n',
'\n',
'#pragma pack(4)\n',
'\n',
'struct __attribute__((packed)) N2 {\n',
'           char c;\n',
'           short s __attribute__((aligned(8)));\n',
'  } newVar;\n',
'\n',
'/* Thanos did nothing wrong */\n',
'\n',
'struct teacher\n',
'{\n',
'    char teachername[if_less_then_add(2+3,ADD_ONE(7-2)+9)]; // Hi there\n',
'    int salary[ADD_ONE(sizeof(school))];\n',
'}  t1,t2;\n',
'\n',
'\n',
'struct student\n',
'{\n',
'    int roll[SUM_UP(BLANK 0,2+3 BLANK )];\n',
'    //weird is a pointer\n',
'    void **(*(*weird)[6])(char, int);\n',
'    float marks;\n',
'    //weirder is a function, no storage allocated\n',
'    int (*Weirder(const char code)) (int, int) ;\n',
'    int INT[2][3][Tue];\n',
'} st;\n',
'\n',
'\n',
'union U{\n',
'	char CHAR;\n',
'	short SHORT;\n',
'	float FLOAT;\n',
'} u;\n',
'\n',
'typedef struct student STUDENT_TYPE, *POINTER_STUDENT_TYPE;\n',
'typedef POINTER_STUDENT_TYPE ARRAY_POINTER_STUDENT_TYPE[3];\n',
'ARRAY_POINTER_STUDENT_TYPE pStudent, *ppStudent;\n',
'\n',
'typedef int (*INT)[2](int), *pINT;              \n',
'typedef INT ppINT, *INT2[3];                    \n',
'INT2 i[5];\n',
'ppINT * typedefI1, **typedefI2[5];\n',
'\n',
'\n'],
#
#
#	Fearure # 1: Branching - Dynamic structures		(demoIndex = 1)
#
#
[
'struct parentDetails { \n',
'    unsigned char parentCount; \n',
'#if parentCount == 2 \n',
'    char parentName1[30]; \n',
'    char parentName2[30]; \n',
'#else \n',
'    char parentName[30]; \n',
'#endif \n',
'}; \n'
],

#
#
#	Branching - both statically and dynamically resolved conditions coexisting	(demoIndex = 2)
#
#
[
'#define CRYPTO_YEAR 2021 \n',
'#define TAX_YEAR    2021 \n',
' \n',
'struct taxDetails { \n',
'   unsigned char filerCount; \n',
'//condition resolved dynamically, during runtime\n',
'#if filerCount == 2 \n',
'   char filerName1[30]; \n',
'   char filerName2[30]; \n',
'#else \n',
'   char filerName[30]; \n',
'#endif \n',
'// condition resolved statically, during compile-time \n',
'#if TAX_YEAR >= CRYPTO_YEAR  \n',
'   int cryptoIncome; \n',
'#endif \n',
'}; \n'
],

#
#
#	Feature # 2: Variable length array (demoIndex = 3)
#
#
[
'struct variableLengthArrayMember {\n',
'  unsigned char packet_length;\n',
'  // We add 1 to avoid the 0-length case\n',
'  unsigned char packet_data[packet_length+1];\n',
'} Not_possible_in_C_structs; \n'
],
#
#
#	Feature # 3: Variable length Bitfield (demoIndex = 4)
#
#
[
'struct variableLengthBitfield {\n',
'  unsigned int num_flags:4;\n',
'  unsigned int bit_flags : num_flags;\n',
'} Not_possible_in_C_structs; \n'
],
#
#
# Feature # 4:	Verification via Initialization (demoIndex = 5):
#
#
['struct e_ident {	\n',
'   unsigned int magic_number = 0x464C457F;	\n',
'	unsigned char EI_CLASS;	\n',
'	unsigned char EI_DATA;		\n',
'	unsigned char EI_VERSION;	\n',
'	unsigned char EI_OSABI;	\n',
'	unsigned char EI_ABIVERSION;	\n',
'	unsigned char EI_PAD[7];		\n',
'} elf_identifier;	\n'
],
#
#
# Feature # 5: Looping and Dimension-less array  (demoIndex = 6):
#
#
[
'struct packet {\n',
'   unsigned char       packet_length;\n',
'  // We add 1 to avoid the 0-length case\n',
'   char packet_data [packet_length+1] ;\n',
'} packetArray [ ] ;  //Dimensionless array\n'
],

#
#
# Feature # 6: Speculative execution and C strings:  (demoIndex = 7,8):
#
#
[
'struct C_String {  \n',
'  // Dimensionless array  \n',
'  char Char[ ] ;  \n',
'     \n',
'  // Termination condition for it  \n',
'  char nullChar = 0;    \n',
'} C_string;  \n'

],
[
'struct C_String {  \n',
'  // Dimensionless array  \n',
'  char Char[ ] ;  \n',
'     \n',
'  // Termination condition for it  \n',
"  char nullChar = 0;    \n",
'};   \n',
'struct C_String Name[10];  \n'
],
#
#
# Feature # 7: Unknown Offset? No problemo!! 	(demoIndex = 9)
#
#
[
'\n',
'\n',
'\n',
'struct Initialization_tester {\n',
'  int preamble; \n',
'  int magic_number=0x0400FEFF;\n',
'  int size; \n',
'  int signature; \n',
'} var1;\n'
],
#
#
#	Speculative execition Initialization (demoIndex = 10)
#
#
[
'\n',
'int filler_junk[]; // No dimension specified\n',
'\n',
'struct Initialization_tester {\n',
'  int preamble; \n',
'  int magic_number=0x0400FEFF;\n',
'  int size; \n',
'  int signature; \n',
'} speculative_execution;\n'
],
##
##
##
##
##
## Real-life example for network packet header parsing using Dynamic structure: (demoIndex = 11)
##
##
##
##
[
'#define LITTLE_ENDIAN 0\n',
'#define BIG_ENDIAN 1\n',
'#define BYTE_ORDER BIG_ENDIAN\n',
'\n',
'#define PROTOCOL_NUM_ICMP	1\n',
'#define PROTOCOL_NUM_IPV4	4\n',
'#define PROTOCOL_NUM_TCP	6\n',
'#define PROTOCOL_NUM_UDP	17\n',
'#define PROTOCOL_NUM_IPV6	41\n',
'#define PROTOCOL_NUM_ETHERNET	143\n',
'\n',
'__attribute__((packed)) struct NW_Pkt_Hdr{\n',
'struct Ethernet_II_Header {\n',
'	char ethernet_MAC_addr_dest[6];\n',
'	char ethernet_MAC_addr_src[6];\n',
'	unsigned short ether_type;\n',
'} ethernet_II_header;\n',
'#if ether_type == 0x0008	//IPv4 (only this is supported right now)\n',
'struct IPv4_Header{\n',
'#if BYTE_ORDER == LITTLE_ENDIAN\n',
'  unsigned char  IPv4_header_length_word:4;  // 4-bit IPv4 version 4-bit header length (in 32-bit words)\n',
'  unsigned char  IPv4_version:4;\n',
'#elif BYTE_ORDER == BIG_ENDIAN\n',
'  unsigned char  IPv4_version:4;\n',
'  unsigned char  IPv4_header_length_word:4;  // 4-bit IPv4 version 4-bit header length (in 32-bit words)\n',
'#endif	\n',
'  unsigned char  IPv4_type_of_service;           \n',
'  unsigned short IPv4_total_length;   \n',
'  unsigned short IPv4_unique_identifier;\n',
'  struct FlagsAndFragment{\n',
'#if BYTE_ORDER == LITTLE_ENDIAN\n',
'    unsigned short IPv4_fragment_offset:13;\n',
'    unsigned short IPv4_more_fragments:1;\n',
'    unsigned short IPv4_dont_fragment:1;\n',
'    unsigned short IPv4_Reserved:1;\n',
'#elif BYTE_ORDER == BIG_ENDIAN\n',
'    unsigned short IPv4_Reserved:1;\n',
'    unsigned short IPv4_dont_fragment:1;\n',
'    unsigned short IPv4_more_fragments:1;\n',
'    unsigned short IPv4_fragment_offset:13;\n',
'#endif	\n',
'  } flags_and_fragment_offset;\n',
'  unsigned char  IPv4_time_to_live;           \n',
'  unsigned char  IPv4_protocol;      // TCP(6), UDP(17), ICMP(1) etc\n',
'  unsigned short IPv4_checksum;      \n',
'  unsigned int   IPv4_src_addr;       \n',
'  unsigned int   IPv4_dst_addr;      \n',
'} IPv4_header;\n',
'\n',
'#if IPv4_header.IPv4_protocol==PROTOCOL_NUM_ICMP\n',
'struct ICMP_Header{\n',
'  unsigned char   ICMP_message_type;\n',
'  unsigned char   ICMP_code;\n',
'  unsigned short  ICMP_checksum;\n',
'  unsigned short  ICMP_identifier;\n',
'  unsigned short  ICMP_sequence;\n',
'  unsigned char   ICMP_data[32];\n',
'} ICMP_header;\n',
'\n',
'#elif IPv4_header.IPv4_protocol==PROTOCOL_NUM_UDP\n',
'struct UDP_Header{\n',
'  unsigned short UDP_src_port_number;\n',
'  unsigned short UDP_dst_port_number;\n',
'  unsigned short UDP_packet_length;\n',
'  unsigned short UDP_checksum_optional;\n',     
'} UDP_header;\n',
'\n',
'#elif IPv4_header.IPv4_protocol==PROTOCOL_NUM_TCP\n',
'\n',
'//TCP Header structure as per RFC 793\n',
'struct TCP_Header {\n',
'  unsigned short TCP_src_port_number;\n',
'  unsigned short TCP_dst_port_number;\n',
'  unsigned int   TCP_sequence_number;\n',
'  unsigned int   TCP_acknowledgement_number;\n',
'#if BYTE_ORDER == LITTLE_ENDIAN\n',
'  unsigned int   TCP_x2_unused:4; \n',
'  unsigned int   TCP_data_offset:4;  \n',
'#endif\n',
'#if BYTE_ORDER == BIG_ENDIAN\n',
'  unsigned int   TCP_data_offset:4; \n',
'  unsigned int   TCP_x2_unused:4; \n',
'#endif\n',
'  union {\n',
'    unsigned char  TCP_flags_char;\n',
'    struct TCP_Individual_flags{\n',
'      unsigned char  TCP_flag_CWR:1;\n',
'      unsigned char  TCP_flag_ECE:1;\n',
'      unsigned char  TCP_flag_URG:1;\n',
'      unsigned char  TCP_flag_ACK:1;\n',
'      unsigned char  TCP_flag_PUSH:1;\n',
'      unsigned char  TCP_flag_RST:1;\n',
'      unsigned char  TCP_flag_SYN:1;\n',
'      unsigned char  TCP_flag_FIN:1;\n',
'    } TCP_individual_flags;\n',
'   } TCP_flags;\n',
'  unsigned short TCP_window;   \n',
'  unsigned short TCP_checksum;   \n',
'  unsigned short TCP_urgent_pointer; \n',  
'  // Optional header\n',
'  struct TCP_MSS {\n',
'    unsigned char TCP_max_segment_size;\n',
'	unsigned char TCP_MSS_length;\n',
'    unsigned short TCP_MSS_value;\n',
'  } TCP_mss;\n',
'  struct TCP_SACK{\n',
'    unsigned char TCP_SACK_permitted;\n',
'	unsigned char TCP_SACK_length;\n',
'  } TCP_sack;\n',
'  __attribute__((packed)) struct TCP_Timestamp {\n',
'    unsigned char TCP_TS_option;\n',
'    unsigned char TCP_TS_length;\n',
'    unsigned int TCP_TS_value;\n',
'    unsigned int TCP_TS_echo_reply;\n',
'   } TCP_timestamp ;\n',
'   unsigned char TCP_NOP;\n',
'   struct TCP_Windows_scale{\n',
'    unsigned char TCP_WS_scale;\n',
'    unsigned char TCP_WS_length;\n',
'    unsigned char TCP_WS_shift_count;\n',
'   } TCP_windows_scale;\n',
'} TCP_header ;\n',
'#endif\n',
'#endif\n',
'} NW_pkt_hdr[3];\n'
]

]
generalData =  "0xFFD8FFE000104A46494600010200000100010000FFFE00042A00FFE20BF84943"+"435F50524F46494C4500010100000BE800000000020000006D6E747252474220"		\
				+"58595A2007D90003001B00150024001F61637370000000000000000000000000"+"000000000000000100000000000000000000F6D6000100000000D32D00000000"		\
				+"29F83DDEAFF255AE7842FAE4CA83390D00000000000000000000000000000000"+"000000000000000000000000000000106465736300000144000000796258595A"		\
				+"000001C00000001462545243000001D40000080C646D6464000009E000000088"+"6758595A00000A680000001467545243000001D40000080C6C756D6900000A7C"		\
				+"000000146D65617300000A9000000024626B707400000AB4000000147258595A"+"00000AC80000001472545243000001D40000080C7465636800000ADC0000000C"		\
				+"7675656400000AE8000000877774707400000B70000000146370727400000B84"+"000000376368616400000BBC0000002C64657363000000000000001F73524742"		\
				+"2049454336313936362D322D3120626C61636B207363616C6564000000000000"+"0000000000000000000000000000000000000000000000000000000000000000"		\
				+"0000000000000000000000000000000000000000000000000000000000000000"+"00000000000000000000000058595A2000000000000024A000000F840000B6CF"		\
				+"63757276000000000000040000000005000A000F00140019001E00230028002D"+"00320037003B00400045004A004F00540059005E00630068006D00720077007C"		\
				+"00810086008B00900095009A009F00A400A900AE00B200B700BC00C100C600CB"+"00D000D500DB00E000E500EB00F000F600FB01010107010D01130119011F0125"		\
				+"012B01320138013E0145014C0152015901600167016E0175017C0183018B0192"+"019A01A101A901B101B901C101C901D101D901E101E901F201FA0203020C0214"		\
				+"021D0226022F02380241024B0254025D02670271027A0284028E029802A202AC"+"02B602C102CB02D502E002EB02F50300030B03160321032D03380343034F035A"		\
				+"03660372037E038A039603A203AE03BA03C703D303E003EC03F9040604130420"+"042D043B0448045504630471047E048C049A04A804B604C404D304E104F004FE"		\
				+"050D051C052B053A05490558056705770586059605A605B505C505D505E505F6"+"060606160627063706480659066A067B068C069D06AF06C006D106E306F50707"		\
				+"0719072B073D074F076107740786079907AC07BF07D207E507F8080B081F0832"+"0846085A086E0882089608AA08BE08D208E708FB09100925093A094F09640979"		\
				+"098F09A409BA09CF09E509FB0A110A270A3D0A540A6A0A810A980AAE0AC50ADC"+"0AF30B0B0B220B390B510B690B800B980BB00BC80BE10BF90C120C2A0C430C5C"
			

networkHdrs =  "0x484efcb41529645d863714c808004500003c44f5000080017e30c0a800948efb"+"276408004589000107d26162636465666768696a6b6c6d6e6f70717273747576"		\
				+"77616263646566676869645d863714c8484efcb4152908004500003c9c8f4000"+"40061c47c0a80001c0a8009487fe0b355ff89e4900000000a002721033050000"		\
				+"020405b40402080a8cca02c60000000001030306484efcb41529645d863714c8"+"080045000120a64c000080112322c0a80094d043dededcc101bb010c7eff"
				
ELF_header =   "0x7F454C4602010100000000000000000003003E00010000008005000000000000"+"4000000000000000801A0000000000000000000040003800090040001D001C00"		\
				+"0600000004000000400000000000000040000000000000004000000000000000"+"F801000000000000F80100000000000008000000000000000300000004000000"		\
				+"3802000000000000380200000000000038020000000000001C00000000000000"+"1C00000000000000010000000000000001000000050000000000000000000000"		\
				+"00000000000000000000000000000000E808000000000000E808000000000000"+"00002000000000000100000006000000B00D000000000000B00D200000000000"		\
				+"B00D200000000000000300000000000050030000000000000000200000000000"+"0200000006000000C00D000000000000C00D200000000000C00D200000000000"		\
				+"F001000000000000F00100000000000008000000000000000400000004000000"+"5402000000000000540200000000000054020000000000004400000000000000"		\
				+"4400000000000000040000000000000050E5746404000000A007000000000000"+"A007000000000000A0070000000000003C000000000000003C00000000000000"		\
				+"040000000000000051E574640600000000000000000000000000000000000000"+"0000000000000000000000000000000000000000000000001000000000000000"
				
CStrings =	   "0x467269656E64732C00526F6D616E732C00636F756E7472796D656E2C006C656E"+"64006D6500796F757200656172733B0D0A4900636F6D6500746F006275727900"		\
				+"4361657361722C006E6F7400746F007072616973650068696D2E0D0A54686500"+"6576696C0074686174006D656E00646F006C6976657300616674657200746865"		\
				+"6D3B0D0A54686500676F6F64006973006F667400696E74657272656400776974"+"6800746865697200626F6E65733B0D0A536F006C657400697400626500776974"		\
				+"68004361657361722E00546865006E6F626C65004272757475730D0A48617468"+"00746F6C6400796F75004361657361720077617300616D626974696F75733A0D"		\
				+"0A4966006974007765726500736F2C0069740077617300610067726965766F75"+"73006661756C742C0D0A416E640067726965766F75736C790068617468004361"		\
				+"6573617200616E73776572E28099640069742E0D0A486572652C00756E646572"+"006C65617665006F660042727574757300616E64007468650072657374E28093"		\
				+"0D0A466F720042727574757300697300616E00686F6E6F757261626C65006D61"+"6E3B0D0A536F00617265007468657900616C6C2C00616C6C00686F6E6F757261"		\
				+"626C65006D656EE280930D0A436F6D65004900746F00737065616B00696E0043"+"6165736172E28099730066756E6572616C2E0D0A486500776173006D79006672"

demoData = [generalData, generalData, generalData, generalData , generalData, ELF_header,  generalData, CStrings, CStrings, generalData, generalData, networkHdrs]



# Put all your include filepaths separated by semicolon here; for example, in the windows it might look like this
INCLUDE_FILE_PATHS = r"C:\Users\yourName\Documents\INCLUDE_FILE_DIR"

sys.stdout.write(str(sys.version_info))
PYTHON2x = True if (sys.version_info >= (2, 7, 0) and sys.version_info < (3, 0, 0)) else False
PYTHON3x = True if sys.version_info >= (3, 0, 0) else False

if PRINT_DEBUG_MSG != True and PRINT_DEBUG_MSG != False:
	sys.stdout.write("PRINT_DEBUG_MSG must be either True or False - exiting!")
	sys.exit()

if BATCHMODE not in (True, False):
	sys.stdout.write("BATCHMODE must be either True or False - exiting!")
	sys.exit()

#print (PYTHON2x)
#print (PYTHON3x)

if DISPLAY_INTEGRAL_VALUES_IN_HEX not in (True, False):
	sys.stdout.write("Currently, DISPLAY_INTEGRAL_VALUES_IN_HEX is NOT either True or False (must be one of them) - exiting!\n") 
	sys.exit()
	
if PYTHON2x and PYTHON3x:
	sys.stdout.write("BAD Coding, dummy!!! How come both Python 2 and Python 3 indicators are True?\n") 
	sys.exit()
elif not PYTHON2x and not PYTHON3x:
	sys.stdout.write("Unsupported version of Python!")
	sys.stdout.write(sys.version_info)
	sys.exit()
else:
	if PYTHON2x:
		sys.stdout.write(" Python 2.x\n" )
	if PYTHON3x:
		print (" Python 3.x\n")

if DEFAULT_ENDIANNESS not in (LITTLE_ENDIAN, BIG_ENDIAN):
	sys.stdout.write("\nDefault value of DEFAULT_ENDIANNESS must be either LITTLE_ENDIAN or BIG_ENDIAN\n" )
	sys.exit()

if BITFIELD_DEFAULT_ENDIANNESS not in (LITTLE_ENDIAN, BIG_ENDIAN):
	sys.stdout.write("\nDefault value of BITFIELD_DEFAULT_ENDIANNESS must be either LITTLE_ENDIAN or BIG_ENDIAN\n" )
	sys.exit()

if MAP_TYPEDEFS_TOO not in (True, False):
	sys.stdout.write("\nDefault value of MAP_TYPEDEFS_TOO must be either True or False\n" )
	sys.exit()

if len(anonymousStructPrefix.strip()) <2 or anonymousStructPrefix[-1] != "#":
	sys.stdout.write("\nanonymousStructPrefix must end with a \"#\" to ensure that it does not clash with a real struct/Union name\n" )
	sys.exit()
if len(dummyVariableNamePrefix.strip()) <2 or dummyVariableNamePrefix[-1] != "#":
	sys.stdout.write("\ndummyVariableNamePrefix must end with a \"#\" to ensure that it does not clash with a real variable name\n" )
	sys.exit()

def ORD(inputStr):
	if PYTHON2x:
		return ord(inputStr)
	elif PYTHON3x:
		if isinstance(inputStr,str):
			return ord(inputStr)
		elif isinstance(inputStr,(bytes,int)):
			return inputStr
		else:
			sys.stdout.write("ERROR in coding: Attempting to extract ordinal value from non-string object of type",type(inputStr))
			sys.exit()
	else:
		sys.stdout.write("Unsupported version of Python - ord() unavailable!")
		sys.exit()

def HEX(n):
	if not checkIfIntegral(n):
#		sys.stdout.write ("\nInside HEX: Input is NOT integral, Input type = ")
#		sys.stdout.write (str(type(n)))
		return n
	elif n < 0:
#		sys.stdout.write ("Inside HEX: Negative")
		return "-0x"+("%x"%(-n)).upper()
	else:
#		sys.stdout.write ("Inside HEX: Positive")
		return "0x"+("%x"%(n)).upper()
	
	
def checkIfBoolean(inputStr):
	if type(inputStr) == type(True):
		return True
	else:
		return False

# Python changed in v3 
def checkIfString(inputStr):
#	print ("inputStr = ", inputStr)
#	print ("type(inputStr) = <%s>"%type(inputStr))
	if PYTHON2x and isinstance(inputStr,basestring):
		return True
	elif PYTHON3x and isinstance(inputStr,str):
		return True
	else:
		return False

def checkIfIntegral(inputNum):
#	MUST_PRINT ("inputNum = ", inputNum)
#	MUST_PRINT ("type(inputNum) = <%s>"%type(inputNum))
	if checkIfString(inputNum) and re.match("^[0-9]+(L|UL|LU|LL|ULL|LLU|l|ul|lu|ll|ull|llu)$",inputNum):
#		MUST_PRINT("Compile-time constant",inputNum)
		inputNum = re.sub('[lLuU]','',inputNum)
#		MUST_PRINT("Compile-time constant changed to",inputNum)
	if PYTHON2x and (isinstance(inputNum,int) or isinstance(inputNum,long)):
		return True
	elif PYTHON3x and isinstance(inputNum,int):
#		MUST_PRINT("Returning True (as", inputNum,"is integer)")
		return True
	else:
#		MUST_PRINT("Returning False (as", inputNum,"is NOT integer)")
		return False


def checkIfStringIsNumeric(inputStr):
#	MUST_PRINT ("inputStr = ", inputStr)
#	MUST_PRINT ("type(inputStr) = <%s>"%type(inputStr))
	if PYTHON2x and isinstance(inputStr,basestring):
		if inputStr.isdigit():
			return True
		else:
			try:
				x = float(inputStr)
				return True
			except:
				return False
	elif PYTHON3x and isinstance(inputStr,str):
		result = inputStr.isnumeric()
#		MUST_PRINT("Returning",result)
		return result
	else:
#		MUST_PRINT("Returning False")
		return False

def checkIfNumber(inputNum):
#	print ("inputNum = ", inputNum)
#	print ("type(inputNum) = <%s>"%type(inputNum))
	if checkIfIntegral(inputNum) or isinstance(inputNum,float):
		return True
	else:
		return False

# This checks if the input is either a string, or a list comprised of similar lists and strings only
def checkIfStringOrListOfStrings(input):
#	print ("input = ", input)
#	print ("type(input) = <%s>"%type(input))
	if isinstance(input,list):
		for item in input:
			if not checkIfStringOrListOfStrings(item):
				return False
		return True
	else:
		return checkIfString(input)

# Do NOT use this function to convert things that are NOT supposed to be strings (like bytes)
def convert2Str(input):
	if checkIfString(input):
		return input
	elif isinstance(input,list):
		outputList = []
		for item in input:
			outputList.append(convert2Str(item))
		return outputList
	elif isinstance(input,dict):
		outputDictionary = {}
		for key, value in input.iteritems():
			strKey = convert2Str(key)
			strValue = convert2Str(value)
			outputDictionary[strKey] = strValue
		return outputDictionary
	elif PYTHON3x and isinstance(input,bytes):
		return input.decode("ascii","ignore")
	elif PYTHON2x and isinstance(input,unicode):
		return str(input)
	else:
		PRINT ("EARNING: unhandled case for input = <",input,">")
		return input

#######################################################################################################################################################
#This returns the flattened version of an input List (just imagine the list without ALL the inside [] )
# This is not as easy as it sounds like. Remember that you will have to keep the outermost list, but remove ALL other inner lists.
#######################################################################################################################################################

def flattenList(inputList):
	if checkIfString(inputList):
		return inputList
	elif isinstance(inputList,list):
		if len(inputList) == 1:
			return inputList
#			if isinstance(inputList[0],list):
#				return flattenList(inputList[0])
#			else:
#				return inputList
		else:
			returnList = []
			for item in inputList:
				# Handle the special case of function(), (), {} and []
				if isinstance(item, list) and len(item)==2 and item[0] in ('()','{}','[]'):
					temp2 = flattenList(item[1])
					if isinstance(temp2,list):
						temp = [item[0][0]] + temp2 + [item[0][1]]
					else:
						temp = item[0][0]+temp2+item[0][1]
				else:
					temp = flattenList(item)
					
				if isinstance(temp,list):
					returnList.extend(temp)
				else:
					returnList.append(temp)
			return returnList
	else:
		return inputList

#inputList = [["a1","+","b2"],"*",["c3","/","d4"],"+","e5"]
#flattened = flattenList(inputList)
#print flattened

#sys.exit()


	
#######################################################################################################################################################
#This returns the string version of an input List (just imagine the list without the surrounding [] and the comma separators)
#######################################################################################################################################################

def list2plaintext(inputList, separator = " "):
	if checkIfString(inputList):
		return inputList
	elif checkIfIntegral(inputList):
		return STR(inputList)
	elif isinstance(inputList,list):
		returnValue = ""
		for i in range(len(inputList)):
			if i>0:
				returnValue += separator
			if list2plaintext(inputList[i]) != False:
				returnValue += list2plaintext(inputList[i])
			else:
				PRINT("list2plaintext(inputList[",i,"] =",inputList[i],") = False")
				return False
		return returnValue
	elif type(inputList)=="bool":
		if inputList == True:
			return "True"
		elif inputList == False:
			return "False"
		else:
			PRINT("inputList =",inputList)
			EXIT("Unknown inputList value")
	else:
		OUTPUT("inputList =",inputList,"is of type",type(inputList))
		return False

#######################################################################################################################################################
#This returns the index of the first occurrence of a contiguous sequence of items in a list (like finding a substring in a string)
#######################################################################################################################################################
def findIndexOfSequenceInList(sequence,inputList):
	if checkIfString(inputList) and checkIfString(sequence):
		return inputList.find(sequence)
	if not isinstance(inputList,list):
		return False
	if checkIfString(sequence):
		sequence = [sequence]
	
	for i in range(len(inputList)-len(sequence)+1):
		if inputList[i:i+len(sequence)] == sequence:
			return i
	
	return -1


#######################################################################################################################################################
#This returns the string version of an input dictionary
#######################################################################################################################################################
def dictionary2string(inputDictionary):
#	PRINT ("inside dictionary2string, inputDictionary =", inputDictionary )
	if isinstance(inputDictionary,int):
		return str(inputDictionary)
	elif PYTHON2x and isinstance(inputDictionary,long):	# This is only for Python 2.x
		return str(inputDictionary)
	elif isinstance(inputDictionary,float):	
		return str(inputDictionary)
	elif checkIfString(inputDictionary):
		return "'"+inputDictionary+"'"
	elif isinstance(inputDictionary,list):
		return list2string(inputDictionary)
	elif isinstance(inputDictionary,dict):
		dictionaryLength = len(inputDictionary)
		itemCount = 0
		outputStr = '{'
		for key in inputDictionary.keys():
			outputStr += dictionary2string(key)+": "+dictionary2string(inputDictionary[key])
			if itemCount < dictionaryLength-1:
				outputStr += ', '
			itemCount += 1
		outputStr += '}'
#		PRINT ("returning outputStr =",outputStr )
		return outputStr
	elif inputDictionary == None:
		return "None"
	elif inputDictionary == True:
		return "True"
	elif inputDictionary == False:
		return "False"
	else:
		PRINT ("ERROR in dictionary2string() - unknown type", type(inputDictionary), "while expecting a dictionary" )
#		print ("inputDictionary =",str(inputDictionary))
		return "<unprintable bytestream of type "+str(type(inputDictionary))+" >"
		
#######################################################################################################################################################
#This returns the string version of an input List
#######################################################################################################################################################
def list2string(inputList):
#	PRINT ("inside list2string, inputList =", inputList )
	if isinstance(inputList,int):
		return str(inputList)
	elif PYTHON2x and isinstance(inputList,long):	# This is only for Python 2.x
		return str(inputList)
	elif isinstance(inputList,float):	
		return str(inputList)
	elif checkIfString(inputList):
		return "'"+inputList+"'"
	elif PYTHON3x and isinstance(inputList,bytes):
		return "'"+inputList.decode("utf-8")+"'"
	elif isinstance(inputList,dict):
		return dictionary2string(inputList)
	elif isinstance(inputList,list):
		outputStr = '['
		for i in range(len(inputList)):
			outputStr += list2string(inputList[i])
			if i < len(inputList)-1:
				outputStr += ', '
		outputStr += ']'
#		PRINT ("returning outputStr =",outputStr )
		return outputStr
	elif inputList == None:
		return "None"
	else:
		print ("ERROR in list2string() - unknown type", inputList, "while expecting a list" )
		sys.exit()

##########################################################################################################################################################
# We do not know if the output of the str() function would change in different Python versions, hence here is our own custom "convert-to-string" routine
##########################################################################################################################################################
def STR(input):
	if checkIfString(input):
		return input
	elif isinstance(input,list):
		return list2string(input)
	elif isinstance(input,dict):
		return dictionary2string(input)
	else:
		if PYTHON2x:
			return str(input)
		elif PYTHON3x:
			if isinstance(input,(bytes, bytearray)):
				return input.decode("ascii","ignore")
			else:
				return str(input)
		else:
			print ("ERROR in STR() - Should never come here")
	


##########################################################################################################################################################
# Universal PRINT function
##########################################################################################################################################################
def PRINT (*argv):
	if PRINT_DEBUG_MSG:
		printString = ""
		for arg in argv:
			strArg = STR(arg)
			printString += strArg + (" " if len(strArg)>0 and strArg[-1] != "\n" else "")
		print (printString)

##########################################################################################################################################################
# PRINT function that will always work, irrespective of the value of PRINT_DEBUG_MSG
##########################################################################################################################################################
def MUST_PRINT (*argv):
	global PRINT_DEBUG_MSG
	backedUpValuePRINT_DEBUG_MSG = PRINT_DEBUG_MSG
	PRINT_DEBUG_MSG = True
	printString = ""
	for arg in argv:
		strArg = STR(arg)
		printString += strArg + (" " if len(strArg)>0 and strArg[-1] != "\n" else "")
	print (printString)
	PRINT_DEBUG_MSG = backedUpValuePRINT_DEBUG_MSG

##########################################################################################################################################################
# PRINT function that will always work, irrespective of the value of PRINT_DEBUG_MSG
# The reason we have this separate OUTPUT function is the follows. We intend to use MUST_PRINT mostly for debugging selective statement,
# as setting the PRINT_DEBUG_MSG = True will turn on the debug globally and flood the console. So, for selective debug, a better approach is to
# take the existing PRINT statement, and then convert them to MUST_PRINT() function. That way, only those MUST_PRINT statements will print, while the
# rest of the regular PRINT() statements won't. Then when the debugging is over, replace those MUST_PRINT() back to ordinary PRINT() statement.
#  
# The only problem with this approach is that there are certain MUST_PRINT() statements that are not for debugging, but rather for regular business.
# For example, in the console we also lay out the structure with field values. Now, if we use MUST_PRINT() statement for those too, the a user
# who is using a "replace-all" for replacing MUST_PRINT() into PRINT() will also end up replacing those statements which were not for debugging at all.
# To avoid this confusion, we use another function OUTPUT which should be strictly used for "regular", non-debug must-print requirements.
##########################################################################################################################################################
OUTPUT = MUST_PRINT

PRINT ("version is " )
PRINT (sys.version_info )

def EXIT(errorMessage):
	OUTPUT(errorMessage)
	sys.exit()
	
#################################################################################################################################################
# Python changed they way they output the dict.keys() function. In Python 2, the output type is a list. In Python 3, it is a dict_keys object.
# So, if you have a statement like "for key in someDict.keys()", that will work in both Python 2 and 3, since the "key" value is same.
# However, suppose you want to extract the list of keys into a list, and then start want to do some operations on that list expecting it to be a "list" object.
# For example, suppose you have "if item in someDict.keys()". That will fail in Python 3, since it is no longer a list object, but a dict_keys object.
# Hence, we are putting a wrapper that will force it to be a list for Python 3.
#################################################################################################################################################
def getDictKeyList(inputDict):
	if not isinstance(inputDict, dict):
		OUTPUT ("ERROR in getDictKeyList() - input to this function is NOT a dictionary",inputDict)
		sys.exit()
	elif not inputDict:
		return []
	elif PYTHON2x:
		return inputDict.keys()
	elif PYTHON3x:
		keyList = list(inputDict.keys())
		if not isinstance(keyList, list):
			OUTPUT ("ERROR in coding - output is still not a list",keyList)
			sys.exit()
		else:
			return keyList
	else:
		PRINT ("Sorry, only Python 2.7 and above are supported now")
		sys.exit()
		
		
try:
	if sys.version_info >= (3, 0, 0):
		PRINT ("For Python 3.0 and above ..." )
		import tkinter as tk
		import tkinter.ttk as ttk
		import tkinter.filedialog as filedialog
		from tkinter import messagebox as messageBox
	elif sys.version_info >= (2, 7, 0):
		PRINT ("For Python 2.7 and above (but below Python 3.0)" )
		import Tkinter as tk
		import ttk
		import tkFileDialog as filedialog
		import tkMessageBox as messageBox
	else:
		# Do 2.6+ stuff
		PRINT ("Unknown version - exiting" )
		sys.exit()
	try:
		Spinbox = ttk.Spinbox
	except AttributeError:
		Spinbox = tk.Spinbox
#except ModuleNotFoundError:		# Works only on Python 3, not 2
except ImportError:
	OUTPUT ("Cannot instantiate tkinter - going into batch mode")
	BATCHMODE = True



def integerDivision(a,b):
	if sys.version_info >= (3, 0, 0):
		if checkIfIntegral(a) and checkIfIntegral(b):
			returnValue = a // b
		else:
			PRINT ("WARNING: Inputs to integerDivision(",a,",",b") are not integral") 
			returnValue = a / b
	else:
		returnValue = a / b
	return returnValue


# Given a bit number, this returns the corresponding byte number
def bit2Byte (bitNumber):
	if not checkIfIntegral(bitNumber):
		sys.stdout.write ("Input to bit2Byte() is not integral - exiting")
		sys.exit()
	elif bitNumber < 0:
		sys.stdout.write ("Input to bit2Byte() cannot be negative - exiting")
		sys.exit()
	else:
		return integerDivision(bitNumber,BITS_IN_BYTE)
		
# Given a byte number, this returns the first bit number corresponding to that byte number
def byte2Bit (byteNumber):
	if not checkIfIntegral(byteNumber):
		sys.stdout.write ("Input to byte2Bit() is not integral - exiting")
		sys.exit()
	elif byteNumber < 0:
		sys.stdout.write ("Input to byte2Bit() cannot be negative - exiting")
		sys.exit()
	else:
		return byteNumber * BITS_IN_BYTE


def errorRoutine(message):
	global window, PRINT_DEBUG_MSG
	backedUpValuePRINT_DEBUG_MSG = PRINT_DEBUG_MSG
	PRINT_DEBUG_MSG = True
	PRINT (message)
	if not BATCHMODE and MAINLOOP_STARTED:
		messageBox.showerror("Error",message)
	PRINT_DEBUG_MSG = backedUpValuePRINT_DEBUG_MSG
	return
	
def warningRoutine(message):
	global window
	PRINT (message)
	if not BATCHMODE and MAINLOOP_STARTED:
		messageBox.showwarning("Warning",message)
	return

def printHelp():
	OUTPUT("The way to invoke this tool is the following:\npython2/3 ParseAndC.py [options], where the options are:\n")
	OUTPUT("-b, --batch               to indicate that the tool will run in the non-interactive, non-GUI, terminal batch mode")
	OUTPUT("-c, --codefile            followed by the code file name")
	OUTPUT("-d, --datafile            followed by the data file name")
	OUTPUT("--dummyVarNamePrefix      All dummy variables will start with this prefix")
	OUTPUT("-e, --enum  [Y/N]         Overrides the default setting of whether to print the enum literal for data values.")
	OUTPUT("-g, --global              followed by the name of the Global-level variables (or typedefs) that will be mapped during the batch mode")
	OUTPUT("                          If providing multiple variable names, then it must be double-quoted (like \"var1 var2\")")
	OUTPUT("                          If no variable names are provided, every variable at the global level in the code file will be automatically selected")
	OUTPUT("-gcc                      Attempts to emulate the GCC compilation environment")
	OUTPUT("-h, --help                Prints the options available")
	OUTPUT("-i, --include             followed by a single string that contains the include file path(s), separated by semicolon")
	OUTPUT("-o, --offset              followed by the offset value (from which offset in the data file the struct will start mapping from)")
	OUTPUT("                          Offsets can be numbers or expressions, but must be then double-quoted, like \"3KB+0x12*43-(0o62/0b10)\"")
	OUTPUT("-t, --typedef             followed by Yes/No to indicate if typedefs will be mapped as regular variables or not")
	OUTPUT("-u                        Suppress warnings when the code tries to #undef symbols that are not-yet-defined ")
	OUTPUT("-v, --verbose, --debug    to indicate if debug messages will be printed or not")
	OUTPUT("-w [Y/N/maxcount]         To turn on/off the verification warning messages, and not to display such message after a certain max count has been reached")
	OUTPUT("-x, --hex                 Prints the integral values in Hex (default is Decimal)")

def parseCommandLineArguments():
	global BATCHMODE, DISPLAY_INTEGRAL_VALUES_IN_HEX, PRINT_UNDEF_WARNING, PRINT_ENUM_LITERALS, codeFileName, dataLocationOffset, inputVariables, VERIFICATION_WARNING_COUNT_MAX
	global PRINT_DEBUG_MSG, MAP_TYPEDEFS_TOO, COMPILER_PADDING_ON, STRUCT_END_PADDING_ON, INCLUDE_FILE_PATHS, dummyVariableNamePrefix, EMULATE_GCC_COMPILATION_ENVIRONMENT
	PRINT ("sys.argv = ",sys.argv)
	
	DATAFILENAME = None
	CODEFILENAME = None
	DATAOFFSET = None
	VARIABLENAMES = None
	map_typedefs_too_response = None

	TRUE_VALUES  = ("y","yes","t","true","1", "on")
	FALSE_VALUES = ("n","no","f","false","0","off")
	
	for item in sys.argv:
		if item.lower() in ("-h", "--h", "-help", "--help"):
			printHelp()
			sys.exit()
		else:
			continue
			
	N = 1
	while N <= len(sys.argv)-1:
		if sys.argv[N].lower() in ("-b", "--b", "-batch", "--batch"):
			PRINT ("Operating in Batch mode (no GUI)")
			BATCHMODE = True
			N += 1
		elif sys.argv[N].lower() in ("-i", "--i", "-include", "--include"):
			PRINT ("Include file path")
			N += 1
			if N == len(sys.argv) or sys.argv[N].startswith("-"):
				OUTPUT("Must supply a double-quoted string containing ALL the include file path(s), separated by semicolon if multiple paths are supplied")
				sys.exit()
			else:
				INCLUDE_FILE_PATHS = sys.argv[N]
				# There is a weird case. If one supplies the following: 
				# $ python ParseAndC.py -i "c:\temp\" -x
				# Then it will not be able to read the -x command line option, and for -i, it will think the following argument: 
				#      <c:\temp" -x>
				if '"' in INCLUDE_FILE_PATHS:
					OUTPUT("Do NOT end directory paths with a slash. Then it will interpret the last \\\" as simply \".")
					OUTPUT("Thus, right now it is thinking that you entered the following as your include directory path: ",INCLUDE_FILE_PATHS)
					sys.exit()
				MUST_PRINT("INCLUDE_FILE_PATHS =",INCLUDE_FILE_PATHS)
			N += 1
		elif sys.argv[N].lower() in ("-x", "--x", "-hex", "--hex", "-hexadecimal", "--hexadecimal"):
			PRINT ("Integral values will be printed in Hexadecimal (default is Decimal)")
			DISPLAY_INTEGRAL_VALUES_IN_HEX = True
			N += 1
		elif sys.argv[N].lower() in ("-p", "--p", "-cp", "--cp", "-pad", "--pad"):
			PRINT ("Compiler padding will be turned on")
			COMPILER_PADDING_ON = True
			STRUCT_END_PADDING_ON = True	# Whether to add additional padding at the end of a structure to make to align to a word boundary
			N += 1
			if N <= len(sys.argv)-1:
				if sys.argv[N].lower() in TRUE_VALUES:
					COMPILER_PADDING_ON = True
					STRUCT_END_PADDING_ON = True	# Whether to add additional padding at the end of a structure to make to align to a word boundary
					N += 1
				elif sys.argv[N].lower() in FALSE_VALUES:
					COMPILER_PADDING_ON = False
					STRUCT_END_PADDING_ON = False	# Whether to add additional padding at the end of a structure to make to align to a word boundary
					N += 1
				else:
					continue
		elif sys.argv[N].lower() in ("-d", "--d", "-df", "--df", "-dfile","--dfile", "-datafile","--datafile"):
			N += 1
			if N > len(sys.argv)-1:
				OUTPUT("Must supply the data filename following the %s option"%sys.argv[N-1])
				sys.exit()
			else:
				DATAFILENAME = sys.argv[N]
				N +=1
		elif sys.argv[N].lower() in ("-c", "--c", "-cf", "--cf", "-cfile","--cfile", "-codefile","--codefile"):
			N += 1
			if N > len(sys.argv)-1:
				OUTPUT("Must supply the code filename following the %s option"%sys.argv[N-1])
				sys.exit()
			else:
				PRINT("Found code file")
				CODEFILENAME = sys.argv[N]
				N +=1
		elif sys.argv[N].lower() in ("-o", "--o", "-do", "--do", "-offset", "--offset", "-doffset", "--doffset", "-dataoffset", "--dataoffset", "-datafileoffset", "--datafileoffset" ):
			N += 1
			if N > len(sys.argv)-1:
				OUTPUT("Must supply the data offset following the %s option"%sys.argv[N-1])
				sys.exit()
			else:
				DATAOFFSET = sys.argv[N]
				convertByteUnits2DecimalResult = convertByteUnits2Decimal(DATAOFFSET)
				if convertByteUnits2DecimalResult[0] == False:
					OUTPUT(DATAOFFSET,"is not a valid data offset")
					sys.exit()
				elif not checkIfIntegral(convertByteUnits2DecimalResult[1]):
					OUTPUT("Supplied data offset %s must be an integer"%DATAOFFSET)
					sys.exit()
				elif convertByteUnits2DecimalResult[1] < 0:
					OUTPUT("Supplied data offset %d must be a non-negative integer"%DATAOFFSET)
					sys.exit()
				else:
					dataLocationOffset = convertByteUnits2DecimalResult[1]
				N +=1
		elif sys.argv[N].lower() in ("-g", "--g") or sys.argv[N].lower().startswith("-global") or sys.argv[N].lower().startswith("--global") :
			N += 1
			if N > len(sys.argv)-1:
				OUTPUT("Must supply the global variable name(double-quoted list if multiple) following the %s option"%sys.argv[N-1])
				sys.exit()
			else:
				VARIABLENAMES = sys.argv[N]
				N +=1
		elif sys.argv[N].lower() in ("-debug","--debug","-v","--v","-verbose","--verbose"):
			N += 1
			if N > len(sys.argv)-1:
				OUTPUT("Turning Debug ON")
				PRINT_DEBUG_MSG = True
				N += 1
			else:
				if sys.argv[N].startswith("-"):
					OUTPUT("Turning Debug ON")
					PRINT_DEBUG_MSG = True
				else:
					print_debug_msg_Response = sys.argv[N]
					if print_debug_msg_Response.lower() in TRUE_VALUES:
						PRINT_DEBUG_MSG = True
						N +=1
					elif print_debug_msg_Response.lower() in FALSE_VALUES:
						PRINT_DEBUG_MSG = False
						N += 1
					elif N==len(sys.argv)-1 and DATAFILENAME==None:
						pass
					else:
						OUTPUT("Unknown value for Debug option")
						sys.exit()
		elif sys.argv[N].lower() in ("-t", "--t", "-td", "--td", "-typedef", "--typedef", "-typedefs", "--typedefs", "-mt", "--mt", "-map_typedefs", "--map_typedefs" ):
			N += 1
			if N > len(sys.argv)-1:
				OUTPUT("Must tell whether to map typedefs too or not, following the %s option"%sys.argv[N-1])
				sys.exit()
			else:
				map_typedefs_too_response = sys.argv[N]
				if map_typedefs_too_response.lower() in FALSE_VALUES:
					PRINT ("NOT mapping the typedefs")
					MAP_TYPEDEFS_TOO = False
				elif map_typedefs_too_response.lower() in TRUE_VALUES:
					PRINT ("Mapping the typedefs too")
					MAP_TYPEDEFS_TOO = True
				else:
					OUTPUT("Must tell whether to map typedefs too or not, following the %s option - %s is not a valid response"%(sys.argv[N-1]),map_typedefs_too_response)
					sys.exit()
				N +=1
		elif sys.argv[N].lower() in ("-dummyvarprefix", "--dummyvarprefix", "-dummyvariableprefix", "--dummyvariableprefix","-dummyvarnameprefix","--dummyvarnameprefix","-dummyvariablenameprefix","--dummyvariablenameprefix"):
			N += 1
			if N > len(sys.argv)-1:
				OUTPUT("Must supply the Dummy Variable Name Prefix following the %s option"%sys.argv[N-1])
				sys.exit()
			else:
				temp = sys.argv[N]
				if len(temp)>=3 and temp[0] in ('"',"'") and temp[-1] in ('"',"'"):
					temp = temp[1:-1]
				if re.match(r'^[_a-zA-Z][_a-zA-Z0-9]*$',temp):
					OUTPUT("Careful! Supplied Dummy Variable Name Prefix of "+temp+" might clash with regular code variable names")
				OUTPUT("Setting dummyVariableNamePrefix to <"+temp+">")
				dummyVariableNamePrefix = temp	
				N +=1
		elif sys.argv[N].lower() in ("-gcc", "--gcc"):
			OUTPUT("Emulating GCC compilation environment")
			EMULATE_GCC_COMPILATION_ENVIRONMENT = True
			N += 1
		elif sys.argv[N].lower() in ("-u", "--u"):
			N += 1
			OUTPUT("Suppressing #undef warnings for symbols that are not defined yet.")
			PRINT_UNDEF_WARNING = False
		elif sys.argv[N].lower() in ("-e", "--e", "-enum","--enum"):
			N += 1
			if N >= len(sys.argv):
				OUTPUT("Will display enum literals whenever possible")
				PRINT_ENUM_LITERALS = True
			elif sys.argv[N][0]=="-":
				OUTPUT("Will display enum literals whenever possible")
				PRINT_ENUM_LITERALS = True
				N += 1
			else:
				temp = sys.argv[N].lower()
				if temp in TRUE_VALUES:
					PRINT_ENUM_LITERALS = True
					OUTPUT("Will display enum literals whenever possible")
				elif temp in FALSE_VALUES:
					OUTPUT("Will NOT display enum literals")
					PRINT_ENUM_LITERALS = False
				else:
					EXIT("Unacceptable string following -enum option - exiting")
				N += 1
					
		elif sys.argv[N].lower() in ("-w", "--w", "-warning","--warning"):
			N += 1
			if N >= len(sys.argv) or sys.argv[N][0]=="-":
				EXIT("Need to provide a valid parameter after the verification warning (\"-w\") option")
			else:
				temp = sys.argv[N].lower()
				if temp in TRUE_VALUES:
					PRINT("Will be printing verification warnings!")
				elif temp in FALSE_VALUES:
					OUTPUT("Will NOT be printing verification warnings at all!")
					VERIFICATION_WARNING_COUNT_MAX = 0
				else:
					VERIFICATION_WARNING_COUNT_MAX = sys.argv[N]
					convertByteUnits2DecimalResult = convertByteUnits2Decimal(VERIFICATION_WARNING_COUNT_MAX)
					if convertByteUnits2DecimalResult[0] == False:
						OUTPUT(VERIFICATION_WARNING_COUNT_MAX,"is not a valid verification warning count")
						sys.exit()
					elif not checkIfIntegral(convertByteUnits2DecimalResult[1]):
						OUTPUT("Supplied data offset %s must be an integer"%VERIFICATION_WARNING_COUNT_MAX)
						sys.exit()
					elif convertByteUnits2DecimalResult[1] < 0:
						OUTPUT("Supplied  verification warning count %s must be a non-negative integer"%VERIFICATION_WARNING_COUNT_MAX)
						sys.exit()
					else:
						VERIFICATION_WARNING_COUNT_MAX = convertByteUnits2DecimalResult[1]
						OUTPUT("Will not be displaying verification warnings after a max count of ",VERIFICATION_WARNING_COUNT_MAX)
				N +=1
		else:
			PRINT ("N = ",N,"len(sys.argv)-1 =",len(sys.argv)-1)
			if DATAFILENAME == None and N == len(sys.argv)-1:
				DATAFILENAME = sys.argv[N]
				N += 1
			else:
				OUTPUT("Unknown parameter %s supplied - exiting"%sys.argv[N])
				printHelp()
				sys.exit()

	if CODEFILENAME == None:
		if BATCHMODE:
			OUTPUT("Must supply code file")
			printHelp()
			sys.exit()
	else:
		PRINT ("Chosen Code file name = ",CODEFILENAME)
		codeFileName = CODEFILENAME
				
	if DATAFILENAME == None:
		if BATCHMODE:
			OUTPUT("Must supply data file")
			printHelp()
			sys.exit()
	else:
		PRINT ("Chosen Data file name = ",DATAFILENAME)
		# This will automatically populate the dataFileName, dataFileSizeInBytes, and inputIsHexChar
		if not checkIfDataFileIsValidAndGetItsLength(DATAFILENAME):
			OUTPUT ("Error finding datafile ",DATAFILENAME)
			sys.exit()
		
		
	if DATAOFFSET != None:
		if BATCHMODE:
			PRINT ("Input Data Offset = ",DATAOFFSET,"results in",dataLocationOffset)
			if dataLocationOffset >= dataFileSizeInBytes:
				OUTPUT("Input Data Offset = ",DATAOFFSET,"(",dataLocationOffset,") too big for data file of size",dataFileSizeInBytes)
				sys.exit()
			
	if BATCHMODE and VARIABLENAMES != None:
		PRINT ("Chosen top-level variable name(s) = ",VARIABLENAMES)
		inputVariables = re.sub("[,\s]+"," ",VARIABLENAMES.strip()).split(" ")
	

	return True


class Node (object):
	def __init__ (self, data, type):
		self.data = data
		self.type = type
		self.children = []
		
	def add_child (self, obj):
		self.children.append(obj)
	
	# Preorder traversal of a N-ary tree
	def traverse (self,level=0):
		PRINT (" "+"--"*level,level," type = <",self.type, ">, ", len(self.children), " children, data = <",self.data, ">" )
		if len(self.children) > 0:
			for i in self.children:
#				PRINT ("Going to traverse the children of ", self )
				i.traverse(level+1)
	
	def populateStructuresAndUnionsDictionary(self, structOrUnionName):
		if self.type != "struct" and self.type != "union" :
			return
		
# This function takes in an input List, and returns the sum of the elements (assumed to be integers)
def listItemsSum(inputList):
	if not isinstance(inputList,list):
		PRINT ("ERROR: Illegal input array dimension value",arrayDimensions )
		return False
	elif len(inputList) == 0:	# Blank
		return False
	elif inputList:
		returnValue = 0
		for item in inputList:
			if not checkIfIntegral(item):
				return False
			else:
				if item <= 0:
					PRINT ("WARNING: non-positive integer",item )
				returnValue += item
		return returnValue
	else:
		PRINT ("ERROR!!!!" )
		sys.exit()
#######################################################################################################################
# This function takes in an input List, and returns the product of the elements (assumed to be integers).
# In case the list items contain unresolved variable names, instead of the product, it returns the product expression list.
# For example, for inputList = [2,3,4], it will return 24, but for [2,'a','4'] it will return ['(','2',')',   '*',  '{','a',')', '*', '(','4',')']
#######################################################################################################################
def listItemsProduct(inputList):
	if not isinstance(inputList,list):
		errorMessage = "ERROR in listItemsProduct(): Illegal input <%s>"%STR(inputList)
		errorRoutine(errorMessage)
		return False
	elif not inputList:	# Blank list
		errorMessage = "ERROR in listItemsProduct(): blank input list"
		errorRoutine(errorMessage)
		return False
	else:
		returnValueList = []
		
		for item in inputList:
		
			if returnValueList:
				returnValueList.append('*')	# Adding a specific multiplication symbol for 2nd onward list items
				
			if checkIfIntegral(item):
				itemValue = str(item)
				returnValueList.append(itemValue)
				continue
				
			if checkIfString(item):
				tokenizeLinesResult = tokenizeLines(item)
				if tokenizeLinesResult == False:
					errorMessage = "ERROR in listItemsProduct() tokenizing <%s>"%item
					errorRoutine(errorMessage)
					return False
				else:
					item = tokenizeLinesResult[0]	# Replace the original string with a tokenized list
				
			if not isinstance(item, list):
				errorMessage = "ERROR in listItemsProduct(): Cannot parse <%s> since it is not a list"%STR(item)
				errorRoutine(errorMessage)
				return False
			else:
				itemValue = ['(']+item+[')']	# Deliberately parenthesizing it
				returnValueList.extend(itemValue)
		
		PRINT("Now we have the returnValueList =",returnValueList)
		
		parseArithmeticExpressionResult = parseArithmeticExpression(returnValueList)
		if parseArithmeticExpressionResult == False:
			errorMessage = "ERROR in listItemsProduct() parsing <%s>"%STR(item)
			errorRoutine(errorMessage)
			return False
			
		evaluateArithmeticExpressionResult = evaluateArithmeticExpression(parseArithmeticExpressionResult)
		if evaluateArithmeticExpressionResult[0] == False:
			errorMessage = "ERROR in listItemsProduct() evaluating <%s>"%evaluateArithmeticExpressionResult
			errorRoutine(errorMessage)
			return False
		elif evaluateArithmeticExpressionResult[1] == LOGICAL_TEST_RESULT_INDETERMINATE:
			return returnValueList	# Return the list itself, not the LOGICAL_TEST_RESULT_INDETERMINATE
		else:
			returnValue = evaluateArithmeticExpressionResult[1]
			if returnValue <= 0:
				PRINT ("WARNING: non-positive returnValue =",returnValue )
			return returnValue



########################################################################################################################################################################
# This function returns the Array Indices for an array element position. For example, if there is an array[Di][Dj][Dk], where Di/Dj/Dk are array dimensions, then we can
# potentially have (Di x Dj x Dk) number of array elements, starting from 0 to (Di x Dj x Dk - 1). So, given inputs of Di, Dj, Dk (the array dimensions) and 
# the array element position (a number between 0 and (Di x Dj x Dk - 1)), this routine outputs [i,j,k] such that essentially in C language, *(array + position) = array[i][j][k]
########################################################################################################################################################################
def calculateArrayIndicesFromPosition(arrayDimensions, position):
	
#	PRINT ("inside calculateArrayIndices(arrayDimensions=",arrayDimensions, "position=",position,")" )
	if not isinstance(arrayDimensions,list):
		errorMessage = "ERROR: Illegal input array dimension value = "+STR(arrayDimensions)
		errorRoutine(errorMessage)
		return False
	elif (not checkIfIntegral(position)) or (position < 0):	
		errorMessage = "ERROR: Illegal input array position value of "+STR(position)
		errorRoutine(errorMessage)
		return False
	else:
		totalCount = 1
		cumulativeProduct = 1
		arrayDimensionsReversed = arrayDimensions[::-1]
		reverseIndex = []
		for i in range(len(arrayDimensionsReversed)):
			d = arrayDimensionsReversed[i]
			if (not checkIfIntegral(d)) or (d <1):
				errorMessage = "ERROR: Illegal input array dimension value of "+STR(d)
				errorRoutine(errorMessage)
				return False
			else:
				totalCount *= d
				if i==0:
					cumulativeProduct = 1
		
				reverseIndex.append(cumulativeProduct)
				cumulativeProduct *= d
				
		if position >= totalCount:
			errorMessage = "ERROR: Illegal input array position value "+STR(position)+" - it cannot be bigger than "+STR(totalCount-1)+" for array dimensions "+STR(arrayDimensions)
			errorRoutine(errorMessage)
			return False
	
		arrayDimensionSizes = reverseIndex[::-1]
		
#		PRINT ("For arrayDimensions =",arrayDimensions,"arrayDimensionSizes=",arrayDimensionSizes )
		
		temp = position
		arrayIndices = []
		for i in range(len(arrayDimensionSizes)):
			arrayIndices.append(integerDivision(temp,arrayDimensionSizes[i]))
			temp = temp%arrayDimensionSizes[i]
#		PRINT ("For arrayDimensions =",arrayDimensions,"position=",position,"arrayIndices =",arrayIndices )

		if position != calculateArrayPositionFromIndices(arrayDimensions, arrayIndices):
			errorMessage = "ERROR!!!For arrayDimensions = "+STR(arrayDimensions)+" position = "+STR(position)+" calculated arrayIndices = "+STR(arrayIndices)+" does not match"
			errorRoutine(errorMessage)
			return False
		else:
			return arrayIndices
		
########################################################################################################################################################################
# This function returns the position of an array element from an input of Array dimensions and Array Indices. For example, if there is an array[Di][Dj][Dk], 
# where Di/Dj/Dk are array dimensions, then we can potentially have (Di x Dj x Dk) number of array elements, starting from 0 to (Di x Dj x Dk - 1). 
# So, given inputs of Di, Dj, Dk (the array dimensions) and Array indices [i,j,k], it returns the array element position - a number between 0 and (Di x Dj x Dk - 1)
# this routine outputs position such that essentially in C language, *(array + position) = array[i][j][k]
########################################################################################################################################################################
def calculateArrayPositionFromIndices(arrayDimensions, arrayIndices):
	
#	PRINT ("inside calculateArrayPositionFromIndices(arrayDimensions=",arrayDimensions, "arrayIndices=",arrayIndices,")" )
	if (not isinstance(arrayDimensions,list)) or (not isinstance(arrayIndices,list)):
		errorMessage = "ERROR: Illegal value for input array dimension ("+STR(arrayDimensions)+") or index ("+STR(arrayIndices)+")"
		errorRoutine(errorMessage)
		return False
	elif len(arrayDimensions) != len(arrayIndices):
		errorMessage = "ERROR: Length of input array dimension ("+STR(arrayDimensions)+") does not match length of array index length("+STR(arrayIndices)+")"
		errorRoutine(errorMessage)
		return False
	else:
		for i in range(len(arrayDimensions)):
			if not checkIfIntegral(arrayDimensions[i]):
				errorMessage = "ERROR: non-integral array dimension ("+STR(arrayDimensions)+") "
				errorRoutine(errorMessage)
				return False
			elif arrayDimensions[i] <1:
				errorMessage = "ERROR: array dimension size must at least be 1 - arrayDimensions["+STR(i)+"] ="+STR(arrayDimensions[i])
				errorRoutine(errorMessage)
				return False
		for i in range(len(arrayIndices)):
			if not checkIfIntegral(arrayIndices[i]):
				errorMessage="ERROR: non-integral array index ("+STR(arrayIndices)+") "
				errorRoutine(errorMessage)
				return False
			elif arrayIndices[i] <0:
				errorMessage = "ERROR: array index must at least be 0 - currently, arrayIndices["+STR(i)+"] ="+STR(arrayIndices[i])
				errorRoutine(errorMessage)
				return False
			elif arrayIndices[i] >= arrayDimensions[i]:
				errorMessage = "ERROR: array index "+STR(arrayIndices[i])+" cannot be numerically equal or bigger than its dimension size ("+STR(arrayDimensions[i])+") "
				errorRoutine(errorMessage)
				return False
				
		cumulativeProduct = 1
		arrayDimensionsReversed = arrayDimensions[::-1]
		reverseIndex = []
		for i in range(len(arrayDimensionsReversed)):
			if i==0:
				cumulativeProduct = 1
			reverseIndex.append(cumulativeProduct)
			cumulativeProduct *= arrayDimensionsReversed[i]
			
		arrayDimensionSizes = reverseIndex[::-1]
		
#		PRINT ("For arrayDimensions =",arrayDimensions,"arrayDimensionSizes=",arrayDimensionSizes )
		
		position = 0
		for i in range(len(arrayDimensionSizes)):
			position += arrayIndices[i]*arrayDimensionSizes[i]
#		PRINT ("For arrayDimensions =",arrayDimensions," and arrayIndices=", arrayIndices,"position=",position )
		return position
		
		

#######################################################################################################################################################
# This prints the input lines, numbered and delimited by <>. Like Line # 0. <....> etc.
#######################################################################################################################################################
def printLines(lines):
	# Check that lines is a list of Lines (strings ending with a newline). If it is a single string, make it a list
	if  isinstance(lines,list):
		itemCount = 0
		while itemCount < len(lines):
			if not checkIfString(lines[itemCount]):
				PRINT ("lines is not a list of proper strings - ", lines )
				return False
				sys.exit()
			itemCount = itemCount + 1
		itemCount = 0
		while itemCount < len(lines):
			PRINT ("Line # %2d = <%s>"%(itemCount,lines[itemCount]) )
			itemCount = itemCount + 1
	else:
		if checkIfString(lines):
			PRINT ("Line #  0 = <%s>"%lines )
		else:
			PRINT ("Unknown object type - lines = <",lines,"> - exiting" )
			return False
			sys.exit()
			
	return True

#######################################################################################################################################################
# This function taken in a List, and progressively removes listification until we get a list with at least 2 members.
# For example, it will reduce the list [[[['a','+','b']]]] to ['a','+','b'].
# The reason we have this function is because sometimes we want to compare two lists, and even if they are not the same from the programmatic
# point of view, they are essentially the same.
#######################################################################################################################################################
def removeUnnecessaryListification(inputList):
	if isinstance(inputList,list):
		if len(inputList) == 1 and isinstance(inputList[0],list):
			return removeUnnecessaryListification(inputList[0])
		else:
			return inputList
	else:
		return inputList
	
#######################################################################################################################################################
# This function taken a string consisting of filepaths separated by semicolon, and returns a list of such filepaths.
# For example, if you call it for "C:/Windows/Users; C:/Temp", it will return ["C:/Windows/Users/", "C:/Temp/"]
# Each of the returned list item will have the proper () slash at the end, and no semicolon.
#######################################################################################################################################################
def returnFilePathList(semicolonSeparatedFilePaths):
	if not checkIfString(semicolonSeparatedFilePaths):
		errorMessage = "ERROR in returnFilePathList- supplied input semicolonSeparatedFilePaths = <%s> is not a string"%(STR(semicolonSeparatedFilePaths))
		errorRoutine(errorMessage)
		return False
	if semicolonSeparatedFilePaths.strip() == "":
		return []
	# Get the current working directory
	cwd = os.getcwd()
	scriptLocation = os.path.realpath(__file__)
	if "\\" in cwd and "/" in cwd and "\\" in scriptLocation and "/" in scriptLocation:
		errorMessage = "ERROR in returnFilePathList() - both current working directory path and script location contain both forward slash and backward slash - cannot figure out if Unix or Windows"
		errorRoutine(errorMessage)
		return False
	
	dirToCheck = scriptLocation if "\\" in cwd and "/" in cwd else cwd
	
	if "\\" in dirToCheck:
		PRINT("Window-based system, where file path is punctuated by backward slash")
		slashType = "\\"
		slashTypeOpposite = "/"
	elif "/" in dirToCheck:
		PRINT("Unix-based system, where file path is punctuated by forward slash")
		slashType = "/"
		slashTypeOpposite = "\\"
	else:
		OUTPUT("Coding error in returnFilePathList() - exiting")
		sys.exit()
	
	if ';' in semicolonSeparatedFilePaths:
		temp = semicolonSeparatedFilePaths.strip().split(';')
	else:
		temp = [semicolonSeparatedFilePaths.strip()]
		
	PRINT("semicolonSeparatedFilePaths = <%s>"%semicolonSeparatedFilePaths)
	PRINT("paths = ",temp)
	
	
	paths = []
	for i in range(len(temp)):
		PRINT("Currently handling path = <%s> for path index %d"%(temp[i],i))
		temp[i] = temp[i].strip()
		PRINT("Currently handling path = <%s> for path index %d (after trimming)"%(temp[i],i))
		if not temp[i]:
			pass
		else:
			temp[i] = temp[i].replace(slashTypeOpposite, slashType)
			if temp[i][-1] != slashType:
				temp[i] += slashType
			paths.append(temp[i])
	
	# Finally, add the current directory at the end
	if cwd[-1]!=slashType:
		cwd += slashType
	paths.append(cwd)
	
	PRINT("Returning paths =",paths)
	return paths
	
#returnFilePathList(";c:/Windows/Users; ; c:\\temp\\;;")
#sys.exit()

#######################################################################################################################################################
# This function takes an input list, and returns True/False based upon whether the input List is a valid Abstract Syntax Tree or not
#######################################################################################################################################################
def isASTvalid(inputList):
#	PRINT=OUTPUT
	PRINT("Entering isASTvalid(inputList=",inputList,")")
	validOperators = oneCharOperatorList+twoCharOperatorList+threeCharOperatorList+derivedOperatorList
	validPrefixOperators = ["++","--","+","-","!","~","*","&","sizeof","_Alignof","()","{}","[]",",","function()","typecast"]
	validPostfixOperators = ["++","--"]
	validInfixOperators = [".","->","*","/","%","+","-",">>","<<","<","<=",">",">=","==","!=","&","^","|","&&","||","=","+=","-=","*=","/=","%=","<<=",">>=","&=","^=","|=",","]
	
	if checkIfString(inputList):
		return True
	elif checkIfNumber(inputList):
		return True
	elif isinstance(inputList,list):
		if len(inputList) == 0:
			return True
		elif len(inputList) == 1:
			return True
		elif len(inputList) == 2:
			# Check the prefix ones of the format [prefix-operator, operand]
			if (inputList[0] in validPrefixOperators) and (inputList[1] not in validOperators):
				res = isASTvalid(inputList[1])
				PRINT("returning isASTvalid(inputList[1]=",inputList[1],") =",res)
				return res
			elif (inputList[0] not in validOperators) and (inputList[1] in validPrefixOperators):
				return isASTvalid(inputList[0])
			elif isinstance(inputList[1], list) and inputList[1][0]=='[]':
				return isASTvalid(inputList[0]) & isASTvalid(inputList[1][1])
			elif (inputList[0] == 'datatype'): 
				for item in inputList[1]:
					if item not in cDataTypes:
						PRINT ("item", item,"in inputList[1] = ",inputList[1], "doesn't belong to either primitiveDatatypeLength.keys() =",getDictKeyList(primitiveDatatypeLength), "or typedefs.keys() = ",getDictKeyList(typedefs) )
						return False
				return True
			else:
				PRINT ("inputList =",inputList, "is not a valid 2-element AST" )
				return False
		elif len(inputList) == 3:
			if inputList[0] == "function()": 
				if inputList[1] not in validOperators:
					# TO-DO - put a check that a function name must be a valid string and not a list (but beware of macro)
					return isASTvalid(inputList[2])
				else:
					PRINT ("inputList =",inputList, "is not a valid AST" )
					return False
			elif (inputList[0] not in validOperators) and (inputList[1] in validInfixOperators) and (inputList[2] not in validOperators):
				return isASTvalid(inputList[0]) & isASTvalid(inputList[2])
			elif inputList[0] == "typecast": 
				# So, for an expression like			int i[(int)2.5];
				# inputList 						= ['typecast', ['()', ['datatype', ['int']]], ['2.5']]
				PRINT("inputList =",inputList)
				if isinstance(inputList[1], list) and len(inputList[1]) == 2 and inputList[1][0]== "()" and isinstance(inputList[1][1], list) 		\
					and inputList[1][1][0]=='datatype' and isinstance(inputList[1][1][1], list) and inputList[1][1][1][0] in cDataTypes and isinstance(inputList[2], list):
					PRINT("Returning isASTvalid(inputList[2]=",inputList[2],")")
					return isASTvalid(inputList[2])
				else:
					PRINT("Returning False")
					return False
			else:
				PRINT ("inputList =",inputList, "is not a valid AST" )
				return False
		elif len(inputList) == 5: # Ternary operator
			if (inputList[0] not in validOperators) and (inputList[1]=="?") and (inputList[2] not in validOperators) and (inputList[3]==":") and (inputList[4] not in validOperators):
				PRINT ("inputList[0] =",inputList[0],"inputList[2] =",inputList[2],"inputList[4] =",inputList[4], )
				return isASTvalid(inputList[0]) & isASTvalid(inputList[2]) & isASTvalid(inputList[4])
		else:
			PRINT ("inputList =",inputList, "is not a valid AST" )
			return False


#######################################################################################################################################################
# This function takes an input list, and returns a deep copy of the list
#######################################################################################################################################################
def deepCopy(input):
	if checkIfNumber(input):
		return input
	elif checkIfString(input):
		returnString = '%s'%input	# Not really necessary since Strings are immutable anyway, still if we really insist on creating a separate copy ....
		return returnString
	elif isinstance(input,list):
		returnList = []
		i = 0
		while i < len(input):
			returnList.append(deepCopy(input[i]))
			i = i+1
		return returnList
	elif isinstance(input,dict):
		returnDict = {}
		for key in getDictKeyList(input):
			keyCopy 	= deepCopy(key)
			valueCopy 	= deepCopy(input[key])
			returnDict[keyCopy] = valueCopy
		return returnDict
	else:
		return input


contextStack = []
def testFunc():
	global contextStack
	a = 1
	s = "string1"
	OUTPUT("id(a) =",id(a))
	OUTPUT("id(s) =",id(s))
	OUTPUT("a=",a,", s=",s)
	contextStack.append(deepCopy(locals()))
	a = 2
	s = "string2"
	OUTPUT("id(a) =",id(a))
	OUTPUT("id(s) =",id(s))
	OUTPUT("a=",a,", s=",s)
	OUTPUT("Now restore")
	a = contextStack[-1]['a']
	s = contextStack[-1]['s']
	OUTPUT("id(a) =",id(a))
	OUTPUT("id(s) =",id(s))
	OUTPUT("a=",a,", s=",s)
	
	OUTPUT("\n\n\n","==="*50,"\nNow printing locals")
	OUTPUT(locals())
	for key in getDictKeyList(locals()):
		OUTPUT ("\t"*2,key, ':', locals()[key],", id("+key+")=",id(key))
	#OUTPUT("\n\n\n","==="*50,"\nNow printing globals")
	#for key in getDictKeyList(globals()):
	#	OUTPUT ("\t"*2,key, ':', globals()[key])
	#OUTPUT("==="*50,"\n\n")
	sys.exit()

#testFunc()
###################################################################################################################################
# This routine saves the execution state 
###################################################################################################################################
def saveExecutionState(identifierRecord, speculativeValue, inputDict = {}):
	global executionStateStack
	
	executionState = {}
	
	executionState["identifierRecord"]									=	deepCopy(identifierRecord)
	executionState["speculativeValue"]									=	deepCopy(speculativeValue)
	executionState["lines"]												=	deepCopy(lines)
	executionState["enums"]												=	deepCopy(enums)
	executionState["enumFieldValues"]									=	deepCopy(enumFieldValues)
	executionState["typedefs"]											=	deepCopy(typedefs)
	executionState["suDict"]											=	deepCopy(suDict)
	executionState["structuresAndUnions"]								=	deepCopy(structuresAndUnions)
	executionState["variableDeclarations"]								=	deepCopy(variableDeclarations)
	executionState["macroDefinitions"]									=	deepCopy(macroDefinitions)
	executionState["currentMacroNames"]									=	deepCopy(currentMacroNames)
	executionState["gTokenLocationLinesChars"]							=	deepCopy(gTokenLocationLinesChars)
	executionState["unraveled"]											=	deepCopy(unraveled)
	executionState["fileDisplayOffset"]									=	deepCopy(fileDisplayOffset)
	executionState["dataLocationOffset"]								=	deepCopy(dataLocationOffset)
	executionState["codeFileName"]										=	deepCopy(codeFileName)
	executionState["dataFileName"]										=	deepCopy(dataFileName)
	executionState["dataFileSizeInBytes"]								=	deepCopy(dataFileSizeInBytes)
	executionState["displayBlock"]										=	deepCopy(displayBlock)
	executionState["dataBlock"]											=	deepCopy(dataBlock)
	executionState["inputIsHexChar"]									=	deepCopy(inputIsHexChar)
	executionState["binaryArray"]										=	deepCopy(binaryArray)
	executionState["hexCharArray"]										=	deepCopy(hexCharArray)
	executionState["totalBytesToReadFromDataFile"]						=	deepCopy(totalBytesToReadFromDataFile)
	executionState["dummyVariableCount"]								=	deepCopy(dummyVariableCount)
	executionState["dummyZeroWidthBitfieldVariableCount"]				=	deepCopy(dummyZeroWidthBitfieldVariableCount)
	executionState["totalVariableCount"]								=	deepCopy(totalVariableCount)
	executionState["runtimeStatementLocationsInGlobalScope"]			=	deepCopy(runtimeStatementLocationsInGlobalScope)
	executionState["runtimeStatementOrGlobalScopedVariableIdOrStructId"]=	deepCopy(runtimeStatementOrGlobalScopedVariableIdOrStructId)
	executionState["runtimeStatementLineNumbers"]						=	deepCopy(runtimeStatementLineNumbers)
	executionState["variableIdsInGlobalScope"]							=	deepCopy(variableIdsInGlobalScope)
	executionState["globalScopedBuddies"]								=	deepCopy(globalScopedBuddies)
	executionState["globalScopedRuntimeBlocks"]							=	deepCopy(globalScopedRuntimeBlocks)
#	executionState["allPossibleQualifiedNames"]							=	deepCopy(allPossibleQualifiedNames)
	executionState["globalScopesSelected"]								=	deepCopy(globalScopesSelected)
	executionState["variableSelectedIndices"]							=	deepCopy(variableSelectedIndices)
	executionState["variablesAtGlobalScopeSelected"]					=	deepCopy(variablesAtGlobalScopeSelected)
	executionState["coloredVarsIdOffsetSize"]							=	deepCopy(coloredVarsIdOffsetSize)
	executionState["coloredDataIdOffsetSize"]							=	deepCopy(coloredDataIdOffsetSize)
	executionState["inputVariables"]									=	deepCopy(inputVariables)
	executionState["MAINLOOP_STARTED"]									=	deepCopy(MAINLOOP_STARTED)
	executionState["pragmaPackStack"]									=	deepCopy(pragmaPackStack)
	executionState["pragmaPackCurrentValue"]							=	deepCopy(pragmaPackCurrentValue)
	
	if inputDict:
		if not isinstance(inputDict,dict):
			errorMessage = "ERROR in saveExecutionState(): passed inputDict is of type <"+type(inputDict)+">, when dictionary is expected"
			errorRoutine(errorMessage)
			return False
		else:
			executionState["localVariables"]							=	deepCopy(inputDict)

	executionStateStack.append(executionState)
	return

###################################################################################################################################
# This routine restores the execution state 
###################################################################################################################################
def restoreGlobalsAndReturnLocals():
#	global executionStateStack	# This is where the context is stored. We do not pop() it here since we may need to restore it again and again. We manually pop it.
	global lines, enums, enumFieldValues, typedefs, suDict, structuresAndUnions, variableDeclarations, macroDefinitions, currentMacroNames, gTokenLocationLinesChars 
	global unraveled, fileDisplayOffset, dataLocationOffset, codeFileName, dataFileName, dataFileSizeInBytes, displayBlock, dataBlock, inputIsHexChar, binaryArray 
	global hexCharArray, totalBytesToReadFromDataFile, dummyVariableCount, dummyZeroWidthBitfieldVariableCount, totalVariableCount, runtimeStatementLocationsInGlobalScope
	global runtimeStatementOrGlobalScopedVariableIdOrStructId, variableIdsInGlobalScope, globalScopedBuddies, globalScopedRuntimeBlocks	#, allPossibleQualifiedNames
	global globalScopesSelected, variableSelectedIndices, variablesAtGlobalScopeSelected, coloredVarsIdOffsetSize, coloredDataIdOffsetSize, inputVariables, MAINLOOP_STARTED
	global pragmaPackStack, pragmaPackCurrentValue, runtimeStatementLineNumbers

	if not executionStateStack:
		errorMessage = "ERROR in restoreExecutionState(): Empty executionStateStack"
		errorRoutine(errorMessage)
		return False
	else:
		executionState = executionStateStack[-1]
	if( lines != executionState["lines"]):
		PRINT("lines has changed - restoring it from saved execution state")
		lines =	deepCopy(executionState["lines"])
	if( enums != executionState["enums"]):
		PRINT("enums has changed - restoring it from saved execution state")
		enums = deepCopy(executionState["enums"])
	if( enumFieldValues != executionState["enumFieldValues"]):
		PRINT("enumFieldValues has changed - restoring it from saved execution state")
		enumFieldValues = deepCopy(executionState["enumFieldValues"])
	if( typedefs != executionState["typedefs"]):
		PRINT("typedefs has changed - restoring it from saved execution state")
		typedefs = deepCopy(executionState["typedefs"])
	if( suDict != executionState["suDict"]):
		PRINT("suDict has changed - restoring it from saved execution state")
		suDict = deepCopy(executionState["suDict"])
	if( structuresAndUnions != executionState["structuresAndUnions"]):
		PRINT("structuresAndUnions has changed - restoring it from saved execution state")
		structuresAndUnions = deepCopy(executionState["structuresAndUnions"])
	if( variableDeclarations != executionState["variableDeclarations"]):
		PRINT("variableDeclarations has changed - restoring it from saved execution state")
		variableDeclarations = deepCopy(executionState["variableDeclarations"])
	if( macroDefinitions != executionState["macroDefinitions"]):
		PRINT("macroDefinitions has changed - restoring it from saved execution state")
		macroDefinitions = deepCopy(executionState["macroDefinitions"])
	if( currentMacroNames != executionState["currentMacroNames"]):
		PRINT("currentMacroNames has changed - restoring it from saved execution state")
		currentMacroNames =	deepCopy(executionState["currentMacroNames"])
	if( gTokenLocationLinesChars != executionState["gTokenLocationLinesChars"]):
		PRINT("gTokenLocationLinesChars has changed - restoring it from saved execution state")
		gTokenLocationLinesChars = deepCopy(executionState["gTokenLocationLinesChars"])
	if( unraveled != executionState["unraveled"]):
		PRINT(unraveled,"has changed - restoring it from saved execution state")
		unraveled =	deepCopy(executionState["unraveled"])
	if( fileDisplayOffset != executionState["fileDisplayOffset"]):
		PRINT("fileDisplayOffset has changed - restoring it from saved execution state")
		fileDisplayOffset =	deepCopy(executionState["fileDisplayOffset"])
	if( dataLocationOffset != executionState["dataLocationOffset"]):
		PRINT("dataLocationOffset has changed - restoring it from saved execution state")
		dataLocationOffset = deepCopy(executionState["dataLocationOffset"])
	if( codeFileName != executionState["codeFileName"]):
		PRINT("codeFileName has changed - restoring it from saved execution state")
		codeFileName = deepCopy(executionState["codeFileName"])
	if( dataFileName != executionState["dataFileName"]):
		PRINT("dataFileName has changed - restoring it from saved execution state")
		dataFileName = deepCopy(executionState["dataFileName"])
	if( dataFileSizeInBytes != executionState["dataFileSizeInBytes"]):
		PRINT("dataFileSizeInBytes has changed - restoring it from saved execution state")
		dataFileSizeInBytes = deepCopy(executionState["dataFileSizeInBytes"])
	if( displayBlock != executionState["displayBlock"]):
		PRINT("displayBlock has changed - restoring it from saved execution state")
		displayBlock = deepCopy(executionState["displayBlock"])
	if( dataBlock != executionState["dataBlock"]):
		PRINT("dataBlock has changed - restoring it from saved execution state")
		dataBlock =	deepCopy(executionState["dataBlock"])
	if( inputIsHexChar != executionState["inputIsHexChar"]):
		PRINT("inputIsHexChar has changed - restoring it from saved execution state")
		inputIsHexChar = deepCopy(executionState["inputIsHexChar"])
	if( binaryArray != executionState["binaryArray"]):
		PRINT("binaryArray has changed - restoring it from saved execution state")
		binaryArray = deepCopy(executionState["binaryArray"])
	if( hexCharArray != executionState["hexCharArray"]):
		PRINT("hexCharArray has changed - restoring it from saved execution state")
		hexCharArray = deepCopy(executionState["hexCharArray"])
	if( totalBytesToReadFromDataFile != executionState["totalBytesToReadFromDataFile"]):
		PRINT("totalBytesToReadFromDataFile has changed - restoring it from saved execution state")
		totalBytesToReadFromDataFile = deepCopy(executionState["totalBytesToReadFromDataFile"])
	if( dummyVariableCount != executionState["dummyVariableCount"]):
		PRINT("dummyVariableCount has changed - restoring it from saved execution state")
		dummyVariableCount = deepCopy(executionState["dummyVariableCount"])
	if( dummyZeroWidthBitfieldVariableCount != executionState["dummyZeroWidthBitfieldVariableCount"]):
		PRINT("dummyZeroWidthBitfieldVariableCount has changed - restoring it from saved execution state")
		dummyZeroWidthBitfieldVariableCount = deepCopy(executionState["dummyZeroWidthBitfieldVariableCount"])
	if( totalVariableCount != executionState["totalVariableCount"]):
		PRINT("totalVariableCount has changed - restoring it from saved execution state")
		totalVariableCount = deepCopy(executionState["totalVariableCount"])
	if( runtimeStatementLineNumbers != executionState["runtimeStatementLineNumbers"]):
		PRINT("runtimeStatementLineNumbers has changed - restoring it from saved execution state")
		runtimeStatementLineNumbers = deepCopy(executionState["runtimeStatementLineNumbers"])
	if( runtimeStatementLocationsInGlobalScope != executionState["runtimeStatementLocationsInGlobalScope"]):
		PRINT("runtimeStatementLocationsInGlobalScope has changed - restoring it from saved execution state")
		runtimeStatementLocationsInGlobalScope = deepCopy(executionState["runtimeStatementLocationsInGlobalScope"])
	if( runtimeStatementOrGlobalScopedVariableIdOrStructId != executionState["runtimeStatementOrGlobalScopedVariableIdOrStructId"]):
		PRINT("runtimeStatementOrGlobalScopedVariableIdOrStructId has changed - restoring it from saved execution state")
		runtimeStatementOrGlobalScopedVariableIdOrStructId = deepCopy(executionState["runtimeStatementOrGlobalScopedVariableIdOrStructId"])
	if( variableIdsInGlobalScope != executionState["variableIdsInGlobalScope"]):
		PRINT("variableIdsInGlobalScope has changed - restoring it from saved execution state")
		variableIdsInGlobalScope = deepCopy(executionState["variableIdsInGlobalScope"])
	if( globalScopedBuddies != executionState["globalScopedBuddies"]):
		PRINT("globalScopedBuddies has changed - restoring it from saved execution state")
		globalScopedBuddies = deepCopy(executionState["globalScopedBuddies"])
	if( globalScopedRuntimeBlocks != executionState["globalScopedRuntimeBlocks"]):
		PRINT("globalScopedRuntimeBlocks has changed - restoring it from saved execution state")
		globalScopedRuntimeBlocks = deepCopy(executionState["globalScopedRuntimeBlocks"])
#	if( allPossibleQualifiedNames != executionState["allPossibleQualifiedNames"]):
#		PRINT("allPossibleQualifiedNames has changed - restoring it from saved execution state")
#		allPossibleQualifiedNames =	deepCopy(executionState["allPossibleQualifiedNames"])
	if( globalScopesSelected != executionState["globalScopesSelected"]):
		PRINT("globalScopesSelected has changed - restoring it from saved execution state")
		globalScopesSelected = deepCopy(executionState["globalScopesSelected"])
	if( variableSelectedIndices != executionState["variableSelectedIndices"]):
		PRINT("variableSelectedIndices has changed - restoring it from saved execution state")
		variableSelectedIndices = deepCopy(executionState["variableSelectedIndices"])
	if( variablesAtGlobalScopeSelected != executionState["variablesAtGlobalScopeSelected"]):
		PRINT("variablesAtGlobalScopeSelected has changed - restoring it from saved execution state")
		variablesAtGlobalScopeSelected = deepCopy(executionState["variablesAtGlobalScopeSelected"])
	if( coloredVarsIdOffsetSize != executionState["coloredVarsIdOffsetSize"]):
		PRINT("coloredVarsIdOffsetSize has changed - restoring it from saved execution state")
		coloredVarsIdOffsetSize = deepCopy(executionState["coloredVarsIdOffsetSize"])
	if( coloredDataIdOffsetSize != executionState["coloredDataIdOffsetSize"]):
		PRINT("coloredDataIdOffsetSize coloredDataIdOffsetSize has changed - restoring it from saved execution state")
		coloredDataIdOffsetSize = deepCopy(executionState["coloredDataIdOffsetSize"])
	if( inputVariables != executionState["inputVariables"]):
		PRINT("inputVariables has changed - restoring it from saved execution state")
		inputVariables = deepCopy(executionState["inputVariables"])
	if( MAINLOOP_STARTED != executionState["MAINLOOP_STARTED"]):
		PRINT("MAINLOOP_STARTED has changed - restoring it from saved execution state")
		MAINLOOP_STARTED = deepCopy(executionState["MAINLOOP_STARTED"])
	if( pragmaPackStack != executionState["pragmaPackStack"]):
		PRINT("pragmaPackStack has changed - restoring it from saved execution state")
		pragmaPackStack = deepCopy(executionState["pragmaPackStack"])
	if( pragmaPackCurrentValue != executionState["pragmaPackCurrentValue"]):
		PRINT("pragmaPackCurrentValue has changed - restoring it from saved execution state")
		pragmaPackCurrentValue = deepCopy(executionState["pragmaPackCurrentValue"])
	

	outputDict = deepCopy(executionState["localVariables"])
	'''
	globalsDeepCopied = ("lines", "enums", "enumFieldValues", "typedefs", "suDict", "structuresAndUnions", "variableDeclarations", "macroDefinitions", "currentMacroNames", 
						"gTokenLocationLinesChars", "unraveled", "fileDisplayOffset", "dataLocationOffset", "codeFileName", "dataFileName", "dataFileSizeInBytes", "displayBlock", 
						"dataBlock", "inputIsHexChar", "binaryArray", "hexCharArray", "totalBytesToReadFromDataFile", "dummyVariableCount", "dummyZeroWidthBitfieldVariableCount", 
						"totalVariableCount", "runtimeStatementLocationsInGlobalScope", "runtimeStatementOrGlobalScopedVariableIdOrStructId", "variableIdsInGlobalScope", 
						"globalScopedBuddies", "globalScopedRuntimeBlocks", "allPossibleQualifiedNames", "globalScopesSelected", "variableSelectedIndices", 
						"variablesAtGlobalScopeSelected", "coloredVarsIdOffsetSize", "coloredDataIdOffsetSize", "inputVariables", "MAINLOOP_STARTED", "pragmaPackStack", 
						"pragmaPackCurrentValue")
	for key in getDictKeyList(executionState):
		if key in globalsDeepCopied:
			pass
		else:
			outputDict[key] = deepCopy(executionState[key])
	'''
#	executionStateStack.pop()
	
	return outputDict


##########################################################################################################################
# This function returns the max value in a specific column of a supplied list
##########################################################################################################################
def minOrMaxValueInColumn(inputList, columnIndex, minOrMax):
	if not isinstance(inputList,list) or not inputList:
		errorMessage = "ERROR in minOrMaxValueInColumn(): Supplied input list (%s) is not actually a proper list"%(STR(inputList))
		errorRoutine(errorMessage)
		return [False, None]
	elif not checkIfIntegral(columnIndex) or columnIndex < 0:
		errorMessage = "ERROR in minOrMaxValueInColumn(): Illegal column index value"%(STR(columnIndex))
		errorRoutine(errorMessage)
		return [False, None]
	elif not checkIfString(minOrMax) or minOrMax.lower() not in ("min","max"):
		errorMessage = "ERROR in minOrMaxValueInColumn(): 3rd parameter (%s) must be either 'min' or 'max'"%(STR(minOrMax))
		errorRoutine(errorMessage)
		return [False, None]
	
	minOrMax = minOrMax.lower()
	returnValue = LARGE_POSITIVE_NUMBER if minOrMax == "min" else LARGE_NEGATIVE_NUMBER if minOrMax == "max" else "THIS_SHOULD_CRASH_THE_PROGRAM"
	
	atLeastOneRowHasLegitimateValue = False
	for row in inputList:
		if checkIfString(row):
			continue
		elif not isinstance(row,list) or not row:
			continue
		elif columnIndex >= len(row):
			continue
		elif not checkIfNumber(row[columnIndex]):
			continue
		else:
			atLeastOneRowHasLegitimateValue = True
			if minOrMax == "max":
				returnValue = row[columnIndex] if row[columnIndex] > returnValue else returnValue
			elif minOrMax == "min":
				returnValue = row[columnIndex] if row[columnIndex] < returnValue else returnValue
			else:
				OUTPUT("Bad coding - exiting!!!")
				sys.exit()
				
	if atLeastOneRowHasLegitimateValue:
		return [True, returnValue]
	else:
		return [False, None]

	
##############################################################################################################################################################
# When we are supplying a string to a regular expression module, the string may contain characters that are used for regular expressions, like *, \, ( + etc.
##############################################################################################################################################################
def escapeREmetacharacters(inputString):
	if not checkIfString(inputString):
		PRINT ("inputString =",inputString,"is not a string - exiting!" )
		return False
		sys.exit()
	else:
		outputString = ''
		reMetacharacters = ['*','+','\\','[',']','(',')','.','^','$','{','}','|','?']
		for c in inputString:
			outputString = outputString + ('\\' + c if c in reMetacharacters else c)
		return outputString
		
#######################################################################################################################################################
# This function returns the size of the datatype.
#
# This function will NOT be able to return the correct value for very complicated expressions, because unlike a full-ledged compiler, here we are
# NOT actually allocating any memory on the stack. Hence, it cannot handle complex expressions involving * and &.
#
# It can only handle very simple expressions like sizeof(S1.S2.S3.i) etc.
#
#######################################################################################################################################################
def getDatatypeSize(inputList):
	PRINT ("\n\n","=="*50,"\nGoing to evaluate getDatatypeSize(inputList) for inputList =",inputList)
	if isinstance(inputList,list):
		if len(inputList) == 1:
			return getDatatypeSize(inputList[0])
		elif len(inputList) == 2 and inputList[0] in ("struct","union"):
			return getDatatypeSize(inputList[1])
		elif len(inputList) == 2 and inputList[0] in ("datatype"):
			return getDatatypeSize(inputList[1])
		elif len(inputList)>1 and inputList[-1] == "*":	# This is handling cases like "unsigned char *"
			allItemsAreDatatypes = True
			for item in inputList[:len(inputList)-1]:
				if ((item not in getDictKeyList(primitiveDatatypeLength)) and 
				    (item not in getDictKeyList(cDataTypes)) and 
				    (item not in getDictKeyList(typedefs)) and 
					(item not in getDictKeyList(suDict))):
					allItemsAreDatatypes = False
					break
			if allItemsAreDatatypes:
				return primitiveDatatypeLength["pointer"]
			else:
				errorMessage = "ERROR: unknown items prior to pointer in <%s>  - exiting"%(STR(inputList))
				errorRoutine(errorMessage)
				return False
		elif len(inputList) == 3 and inputList[1] in (".","->"):
			PRINT("variableDeclarations =")
			for item in variableDeclarations: PRINT(item)
			PRINT("structuresAndUnions =")
			for row in structuresAndUnions : PRINT(row)
			PRINT("Struct member operator")
			flattenedList = flattenList(inputList)
			PRINT ("Will try to make sense of the following expressions:",flattenedList)
			newSize = -1
			N = 0
			while N < len(flattenedList):
				PRINT ("\n"*2,"N =",N,"\n"*2)
				gotoNextCycle = False
				if N==0:
					# For the first item, it must be a declared variable (so check in variableDeclarations)
					nextDataType = ""
					for item in variableDeclarations:
						if item[0] == flattenedList[N]:
							PRINT ("variable",item[0],"exists in variableDeclarations")
							variableDescription = item[4]
							PRINT ("For variable",item[0],", variable description = ",variableDescription)
							datatype = variableDescription["datatype"]
							PRINT ("variable",item[0],"\'s datatype = ",datatype)
							if datatype in getDictKeyList(suDict):
								PRINT ("variable",item[0],"\'s datatype = ",datatype,"is a struct/union")
								components = structuresAndUnions[suDict[datatype][-1]]["components"]
								for c in components:
									if c[0] == flattenedList[N+2]:
										nextDataType = c[4]["datatype"]
										newSize = c[1]
										break
							else:
								errorMessage = "ERROR: cannot use %s operator on non-member variable %s - exiting"%(STR(flattenedList[N+1]), STR(flattenedList[N+2]))
								errorRoutine(errorMessage)
								return False
							PRINT ("For new variable",flattenedList[N+2],", datatype = ",nextDataType,", size =",newSize)
					if nextDataType == "":
						errorMessage = "ERROR: cannot use %s operator on non-member variable %s - exiting"%(STR(flattenedList[N+1]), STR(flattenedList[N+2]))
						errorRoutine(errorMessage)
						return False
					else:
						N = N + 2
						gotoNextCycle = True
						continue
				elif N == len(flattenedList)-1:
					return newSize
				elif N < len(flattenedList)-1 and flattenedList[N+1] in (".","->") and nextDataType not in getDictKeyList(suDict):
						errorMessage = "ERROR: cannot use %s operator on non-struct variable %s - exiting"%(STR(flattenedList[N+1]), STR(flattenedList[N]))
						errorRoutine(errorMessage)
						return False
				elif N < len(flattenedList)-1 and flattenedList[N+1] in (".","->") and (N+1==len(flattenedList)-1):
					errorMessage = "ERROR: cannot use %s operator on struct variable %s without specifying any member variable - exiting"%(STR(flattenedList[N+1]), STR(flattenedList[N]))
					errorRoutine(errorMessage)
					return False
				elif ("components" not in getDictKeyList(structuresAndUnions[suDict[nextDataType][-1]])) or (structuresAndUnions[suDict[nextDataType][-1]]["components"] =={}):
					PRINT (getDictKeyList(structuresAndUnions[suDict[nextDataType][-1]]))
					errorMessage = "ERROR: cannot use %s operator on blank struct variable %s - exiting"%(STR(flattenedList[N+1]), STR(nextDataType))
					errorRoutine(errorMessage)
					return False
				else:
					PRINT ("Passed error checks for N=",N,"nextDataType =",nextDataType)
					components = structuresAndUnions[suDict[nextDataType][-1]]["components"]
					componentFound = False
					for c in components:
						if c[0] == flattenedList[N+2]:
							newDataType = c[4]["datatype"]
							newSize = c[1]
							componentFound = True
							PRINT ("For new variable",flattenedList[N+2],", datatype = ",newDataType,", size =",newSize)
							break
					if componentFound == False:
						errorMessage = "ERROR: cannot use %s operator on blank struct variable %s - exiting"%(STR(flattenedList[N+1]), STR(nextDataType))
						errorRoutine(errorMessage)
						return False
					else:
						nextDataType = newDataType
						
						N = N + 2
						gotoNextCycle = True
						
						continue

				if gotoNextCycle == False:
					PRINT("ERROR: The control should never come here - should error out much before")
					errorMessage = "ERROR: The control should never come here - should error out much before. N=%d"%(N)
					errorRoutine(errorMessage)
					return False
				
			if newSize < 0:
				errorMessage = "ERROR: Could not calculate the size"
				errorRoutine(errorMessage)
				return False
			else:
				return newSize
				
		else:
			errorMessage = "ERROR: unknown length list inputList=<%s>  - exiting"%(STR(inputList))
			errorRoutine(errorMessage)
			return False
			
	elif checkIfString(inputList):
#		PRINT ("inputList = <",inputList,"> is a string, now checking")
		if inputList in getDictKeyList(primitiveDatatypeLength):
			return primitiveDatatypeLength[inputList]
		elif inputList in getDictKeyList(suDict):
			return structuresAndUnions[suDict[inputList][-1]]["size"]
		elif inputList in getDictKeyList(typedefs):
#			return getDatatypeSize(typedefs[inputList])		#Bug fix on 2020-03-04
			return typedefs[inputList][1]
		else:
			PRINT ("Checking if ",inputList,"is any of the variables declared before" )
			PRINT (variableDeclarations )
			for i in range(len(variableDeclarations)):
				if variableDeclarations[i][0] == inputList:
					return variableDeclarations[i][1]
			PRINT ("The variable",inputList,"is any of the variables declared before, hence cannot determine the size of" )
			errorMessage = "ERROR: The variable"+inputList+"is any of the variables declared before, hence cannot determine the size of"
			errorRoutine(errorMessage)
			return False
	else:
		errorMessage = "ERROR: Unknown inputList <%s>  - exiting"%(STR(inputList))
		errorRoutine(errorMessage)
		return False
		
	
def isStringAValidNumber(numericString):
	if numericString.isdigit():
#		PRINT ("Is digit")
		return True
	elif checkIfString(numericString):
		PRINT ("numericString =",numericString,"is string")
		if "." in numericString: 
#			PRINT ("has a decimal point")
			if numericString.count(".")>1:
#				PRINT ("more than once")
				return False
			else:
#				PRINT ("only once")
				if numericString[-1] == ".":
					PRINT ("The decimal cannot be at the end") 
					return False
				elif numericString[0] == ".":
					return numericString[1:].isdigit()
				else:
					digitParts = re.split(r"\.",numericString)
#					PRINT ("digitParts =",digitParts)
					if len(digitParts) != 2:
						return False
					else:
						return digitParts[0].isdigit() and digitParts[1].isdigit()
		else:
			return False
	else:
		return False



# Float numbers are difficult to say that are equal in value. So we say they are equal if they are "close enough"
def areFloatsCloseEnough (f1, f2, relativeTolerance = RELATIVE_TOLERANCE_FOR_FLOAT, absoluteTolerance = ABSOLUTE_TOLERANCE_FOR_FLOAT):
	PRINT=OUTPUT
	if f1 == f2:	# Just what the heck
		return True
		
	if relativeTolerance < 0 or absoluteTolerance < 0:
		errorMessage = "Error in areFloatsCloseEnough(): tolerances must be non-negative"
		errorRoutine(errorMessage) 
		return False

	difference = abs(f1-f2)
	relativeDifference = difference / max(abs(f1), abs(f2))
	
	PRINT("f1 = ",f1, ", f2 =", f2, ", difference =", difference, ", relativeDifference =",relativeDifference, ", relativeTolerance =",relativeTolerance)
	
	if difference <= absoluteTolerance:
		return True
	elif relativeDifference <= relativeTolerance:
		PRINT(f1,"and",f2,"are close enough floating point numbers")
		return True
	else:
		PRINT(f1,"and",f2,"are NOT close enough floating point numbers - the relativeDifference (",relativeDifference,") is > relativeTolerance (",relativeTolerance,")")
		return False


#######################################################################################################################################################
#
# 						!!!! 	THIS FUNCTION NEEDS AN AST, NOT JUST A LIST !!!!!
#
# This function takes a list of tokens representing an Arithmetic Expression AST, evaluates it, and returns the result.
# The input must be a valid AST, otherwise it will not work. Just giving it in the token list form is not sufficient.
# The output from this is a Tuple of a boolean value and a result [True/Flase, result]. The reason we do this is because an arithmetic expression result
# can itself return False as a proper output, so we do not know if that is a true result, or something went wrong.
#######################################################################################################################################################
def evaluateArithmeticExpression(inputAST):
#	PRINT=OUTPUT
	executionStage = "Interpret" if lastActionWasInterpret else "Map" if lastActionWasMap  else "Undefined Execution Stage"
	inputList = inputAST	# Just to remind that the inputList must be an AST
	PRINT ("Inside evaluateArithmeticExpression(inputList =", inputList,") during", executionStage)
	if checkIfNumber(inputList):
		PRINT("Returning [True,",inputList,"] since it is a number")
		return [True,inputList]
	elif checkIfString(inputList):
#		PRINT ("It's a string - returning as it is!" )
		if isStringAValidNumber(inputList):
			if '.' in inputList:
				return [True,float(inputList)]
			else:
				return [True, int(inputList)]
		elif len(inputList)>=3 and inputList[:2]=="0x": 
			if re.match("^[a-fA-F0-9]+(u|U|l|L|ll|LL|ul|UL|lu|LU|ull|ULL|LLU|llu)?$",inputList[2:]):
				if inputList[-3:] in ('ULL','ull'):
					value2convert = inputList[:-3]
				elif inputList[-2:] in ('LL','ll', 'ul','UL'):
					value2convert = inputList[:-2]
				elif inputList[-1] in ('L','l', 'u','U'):
					value2convert = inputList[:-1]
				else:
					value2convert = inputList[:]
				result = int(value2convert,16)
				PRINT("Input is Hex number, returning ",[True,result])
				return [True,result]
			else:
				errorMessage = "WARNING - non-numeric string <%s> - cannot evaluate HEX undefined constant"%(STR(inputList))
				errorRoutine(errorMessage)
				return [False, None]
		elif len(inputList)>=3 and inputList[:2]=="0o": 
			if re.match("^[0-7]+(u|U|l|L|ll|LL|ul|UL|lu|LU|ull|ULL|LLU|llu)?$",inputList[2:]):
				if inputList[-3:] in ('ULL','ull'):
					value2convert = inputList[:-3]
				elif inputList[-2:] in ('LL','ll', 'ul','UL'):
					value2convert = inputList[:-2]
				elif inputList[-1] in ('L','l', 'u','U'):
					value2convert = inputList[:-1]
				else:
					value2convert = inputList[:]
				return [True,int(value2convert,8)]
			else:
				errorMessage = "WARNING - non-numeric string <%s> - cannot evaluate Octal undefined constant"%(STR(inputList))
				errorRoutine(errorMessage)
				return [False, None]
		elif len(inputList)>=3 and inputList[:2]=="0b": 
			if re.match("^[01]+(u|U|l|L|ll|LL|ul|UL|lu|LU|ull|ULL|LLU|llu)?$",inputList[2:]):
				if inputList[-3:] in ('ULL','ull'):
					value2convert = inputList[:-3]
				elif inputList[-2:] in ('LL','ll', 'ul','UL'):
					value2convert = inputList[:-2]
				elif inputList[-1] in ('L','l', 'u','U'):
					value2convert = inputList[:-1]
				else:
					value2convert = inputList[:]
				return [True,int(value2convert,2)]
			else:
				errorMessage = "WARNING - non-numeric string <%s> - cannot evaluate Binary undefined constant"%(STR(inputList))
				errorRoutine(errorMessage)
				return [False, None]
		elif re.match("^[0-9]+(u|U|l|L|ll|LL|ul|UL|lu|LU|ull|ULL|LLU|llu)?$",inputList):
				if inputList[-3:] in ('ULL','ull'):
					value2convert = inputList[:-3]
				elif inputList[-2:] in ('LL','ll', 'ul','UL'):
					value2convert = inputList[:-2]
				elif inputList[-1] in ('L','l', 'u','U'):
					value2convert = inputList[:-1]
				else:
					value2convert = inputList[:]
				result = int(value2convert)
				PRINT("Input is decimal integer, returning",[True,result])
				return [True,result]
				
		elif inputList in getDictKeyList(enumFieldValues):
			return [True, int(enumFieldValues[inputList])]
			
		elif inputList[0] not in ['"',"'"] and inputList[-1] not in ['"',"'"]:
			# The inputList is NEITHER a valid numberic constant NOR a quoted string - it must be a variable name, whose value can only be known during the runtime.
			# If this happens during the Interpret stage, there is no unraveled and thus no way to verify if the condition is True or False
			runtimeVariableName = outputTextArithmeticExpressionFromAST(inputList)
			if not lastActionWasInterpret and not lastActionWasMap:
				errorMessage = "Sanity Check Error in evaluateArithmeticExpression() while evaluating the variable name: <%s>: Both the Interpret and Map are False"%STR(inputList)
				errorRoutine(errorMessage)
				return [False, None]
			elif lastActionWasInterpret:	# During the interpret phase, we cannot figure out what the value is.
				PRINT("Inside evaluateArithmeticExpression() during Interpret - cannot evaluate the variable name: <",STR(inputList),">, hence returning a LOGICAL_TEST_RESULT_INDETERMINATE value")
				return [True, LOGICAL_TEST_RESULT_INDETERMINATE]
			elif lastActionWasMap:
				if not unraveled:
					errorMessage = "Error in evaluateArithmeticExpression() while evaluating the variable name: <%s>: No unraveled yet"%STR(inputList)
					errorRoutine(errorMessage)
					return [False, None]
				else:
					foundInUnraveled = False
					valueInUnraveled = None
					# First try to find an exact match, from last to first record in unraveled
					i = len(unraveled)-1
					while (i>=0):
						unraveledVariableName = unraveled[i][1]
						if unraveledVariableName == runtimeVariableName:
							foundInUnraveled = True
							# By default we are taking the LE value. Can change it to BE by setting the DEFAULT_ENDIANNESS parametter to BIG_ENDIAN
							valueInUnraveled = unraveled[i][6+DEFAULT_ENDIANNESS]	
							unraveledVariableId = unraveled[i][8][-1]
							break
						i -= 1
					if foundInUnraveled:
						PRINT("Found exact match in unraveled for variable",runtimeVariableName,", LE value is",valueInUnraveled)
					else:
						PRINT("Found NO exact match in unraveled for variable",runtimeVariableName,", trying to find approximate match")
						
					# If exact match is not found, try to find an approximate match
					if not foundInUnraveled:
						i = len(unraveled)-1
						while (i>=0):
							unraveledVariableName = unraveled[i][1]
							if checkIfSameUnraveledVariable(runtimeVariableName, unraveledVariableName):
								foundInUnraveled = True
								# By default we are taking the LE value. Can change it to BE by setting the DEFAULT_ENDIANNESS parametter to BIG_ENDIAN
								valueInUnraveled = unraveled[i][6+DEFAULT_ENDIANNESS]	
								unraveledVariableId = unraveled[i][8][-1]
								break
							i -= 1
					if foundInUnraveled:
						PRINT("Found approximate match in unraveled for variable",runtimeVariableName,", LE value is",valueInUnraveled)
					else:
						PRINT("Found NO approximate match in unraveled for variable",runtimeVariableName,", trying to find suffix match")
						
					# If exact match is not found, try to find a suffix match
					if not foundInUnraveled:
						i = len(unraveled)-1
						while (i>=0):
							unraveledVariableName = unraveled[i][1]
							if checkIfSameUnraveledVariable(runtimeVariableName, unraveledVariableName, False):
								foundInUnraveled = True
								# By default we are taking the LE value. Can change it to BE by setting the DEFAULT_ENDIANNESS parametter to BIG_ENDIAN
								valueInUnraveled = unraveled[i][6+DEFAULT_ENDIANNESS]	
								unraveledVariableId = unraveled[i][8][-1]
								break
							i -= 1
					if foundInUnraveled:
						PRINT("Found Suffix match in unraveled for variable",runtimeVariableName,", LE value is",valueInUnraveled)
					else:
						PRINT("Found NO Suffix match in unraveled for variable",runtimeVariableName,", so absolutely no match possible")
							
					if foundInUnraveled:
						PRINT("Found match in unraveled for variable",runtimeVariableName,", LE value is",valueInUnraveled)
						if valueInUnraveled == None:
							errorMessage = "Coding bug in evaluateArithmeticExpression() - blank value for %s despite finding it in unraveled.<%s>"%(STR(runtimeVariableName),STR(inputList))
							errorRoutine(errorMessage)
							OUTPUT("Coding bug in evaluateArithmeticExpression() - blank value despite finding it in unraveled")
							return [False, None]
						else:
							if DISPLAY_INTEGRAL_VALUES_IN_HEX and variableDeclarations[unraveledVariableId][4]["datatype"] in ("char","short","int","long","long long"):
								PRINT("For unraveled variable",runtimeVariableName,"(variable id",unraveledVariableId,"), variableDeclarations[unraveledVariableId][4][\"datatype\"] =",variableDeclarations[unraveledVariableId][4]["datatype"])
								if valueInUnraveled.startswith("0x") or valueInUnraveled.startswith("-0x"):
									PRINT("for variable "+unraveledVariableName+", the value stored in unraveled is <"+valueInUnraveled+">")
									valueInUnraveled = int(valueInUnraveled,16)
									PRINT("Which is then transformed into decimal value of",valueInUnraveled)
								else:
									errorMessage = "Error in evaluateArithmeticExpression evaluating valueInUnraveled = <"+STR(valueInUnraveled)+"> - for variable "+unraveledVariableName+", the value stored in unraveled ("+valueInUnraveled+") is not a Hex string"
									errorRoutine(errorMessage)
									return [False, None]
							return [True, valueInUnraveled]
					else:
						errorMessage = "Error in evaluateArithmeticExpression(): In the input arithmatic expression " + STR(inputList) + " , did not find the variable name: <%s> in unraveled during %s"%(STR(runtimeVariableName), executionStage)
						errorRoutine(errorMessage)
						return [False, None]
			else:
				OUTPUT("Coding error in evaluateArithmeticExpression() - exiting")
				sys.exit()
		elif inputList[0] == "'" and inputList[-1] == "'" and len(inputList)==3:
			asciiCharArray = [chr(i) for i in range(256)]
			if inputList[1] in asciiCharArray:
				return [True, asciiCharArray.index(inputList[1])]
			else:
				errorMessage = "WARNING - non-numeric character <%s> - cannot evaluate undefined constant"%(STR(inputList))
				errorRoutine(errorMessage)
				return [False, None]
		else:
			errorMessage = "WARNING - non-numeric string <%s> - cannot evaluate undefined constant"%(STR(inputList))
			errorRoutine(errorMessage)
			return [False, None]

	elif isinstance(inputList,list):
	
		if not isASTvalid(inputList):
			warningMessage = "WARNING - evaluating the arithmetic expression may not work because the inputList <" +STR(inputList)+ "> is not a valid AST" 
			warningRoutine(warningMessage)
		
		# If it is a list of lists, but contains only a single member, remove one level of listification
		if len(inputList) == 1:
#			PRINT ("Returning",inputList[0] )
			result = evaluateArithmeticExpression(inputList[0])
			if result[0] == False:
				errorMessage = "Error in evaluateArithmeticExpression evaluating inputList[0] = <"+STR(inputList[0])+">"
				errorRoutine(errorMessage)
				return [False, None]
			else:
				return [True, result[1]]
			
		# 2-member lists
		elif len(inputList) == 2:

			if inputList[0] in ['()','~','+','-',"!","*","&","++"]:
			
				evaluateArithmeticExpressionOutput1 = evaluateArithmeticExpression(inputList[1])
				
				if len(evaluateArithmeticExpressionOutput1) != 2 or evaluateArithmeticExpressionOutput1[0] != True:
					return [False, None]
				else:
					op1 = evaluateArithmeticExpressionOutput1[1]
					
				if op1 == LOGICAL_TEST_RESULT_INDETERMINATE:
					return [True, LOGICAL_TEST_RESULT_INDETERMINATE]
					
				if   inputList[0] == '()':	# Just parenthesized expression
					result = op1
				elif inputList[0] == '~':
					result = ~op1
				elif inputList[0] == '+':
					result = +op1
				elif inputList[0] == '-':
					result = -op1
				elif inputList[0] == "!":
					if op1 == 0:
						result = 1
					else:
						result = 0
				elif op1 == "*":
					errorMessage = "Operator <"+inputList[0]+"> (Dereferencing) not yet supported (coming soon)"
					errorRoutine(errorMessage)
					return [False, None]
				elif op1 == "&":
					errorMessage = "Operator <"+inputList[0]+"> (Referencing) not yet supported (coming soon)"
					errorRoutine(errorMessage)
					return [False, None]
				elif inputList[0] == "++":
					result = op1 + 1
				else:
					errorMessage = "Operation <"+inputList[0]+"> either not supported or coded"
					errorRoutine(errorMessage)
					return [False, None]
					
			elif inputList[1] == "++":	# TO-DO: Not sure if the interpreter needs to do anything here
				evaluateArithmeticExpressionOutput0 = evaluateArithmeticExpression(inputList[0])
				if len(evaluateArithmeticExpressionOutput0) != 2 or evaluateArithmeticExpressionOutput0[0] != True:
					return [False, None]
				else:
					result = evaluateArithmeticExpressionOutput0[1]
					
			elif inputList[0] == "defined":	
				PRINT ("Inside defined()" )
				if isinstance(inputList[1],list):
					if len(inputList[1])==2 and inputList[1][0]=="()":
						symbolToCheckIfDefined = inputList[1][1]
						if symbolToCheckIfDefined in currentMacroNames:
							return [True, True]
						else:
							return [True, False]
					else:	
						errorMessage = "ERROR: Finding defined(%s)"%(STR(symbolToCheckIfDefined))
						errorRoutine(errorMessage)
						return [False, None]
				else:
					errorMessage = "ERROR: Finding defined(%s)"%(STR(symbolToCheckIfDefined))
					errorRoutine(errorMessage)
					return [False, None]
							
			elif inputList[0] == "sizeof":	# TO-DO: Not sure if the interpreter needs to do anything here
				PRINT ("Inside sizeof(), inputList =",inputList)
				if isinstance(inputList[1],list):
					if len(inputList[1])==2 and inputList[1][0]=="()":
						sizeofType = inputList[1][1]
						PRINT ("Inside sizeof() - calling getDatatypeSize(sizeofType=",sizeofType,")" )
						getDatatypeSizeResult = getDatatypeSize(sizeofType)
						if getDatatypeSizeResult == False or getDatatypeSizeResult == None:
							errorMessage = "ERROR: Finding sizeof(%s)"%(STR(sizeofType))
							errorRoutine(errorMessage)
							return [False, None]
						else:
							PRINT ("Inside sizeof() - return value for getDatatypeSize(sizeofType=",sizeofType,") =",getDatatypeSizeResult )
							return [True, getDatatypeSizeResult]
							
				elif checkIfString(inputList[1]):
					getDatatypeSizeResult = getDatatypeSize(inputList[1])
					if getDatatypeSizeResult == False:
						errorMessage = "ERROR: Finding sizeof(%s)"%(STR(inputList[1]))
						errorRoutine(errorMessage)
						return [False, None]
					else:
						return [True, getDatatypeSizeResult]
				else:
					errorMessage = "ERROR: unknown argument for sizeof(%s) - expected a list "%(STR(inputList[1]))
					errorRoutine(errorMessage)
					return [False, None]
			else:
				errorMessage = "Cannot evaluate Unknown 2-member expression:<%s> during %s"%(STR(inputList), executionStage)
				errorRoutine(errorMessage)
				return [False, None]
				
		# 3-member lists
		elif len(inputList) == 3:

			if inputList[1] in ['+','-','*','/','%','<<','>>','|','&','^','<','>','<=','>=','||','&&','==','!=']:
			
				evaluateArithmeticExpressionOutput0 = evaluateArithmeticExpression(inputList[0])
				PRINT("inputList =",inputList,",  evaluateArithmeticExpression(inputList[0]=",STR(inputList[0]),") returns evaluateArithmeticExpressionOutput0 (",STR(evaluateArithmeticExpressionOutput0),")")
				if not isinstance(evaluateArithmeticExpressionOutput0, list):
					errorMessage = "ERROR: evaluateArithmeticExpressionOutput0 (%s) = evaluateArithmeticExpression(inputList[0]=%s) is NOT a list "%(STR(evaluateArithmeticExpressionOutput0),STR(inputList[0]))
					errorRoutine(errorMessage)
					return [False, None]
				elif len(evaluateArithmeticExpressionOutput0) != 2 or evaluateArithmeticExpressionOutput0[0] != True:
					errorMessage = "ERROR: evaluateArithmeticExpression(inputList[0]) = evaluateArithmeticExpression(%s) =%s"%(STR(inputList[0]),STR(evaluateArithmeticExpressionOutput0))
					return [False, None]
					
				evaluateArithmeticExpressionOutput2 = evaluateArithmeticExpression(inputList[2])
				if not isinstance(evaluateArithmeticExpressionOutput2, list):
					errorMessage = "ERROR: evaluateArithmeticExpressionOutput2 (%s) = evaluateArithmeticExpression(inputList[2]=%s) is NOT a list "%(STR(evaluateArithmeticExpressionOutput2),STR(inputList[2]))
					errorRoutine(errorMessage)
					return [False, None]
				elif len(evaluateArithmeticExpressionOutput2) != 2 or evaluateArithmeticExpressionOutput2[0] != True:
					errorMessage = "ERROR: evaluateArithmeticExpressionOutput2 (%s) = evaluateArithmeticExpression(inputList[2]=%s) is NOT a list "%(STR(evaluateArithmeticExpressionOutput2),STR(inputList[2]))
					errorRoutine(errorMessage)
					return [False, None]

				op0 = evaluateArithmeticExpressionOutput0[1]
				op2 = evaluateArithmeticExpressionOutput2[1]
				PRINT("op0 =",op0,"op2 =",op2)
				
				if op0 == LOGICAL_TEST_RESULT_INDETERMINATE or op2 == LOGICAL_TEST_RESULT_INDETERMINATE:
					return [True, LOGICAL_TEST_RESULT_INDETERMINATE]
			
				# Arithmetic operations
				if   inputList[1] == '+':
					result =  op0 + op2
				elif inputList[1] == '-':
					result =  op0 - op2
				elif inputList[1] == '*':
					result =  op0 * op2
				elif inputList[1] == '/':
					if checkIfIntegral(op0) and checkIfIntegral(op2):
						result = integerDivision(op0, op2)
					else:
						result =  op0 / op2
				elif inputList[1] == '%':
					result =  op0 % op2
				elif inputList[1] == '<<':
					result =  op0 << op2
				elif inputList[1] == '>>':
					result =  op0 >> op2
				elif inputList[1] == '|':
					result =  op0 | op2
				elif inputList[1] == '&':
					result =  op0 & op2
				elif inputList[1] == '^':
					result =  op0 ^ op2
					
				# Logical operations
				elif inputList[1] == '<':
					if op0 < op2:
						result = 1
					else:
						result = 0
				elif inputList[1] == '>':
					if op0 > op2:
						result = 1
					else:
						result = 0
				elif inputList[1] == '<=':
					if op0 <= op2:
						result = 1
					else:
						result = 0
				elif inputList[1] == '>=':
					if op0 >= op2:
						result = 1
					else:
						result = 0
				elif inputList[1] == '||':
					if op0 or op2:
						result = 1
					else:
						result = 0
				elif inputList[1] == '&&':
					if op0 and op2:
						result = 1
					else:
						result = 0
				elif inputList[1] == '==':
					if op0 == op2:
						result = 1
					elif isinstance(op0, float) or isinstance(op2, float):
						result = 1 if areFloatsCloseEnough(op0, op2) else 0
#						PRINT("Result = ",result," after calling areFloatsCloseEnough(op0=",op0, ", op2=",op2,")")
					else:
						result = 0
				elif inputList[1] == '!=':
					if op0 == op2:
						result = 0
					elif isinstance(op0, float) or isinstance(op2, float):
						result = 0 if areFloatsCloseEnough(op0, op2) else 1
					else:
						result = 1
				else:
					errorMessage = "Coding error in evaluateArithmeticExpression() while handling the %s operator in <%s> - exiting!"%(STR(inputList[1]),STR(inputList))
					errorRoutine(errorMessage)
					return [False, None]
					
			elif inputList[1] in ['.','->']:
				qualifiedVariable = "".join(flattenList(inputList))
#				qualifiedVariable = outputTextArithmeticExpressionFromAST(inputList[0])+inputList[1]+outputTextArithmeticExpressionFromAST(inputList[2])
				PRINT("For inputList = ",inputList,"qualifiedVariable =",qualifiedVariable)
				evaluateArithmeticExpressionResult = evaluateArithmeticExpression(qualifiedVariable)
				if len(evaluateArithmeticExpressionResult) != 2 or evaluateArithmeticExpressionResult[0] != True:
					errorMessage = "Error in evaluateArithmeticExpression() while evaluating right operand to the dot(.) operator: <%s> during %s"%(STR(inputList), executionStage)
					errorRoutine(errorMessage)
					return [False, None]
				else:
					result = evaluateArithmeticExpressionResult[1]
			elif inputList[0] == 'typecast':
				if isinstance(inputList[1], list) and len(inputList[1]) == 2 and inputList[1][0]== "()" and isinstance(inputList[1][1], list) and inputList[1][1][0]=='datatype' \
					and isinstance(inputList[1][1][1], list) and inputList[1][1][1][-1] in cDataTypes and isinstance(inputList[2], list) and isASTvalid(inputList[2]):
					PRINT("Inside evaluateArithmeticExpression(), for typecast expression, going to evaluate inputList = ",inputList)
					PRINT("But let's first evaluateArithmeticExpression(inputList[2]=",inputList[2],")")
					evaluateArithmeticExpressionResult2 = evaluateArithmeticExpression(inputList[2])
					if evaluateArithmeticExpressionResult2[0]!=True:
						return [evaluateArithmeticExpressionResult2[0], None]
					elif evaluateArithmeticExpressionResult2[1]==LOGICAL_TEST_RESULT_INDETERMINATE:
						return [True, LOGICAL_TEST_RESULT_INDETERMINATE]
					else:
						PRINT("Going to make <",evaluateArithmeticExpressionResult2[1],"> a",inputList[1][1][1])
						if inputList[1][1][1][-1] in ('char', 'short', 'int','long','long long'):
							PRINT("Typecast to integral type")
							sizeInBits = primitiveDatatypeLength[inputList[1][1][1][-1]]*BITS_IN_BYTE
							mask = (1<<sizeInBits)-1
							PRINT("sizeInBits =",sizeInBits,", mask =",hex(mask),",evaluateArithmeticExpressionResult2[1]=",evaluateArithmeticExpressionResult2[1],", int(evaluateArithmeticExpressionResult2[1])=",int(evaluateArithmeticExpressionResult2[1]))
							isNegative = True if evaluateArithmeticExpressionResult2[1] < 0 else False
							# Somehow, if you do "(-1) & 0xFF", Python returns 255.
							result = int(evaluateArithmeticExpressionResult2[1]) & mask
							if isNegative and result >= 0:
								PRINT("Was negative, now positive!!!")
							PRINT("Converted",evaluateArithmeticExpressionResult2[1]," to",result)
							return [True, result]
						elif inputList[1][1][1][-1] in ('float', 'double'):
							result = 1.0 * evaluateArithmeticExpressionResult2[1]
							return [True, result]
						else:
							EXIT("Error in evaluateArithmeticExpression() - not coded yet")
					sys.exit()
			else:
				errorMessage = "Cannot evaluate Unknown 3-member expression:<%s>"%STR(list2plaintext(inputList))
				if inputList[1]=='=':
					errorMessage += ". \n\nAre you sure you did not mean to use \"==\" (comparison) rather than \"=\" (assignment)?"
				errorRoutine(errorMessage)
				return [False, None]
				
		#Ternary operator
		elif len(inputList) == 5: 
			PRINT ("5-item list" )
			
			if inputList[1] == "?" and inputList[3] == ":":
			
				evaluateArithmeticExpressionOutput0 = evaluateArithmeticExpression(inputList[0])
				if len(evaluateArithmeticExpressionOutput0) != 2 or evaluateArithmeticExpressionOutput0[0] != True:
					return [False, None]
					
				evaluateArithmeticExpressionOutput2 = evaluateArithmeticExpression(inputList[2])
				if len(evaluateArithmeticExpressionOutput2) != 2 or evaluateArithmeticExpressionOutput2[0] != True:
					return [False, None]

				evaluateArithmeticExpressionOutput4 = evaluateArithmeticExpression(inputList[4])
				if len(evaluateArithmeticExpressionOutput4) != 2 or evaluateArithmeticExpressionOutput4[0] != True:
					return [False, None]

				if LOGICAL_TEST_RESULT_INDETERMINATE in (evaluateArithmeticExpressionOutput0[1], evaluateArithmeticExpressionOutput2[1], evaluateArithmeticExpressionOutput4[1]):
					return [True, LOGICAL_TEST_RESULT_INDETERMINATE]
				elif evaluateArithmeticExpressionOutput0[1] == True:
					result = evaluateArithmeticExpressionOutput2[1]
				else:
					result = evaluateArithmeticExpressionOutput4[1]
			else:
				PRINT ("Unknown expression of length",len(inputList)," = ",inputList )
				errorMessage = "Cannot evaluate: Unknown expression of length"+STR(len(inputList))," = " + STR(inputList)
				errorRoutine(errorMessage)
				return [False, None]
				
		elif inputList[0] == "function()":
			errorMessage = "Sorry, function call (including sizeof) not supported yet (coming soon)"
			errorRoutine(errorMessage)
			return [False, None]
		
		else:
			errorMessage = "Cannot evaluate: Unknown expression of length"+STR(len(inputList))," = " + STR(inputList)
			errorRoutine(errorMessage)
			return [False, None]
			
		return [True, result]
		
	else:
		PRINT ("inputList = ", inputList )
		PRINT ("ERROR in evaluateArithmeticExpression() - inputList not list or numeric string - exiting" )
		errorMessage = "ERROR in evaluateArithmeticExpression() - cannot evaluate: Unknown expression "+STR(inputList)
		errorRoutine(errorMessage)
		return [False, None]

#inputList = ['c', '==', ['-', '1']]
#inputList = [[['S1', ['[]', ['0']]], ['[]', ['1']]], '.', 'c']
#PRINT_DEBUG_MSG = True
#res = evaluateArithmeticExpression(inputList)
#PRINT(res)
#sys.exit()
#PRINT (evaluateArithmeticExpression(["1","+",[[['-','3'],'^','2'],'*','5']]) )
#inputList = ['var1','.',['var2','.',['var3','.','var4']]]
#evaluateArithmeticExpressionResult = evaluateArithmeticExpression(inputList)
#MUST_PRINT("evaluateArithmeticExpression(",inputList,") =",evaluateArithmeticExpressionResult)
#sys.exit()


#######################################################################################################################################################
#This function takes in two lists. It returns a third list, which is essentially setC = setA - setB
#######################################################################################################################################################
def removeItemsIn2ndListFrom1st (a,b):
	c = a.copy()
	for item in b:
		if item in c:
			c.remove(item)
	return c

#######################################################################################################################################################
#This function takes in two lists. It returns a third list, which is essentially setC = setA intersection setB
#######################################################################################################################################################
def commonItems (list1,list2):
	if not (list1 and list2 and isinstance(list1,list) and isinstance(list2,list) ):
		return []
	common = []
	for item in list1:
		if item in list2:
			common.append(item)
	return common


#######################################################################################################################################################
#This function takes in two lists. It returns a third list, which is essentially setC = setA Union setB
#######################################################################################################################################################
def setUnion (list1,list2):
	list1 = [list1] if checkIfString(list1) else list1
	list2 = [list2] if checkIfString(list2) else list2
	
	if not (isinstance(list1,list) and isinstance(list2,list) ):
		warningMessage ="WARNING: Cannot perform set-like union for list1="+STR(list1)+" and list2="+STR(list2)
		warningRoutine(warningMessage)
		return False
	else:
		unionItemList = []
		unionItemList.extend(list1)
		for item in list2:
			if item not in list1:
				unionItemList.append(item)
		return unionItemList



#######################################################################################################################################################
#This function takes in a list of tokens. It finds the ## operators inside them, and then concatenates the tokens accordingly
#######################################################################################################################################################
def applyDoubleHashOperator(inputList):
	PRINT("inputList =",inputList)
	if inputList == [] or checkIfString(inputList):
		return inputList
	elif isinstance(inputList,list):
		# If it is a list of lists, but contains only a single member, remove one level of listification
		if len(inputList) == 1:
			PRINT ("Returning",inputList[0] )
			return applyDoubleHashOperator (inputList[0])
		else:	
			if isinstance(inputList,list) and len(inputList)==3 and inputList[1]=='##':
				concatenatedToken = applyDoubleHashOperator(inputList[0])+applyDoubleHashOperator(inputList[2])
				PRINT("Returning concatenatedToken = <",concatenatedToken,">")
				return concatenatedToken
			else:
				outputList = []
				i = 0
				while i < len(inputList):
					outputList.append(applyDoubleHashOperator(inputList[i]))
					i = i+1
				PRINT("outputList =",outputList)
				return outputList

#lst1 = ['a','##',['b','##','c']]
#lst2 = applyDoubleHashOperator(lst1)
#MUST_PRINT (lst2 )
#sys.exit()



######################################################################################################################################################################
# This function checks if a given list has starts with a brace, whether the matching brace is also there or not (also checks for the legality of interleaving braces).
# After the matched brace is found, it does not care if there are more items in the list, or the legality of its structure thereafter.
######################################################################################################################################################################
def matchingBraceDistance(inputList):
	global bracesDict, bracesDictReverse
	if inputList[0] not in bracesDict:
		PRINT ("Error: inputList[0] begins with a ",inputList[0],", not a proper brace like (,{,[,<, or ?" )
		return -1000000	# An arbitrary large negative number
		sys.exit()

	# Check if the incoming token stream has the different kind of braces legally interleaved or not
	# For example, ((a+b[c])) is fine. ((a+b[c)]) is NOT fine, even though they have the matching count of parenthesis. 
	onlyBraces = []
	i=0
	# There is a problem with the < > braces, since "<" and ">" are also valid operators, which means there might be an mismatching number of them
	# So, we count them only when the inputList[0] is a "<". Same with : and ?
	while i < len(inputList):
		if inputList[i] in bracesDict:
			if (inputList[i]!="<" and inputList[i]!="?") or (inputList[i]=="<" and inputList[0]=="<") or (inputList[i]=="?" and inputList[0]=="?"):
				onlyBraces.append(inputList[i])
		elif inputList[i] in bracesDictReverse:
			if (inputList[i]!=">" and inputList[i]!=":") or (inputList[i]==">" and inputList[0]=="<") or (inputList[i]==":" and inputList[0]=="?"):
				if onlyBraces[-1] == bracesDictReverse[inputList[i]]:
					del onlyBraces[-1]
				else:
					errorMessage = "ERROR in matchingBraceDistance(): Illegal brace \"" + STR(inputList[i]) + "\" found in inputList["+ STR(i) + "], expected a \"" + STR(bracesDict[onlyBraces[-1]]) +"\"" 
					errorRoutine(errorMessage)
					return -1000000	# An arbitrary large negative number
					sys.exit()
		# This assumes that onlyBraces gets populated with the i=0, and the moment it is getting emptied, that means we have found a matching end-parenthesis
		if not onlyBraces:
			return i
		i=i+1
		
	if onlyBraces:
		PRINT ("onlyBraces = ",onlyBraces, "len(onlyBraces) = ",len(onlyBraces) )
		PRINT ("Incomplete input - still expecting a ", bracesDict[onlyBraces[-1]] )
		return -1000000		# An arbitrary large negative number



######################################################################################################################################################################
# This function checks if a given list has ends with a brace, whether the matching brace is also there or not (also checks for the legality of interleaving braces).
# After the matched brace is found, it does not care if there are more items in the list, or the legality of its structure therebefore.
######################################################################################################################################################################
def matchingBraceDistanceReverse(inputList):
	global bracesDict, bracesDictReverse
	if inputList[-1] not in bracesDictReverse:
		PRINT ("Error: inputList[-1] ends with a ",inputList[-1],", not a proper brace like ),},],>, or :" )
		return -100000 	# An arbitrary large negative number
		sys.exit()

	# Check if the incoming token stream has the different kind of braces legally interleaved or not
	# For example, ((a+b[c])) is fine. ((a+b[c)]) is NOT fine, even though they have the matching count of parenthesis. 
	onlyBraces = []
	i=len(inputList)-1
	# There is a problem with the < > braces, since "<" and ">" are also valid operators, which means there might be an mismatching number of them
	# So, we count them only when the inputList[0] is a "<"
	while i >= 0:
		if inputList[i] in bracesDictReverse:
			if inputList[i]!=">" or (inputList[i]==">" and inputList[-1]==">"):
				onlyBraces.append(inputList[i])
		elif inputList[i] in bracesDict:
			if inputList[i]!="<" or (inputList[i]=="<" and inputList[-1]==">"):
				if onlyBraces[-1] == bracesDict[inputList[i]]:
					del onlyBraces[-1]
				else:
					errorMessage = "ERROR in matchingBraceDistanceReverse(): Illegal brace \"" + STR(inputList[i]) + "\" found in inputList["+ STR(i) + "], expected a \"" + STR(bracesDictReverse[onlyBraces[-1]]) +"\"" 
					errorRoutine(errorMessage)
					PRINT ("Error: Illegal brace ",inputList[i], " found in inputList[",i,"], expected a ",bracesDictReverse[onlyBraces[-1]] )
					return -100000 	# An arbitrary large negative number
					sys.exit()
		# This assumes that onlyBraces gets populated with the i=len(inputList)-1, and the moment it is getting emptied, that means we have found a matching end-parenthesis
		if not onlyBraces:
			return len(inputList)-i-1
		i = i - 1
		
	if onlyBraces:
		PRINT ("onlyBraces = ",onlyBraces, "len(onlyBraces) = ",len(onlyBraces) )
		PRINT ("Incomplete input - still expecting a ", bracesDictReverse[onlyBraces[-1]] )
		return -1000000		# An arbitrary large negative number

#list1 = ['a','(','a','+','b','[','c',']',')','b','{','}']
#list2 = ["(","a","(","b","[","+",'(',')',"c","]","-","[","]","e",")",")"]
#list3 = ['(','a','+','b','[','c',')',']']
#list1 = ['(','a',')','b']
#PRINT (matchingBraceDistanceReverse(list2[:10]) )
#sys.exit()


####################################################################################################################################################
# This function takes in a list of tokens (not necessarily an AST) that contains some braces, and it checks the legality of the brace interleaving.
# For example, ((a+b[c])) is fine. ((a+b[c)]) is NOT fine, even though they have the matching count of parenthesis. 
# We are deliberately not including the third braces here, as that might be used as part of Logical operation.
#####################################################################################################################################################
def braceInterleavingLegal(inputList,omitColons = True):
#	PRINT ("Checking <",inputList,"> for brace interleaving legality" )
	global bracesDict, bracesDictReverse
	onlyBraces = []
	i=0
	while i < len(inputList):
		# Since 
		if inputList[i] == "<" or inputList[i] == ">":
			pass
		# Unless there exists the '?', we don't check for the ':'. This is because colons will always be unmatched in a bitfield declaration.
		# The only case where this will create problem is where we have multi-variable declarations like int a:4, b[2+3>3?
		elif (omitColons == True) and (inputList[i] == "?" or inputList[i] == ":"):	
			pass
		elif inputList[i] in bracesDict:
			onlyBraces.append(inputList[i])
		elif inputList[i] in bracesDictReverse:
			if onlyBraces and (onlyBraces[-1] == bracesDictReverse[inputList[i]]):
				del onlyBraces[-1]
			else:
				PRINT ("i =",i,", onlyBraces =",onlyBraces )
				if onlyBraces:
					errorMessage = "ERROR in braceInterleavingLegal(): Illegal brace " + STR(inputList[i]) + " found in inputList[" + STR(i) + "], expected a " + STR(bracesDict[onlyBraces[-1]] )
				else:
					errorMessage = "ERROR in braceInterleavingLegal(): Illegal brace " + STR(inputList[i]) + " found in inputList[" + STR(i) + "], no previous occurence of " + STR(bracesDictReverse[inputList[i]] )
				errorRoutine(errorMessage)
				return False
		i = i + 1
	if onlyBraces:
		return False
	else:
		return True
		
#list1 = ['a','(','a','+','b','[','c',']',')','b','{','}']
#list2 = ['(','a','+','b','[','c',')',']']
#PRINT (braceInterleavingLegal(list1) )
#PRINT (braceInterleavingLegal(list2) )
#sys.exit()
#####################################################################################################################################
# findSubsequenceInList(subsequence, tokenList)
# This routine finds if the first list exists as a subsequence of the second list. If it does, it sends the first occurrence of that.
# And the result is a list of the indices (not necessarily contiguous) of the tokenList that correspond to the subsequence.
# For example, the [c,f,g] subsequence exists in a list [a,b,c,d,e,f,g,h,i]. This routine will return [2,5,6].
######################################################################################################################################

def findSubsequenceInList(subsequence, tokenList):
	PRINT("Looking for susquence =",subsequence,"in tokenList =",tokenList)
	if not isinstance(subsequence,list):
		errorMessage = "input subsequence "+STR(subsequence)+" is not a list"
		errorRoutine(errorMessage)
		return False
	if not isinstance(tokenList,list):
		errorMessage = "input tokenList "+STR(tokenList)+" is not a list"
		errorRoutine(errorMessage)
		return False
	
	if len(subsequence) == 0:
		return []
	elif len(subsequence) > len(tokenList):
		return []
	elif len(subsequence) == len(tokenList) and subsequence != tokenList:
		return []
	elif subsequence[0] not in tokenList:
		return []
	elif len(subsequence)==1:
		return [tokenList.index(subsequence[0])]
	else:
		foundAtIndex = -1
		while subsequence[0] in tokenList[foundAtIndex+1:]:
			foundAtIndex = foundAtIndex+1 + tokenList[foundAtIndex+1:].index(subsequence[0])
			PRINT("Found occurrence of ",subsequence[0],"at position",foundAtIndex,"of ",tokenList)
			tempList = []
			result = findSubsequenceInList(subsequence[1:], tokenList[foundAtIndex+1:])
			PRINT("findSubsequenceInList(",STR(subsequence[1:]),",", STR(tokenList[foundAtIndex+1:]),") =",STR(result))
			if result!=False and result != []:
				if len(result) != len(subsequence)-1:
					OUTPUT("Coding error in findSubsequenceInList(), result is ",result,"while subsequence =",subsequence)
					sys.exit()
				tempList = [foundAtIndex]
				for item in result:
					tempList.append(item+foundAtIndex+1)
				break
		# Verify that the result is correct
		if tempList != []:
			if len(tempList) != len(subsequence):
				OUTPUT("Coding error in findSubsequenceInList(), result is ",tempList,"while subsequence =",subsequence,"and they are of different length")
				sys.exit()
			else:
				for i in range(len(tempList)):
					if subsequence[i] != tokenList[tempList[i]]:
						OUTPUT("Coding error in findSubsequenceInList(), result[",i,"] = ",tempList[i],"but tokenList[",tempList[i],"] =",tokenList[tempList[i]],"doesn't match with subsequence[",i,"] =",subsequence[i])
						sys.exit()
		return tempList

####################################################################################################################################################
# Inside unraveled, the parentage of every variable is properly qualified - there is no anonymous structure name or dummy variable.
# That means, even if the code has anonymous struct declarations and dummy struct variables, inside unraveled there is going to 
# SOME struct name (that begins with anonymousStructPrefix, like "Anonymous#") and SOME variable name (that begins with dummyVariableNamePrefix,
# like "dummyUnnamedBitfieldVar#"). While a coder is going to know what are these prefixes going to be, he/she cannot know apriori the exact
# name, like if it is going to be Anonymous#0 or Anonymous#1, etc. Hence, a #RUNTIME statement cannot possibly have a fully qualified
# if condition like 

# #RUNTIME #if Anonymous#0.t1[0].DummyVar#1.salary[6].dummyUnnamedBitfieldVar#0 == somevalue
#
# Instead, it will have something like
#
# #RUNTIME #if t1[0].salary[6] == somevalue
# 
# Our job is to eliminate the anonymousStructPrefix/dummyVariableNamePrefix etc. stuff from the unraveled variable name and then compare the two.
# If the supplied fullMatchRequiredNotJustSuffix is True, we need a full match. Or else, if the findThisString is a suffix of inThisString, it will succeed.
#####################################################################################################################################################
def checkIfSameUnraveledVariable (findThisString, inThisString, fullMatchRequiredNotJustSuffix = True):
	if not (checkIfString(findThisString) and checkIfString(inThisString)):
		errorMessage = "Error in checkIfSameUnraveledVariable(): Passed inputs are not proper strings. type(findThisString) = "+type(findThisString)+", findThisString ="+STR(findThisString)+", type(inThisString) = "+type(inThisString)+", inThisString ="+inThisString
		errorRoutine(errorMessage)
		return False
	
	t1 = re.split('[\.\[\]]+',findThisString)		# Basically, we treat the dot operator and the array([]) operator as the variable delimiters
	t1 = [x for x in t1 if x != "" and anonymousStructPrefix not in x and dummyVariableNamePrefix not in x and dummyUnnamedBitfieldNamePrefix not in x]
	PRINT("findThisString = <"+findThisString+"> has been tokenized into",t1)
	t2 = re.split('[.\[\]]+',inThisString)
	t2 = [x for x in t2 if x != "" and anonymousStructPrefix not in x and dummyVariableNamePrefix not in x and dummyUnnamedBitfieldNamePrefix not in x]
	PRINT("inThisString = <"+inThisString+"> has been tokenized into",t2)
	if (fullMatchRequiredNotJustSuffix and t1==t2) or (not fullMatchRequiredNotJustSuffix and t1==t2[-len(t1):]):
		PRINT("findThisString = <"+findThisString+"> has been found in <"+inThisString+">")
		return True
	else:
		PRINT("findThisString = <"+findThisString+"> has NOT been found in <"+inThisString+">")
		return False

#findThisString = "t1[0].salary[6][0]"
#inThisString = "Anonymous#0.t1[0].DummyVar#1.salary[6].dummyUnnamedBitfieldVar#0"
#PRINT (checkIfSameUnraveledVariable (findThisString, inThisString)):
#sys.exit()


###########################################################################################################################################
# Checks if the tokenlist contains a function definition (NOT declaration) of the form:    funcname([arguments]){[statements]}
###########################################################################################################################################
def checkIfFunctionDefinition(tokenList):
	PRINT("Checking for function signature in tokenList =",STR(tokenList))
	if not isinstance(tokenList,list):
		return [False, None]
	
	# Kludge - I have implemented the '()' operator also, so 
	functionDefinitionSignature1 = ['(',')','{','}']
	functionDefinitionSignature2 = ['()','{','}']
	functionDefinitionSignature = [functionDefinitionSignature1, functionDefinitionSignature2]
	functionCheckResult = False
	functionDefinitionEndIndex = LARGE_NEGATIVE_NUMBER

	result = findSubsequenceInList(functionDefinitionSignature1, tokenList)
	if result != False and result != []:
		if result[1] != result[2]-1:	# The { must come right after the closing )
			PRINT("The } did not come right before the { - hence no function")
		else:
			# check if the () braces match
			d1 = matchingBraceDistance(tokenList[result[0]:])
			d2 = matchingBraceDistance(tokenList[result[2]:])
			if d1 < 0:
				PRINT("No matching ) for ( - hence no function")
			elif result[0] + d1 != result[1]:
				PRINT("There exists a } but that doesn't match with the ( - hence no function")
			
			# check if the {} braces match
			elif d2 < 0:
				PRINT("No matching } for { - hence no function")
			elif result[2] + d2 != result[3]:
				PRINT("There exists a } but that doesn't match with the { - hence no function")
				
			# Check if the token right before the ( is not a keyword
			elif result[0] == 0 or tokenList[result[0]-1] in illegalVariableNames:
				PRINT("The token before the ( } is not a proper variable name - hence no function")
			
			else:
				functionCheckResult = True
				functionDefinitionEndIndex = result[3]

	if functionCheckResult == False:
		result = findSubsequenceInList(functionDefinitionSignature2, tokenList)
		if result != False and result != []:
			# check if the () braces match
			d2 = matchingBraceDistance(tokenList[result[1]:])
			
			# check if the {} braces match
			if d2 < 0:
				PRINT("No matching } for { - hence no function")
			elif result[1] + d2 != result[2]:
				PRINT("There exists a } but that doesn't match with the { - hence no function")
				
			# Check if the token right before the ( is not a keyword
			elif result[0] == 0 or tokenList[result[0]-1] in illegalVariableNames:
				PRINT("The token before the ( } is not a proper variable name - hence no function")
			else:
				functionCheckResult = True
				functionDefinitionEndIndex = result[2]

	PRINT("functionCheckResult =",functionCheckResult,"for tokenList =",STR(tokenList))

	#Sanity check
	if functionCheckResult == True: 
		if tokenList[functionDefinitionEndIndex] != '}':
			OUTPUT("Coding error in checkIfFunctionDefinition() - exiting")
			sys.exit()
		else:
			return [True, functionDefinitionEndIndex]
	else:
		return [False, None]

####################################################################################################################################################
# This function takes in a list of tokens which represent the parenthesized (1st or 2nd) comma-separated list of arguments, 
# and returns a list of the arguments. In the returned list of list, each list is an argument, which itself is a list of tokens
# Thus, parseArgumentList(["(","a",",","(","b",",","c",")",")"]) will yield [['a'], ['(', 'b', ',', 'c', ')']]
#####################################################################################################################################################
def parseArgumentList(inputList, omitColons=False):
	if not (len(inputList)>=2 and ((inputList[0] =='(' and inputList[-1]==')') or (inputList[0] =='{' and inputList[-1]=='}'))):
		PRINT ("Invalid argument list - must be properly parenthesized",inputList )
		return False
		sys.exit()
	# Check if the incoming token stream has the different kind of braces legally interleaved or not
	# For example, ((a+b[c])) is fine. ((a+b[c)]) is NOT fine, even though they have the matching count of parenthesis. 
	argumentList = []
	onlyBraces = []
	if len(inputList)==2:
		return argumentList
	
	# Here we assume that we have at least one argument
	# To-DO : Strip away the spaces, unless it is all spaces
	argStartIndex = 1
	i=0
	while i < len(inputList):
		if omitColons and inputList[i] in ('?',':'):
			pass
		elif inputList[i] in bracesDict:
			onlyBraces.append(inputList[i])
		elif inputList[i] in bracesDictReverse:
			#Special case for ending parenthesis
			if i==len(inputList)-1 and inputList[i] in (')','}'):
				if argStartIndex==i-1: # If it is a single member, no point making it a list
					argumentList.append(inputList[argStartIndex])
				else:
					argumentList.append(inputList[argStartIndex:i])
			elif onlyBraces[-1] == bracesDictReverse[inputList[i]]:
				del onlyBraces[-1]
			else:
				errorMessage = "ERROR in parseArgumentList("+STR(inputList)+"): Illegal brace \"" + STR(inputList[i]) + "\" found in inputList[" +STR(i) + "], expected a \"" + STR(bracesDict[onlyBraces[-1]])+ "\""
				errorRoutine(errorMessage)
				return False
				sys.exit()
		elif len(onlyBraces)==1 and onlyBraces[-1] in ('(','{') and (inputList[i] == ',' or i==len(inputList)-1):
			if argStartIndex==i-1: # If it is a single member, no point making it a list
				argumentList.append(inputList[argStartIndex])
			else:
				argumentList.append(inputList[argStartIndex:i])
			argStartIndex = i+1
		i=i+1
	PRINT("The argument lists =\n",argumentList,"\n\n")
	for item in argumentList:
		PRINT(list2plaintext(item))
	return argumentList

#PRINT (parseArgumentList(["(","a",",","(","b",",","c",")",")"]) )
	
#MUST_PRINT (parseArgumentList(["(","min","(","b",",","c",")",",","[","d","]","e",")"]) )
#MUST_PRINT (parseArgumentList(["(","min","(","b",",","c",")",",","[","d","]","e",")"]) )
#MUST_PRINT (parseArgumentList(["{","0",",","{","0",",","c","}",",","0",",","e","}"]) )
#sys.exit()	


#######################################################################################################################################################################
# This recursive function takes three arguments.: 1) One input list, 2) list item to be replaced (which is A) 3) the new list item that it will replace it (which is B)
########################################################################################################################################################################
def replaceToken (inputList, A, B):
	if isinstance(inputList, list):
		inputListCopy = []
		for item in inputList:
#			PRINT ("Before traversal, item = <",item,">" )
			inputListCopy.append(replaceToken (item, A, B))
#			PRINT ("After traversal, item = <",item,">" )
		return inputListCopy
	else:
		if inputList == A:
#			PRINT ("Before replacement, inputList = <",inputList,">" )
			inputList = B
#			PRINT ("After replacement, inputList = <",inputList,">" )
		return inputList

##########################################################################################################################################################
# This function takes three arguments.: 1) One input list, 2) A dictionary <key,value> pairs so that 
# all the <key_i> values should be replaced with the corresponding <value_i> values. We implement the dictionary using list since dictionary is un
# We cannot do this just by replacing the tokens. Because then suppose the dictionary contains two key-value pairs: <a,b> and <b,c>
# which means replace all a's with b's, and replace all b's with c's. So, we would expect an expression of a+b to be transformed to b+c.
# Unfortunately, if we do this by first doing a-->b replacement, we will get (a+b)-->(b+b). Now if we do the b-->c replacement, we will get (c+c).
# To avoid this problem, we must design the problem the following way: Make sure that the key set and value set never intersect.
# To achieve this without having to look at all possible invocations of a macro, we should first change the macro arguments to somethings
# that the macro invocations would never use. This is the first step. Once this first step is complete, we can do the second step of replacing the
# never-used-in-invocations-variables to actual-invocation-variable-argument-variables.
##########################################################################################################################################################
# The output is a 2-member tuple. The first member tells if this the return value is True or False. If True, only then one should pay attention to the 2nd member, the result.
# The reason we do this convoluted way is beacuse we are worried that a simple return value of False might be construed as a valid return result.
##########################################################################################################################################################

def replaceArguments (inputList, dictionary):
	if isinstance(dictionary,dict):
		newDict = OrderedDict()
		newDict1stHalf = OrderedDict()
		newDict2ndHalf = OrderedDict()
		
		# Choose a very arbitrary prefix that will NEVER be an actual variable name. If it still appears in one of <value>s, keep changing it until it doesn't
		prefix = "______Z___Ta_9UYTadfg_____"
		while (True):
			prefixAppearsInValues = False
			for key,value in dictionary.items():
				outputTextArithmeticExpressionFromASTOutput = outputTextArithmeticExpressionFromAST(value)
				if outputTextArithmeticExpressionFromASTOutput == False:
					PRINT ("ERROR in replaceArguments after calling outputTextArithmeticExpressionFromAST(value) for value =", value )
					return [False,None]
				if outputTextArithmeticExpressionFromASTOutput.find(prefix) >= 0:
					PRINT ("prefix", prefix, "found in value <",value,">" )
					prefixAppearsInValues = True
					break
			if prefixAppearsInValues == True:
				prefix = "_" + prefix  + "_"
			else:
				break
		PRINT ("prefix = <",prefix,">" )
		
		for key,value in dictionary.items():
			# Check that the key values are never a list. Otherwise we cannot really assign the prefix to a list
			if not checkIfString(key):
				PRINT ("Error: Inside Macro arguments definitions, arguments must be a single string variable, where it is now <",key,">" )
				return [False, None]
				sys.exit()
			else:
				newDict1stHalf[key] = prefix+key
				newDict2ndHalf[prefix+key] = value

		# It's important that we do it this way. Otherwise, we will still have the intended problem we are doing to solve
		for key, value in newDict1stHalf.items():
			newDict[key]=value
		for key, value in newDict2ndHalf.items():
			newDict[key]=value
		PRINT (newDict )
		
		for key,value in newDict.items():
			inputList = replaceToken (inputList, key, value)
	return [True, inputList]

###################################################################################
# Convert Multi-Line Strings into Single-Line Strings	
###################################################################################
def convertMultiLineStringsIntoSingleLineStrings(inputLines):
	if not inputLines:
		return []
	
	# Check that inputLines is a list of lines (strings ending with a newline). If it is a single string, make it a list
	if  isinstance(inputLines,list):
#		PRINT ("inputLines is indeed a list" )
		itemCount = 0
		while itemCount < len(inputLines):
			if not checkIfString(inputLines[itemCount]):
				PRINT ("Exiting - inputLines is not a list of proper strings - ", inputLines )
				return False
				sys.exit()
			elif not inputLines[itemCount] or inputLines[itemCount][-1] != '\n':
#				PRINT ("Appending newline to the end of inputLines[",itemCount,"]" )
				inputLines[itemCount] = inputLines[itemCount] + '\n'
			itemCount = itemCount + 1
		PRINT ("inputLines is indeed a list of proper strings - ", inputLines )
	else:
#		PRINT ("inputLines is NOT a list" )
		if checkIfString(inputLines):
#			PRINT (("Checking if inputLines=<%s> has a newline at the end"%(inputLines)) )
			if inputLines[-1] != '\n':
#				PRINT ("Appending newline to the end of inputLines" )
				inputLines = inputLines + '\n'
#			PRINT ("Converting the inputLines <",inputLines,">, which is a basic string but not a list, into a list" )
			inputLines = [inputLines]
#			PRINT ("Now the listified inputLines = ",inputLines )
		else:
			PRINT ("Exiting - Unknown object type - inputLines = <",inputLines,">" )
			return False
			sys.exit()
	
	outputLines = inputLines
	
	continuingString = False
	stringStartLineNum = LARGE_NEGATIVE_NUMBER
	stringStartCharNum = LARGE_NEGATIVE_NUMBER
	stringEndLineNum   = LARGE_NEGATIVE_NUMBER
	stringEndCharNumInclusive   = LARGE_NEGATIVE_NUMBER
	
	lineNum = 0
	while True:
		if lineNum>=len(inputLines):
			break
		else: 
			PRINT("Processing line #",lineNum," = ",inputLines[lineNum])
			pass
		line = inputLines[lineNum]
		for i in range(len(line)):
			if line[i] == '"':
				if continuingString:
					if i>0 and line[i-1]=="\\":
						pass
					else: #End of string
						stringEndLineNum   = lineNum
						stringEndCharNumInclusive   = i
						
						if stringEndLineNum == stringStartLineNum:	# String starts and ends on the same line; do nothing
							pass
						elif stringEndLineNum < stringStartLineNum: # Error
							errorMessage = "ERROR in convertMultiLineStringsIntoSingleLineStrings: stringEndLineNum (%d) < stringStartLineNum (%d)"%(stringEndLineNum, stringStartLineNum)
							errorRoutine(errorMessage)
							return False
						elif stringEndLineNum > stringStartLineNum: # 
							#Convert the outputlines
							for j in range(len(outputLines)):
								if outputLines[j][-1] != "\n":
									OUTPUT("Line",j, "does not end with newline - exiting")
									sys.exit()
								if j < stringStartLineNum or j > stringEndLineNum:
									pass
								elif j == stringStartLineNum:
									outputLines[stringStartLineNum] = outputLines[stringStartLineNum][:-1] + "\\n"
								elif stringStartLineNum < j < stringEndLineNum:
									outputLines[stringStartLineNum] += outputLines[j]
									outputLines[stringStartLineNum]= outputLines[stringStartLineNum][:-1]+"\\n"
									outputLines[j] = "\n"
								elif j == stringEndLineNum:
									outputLines[stringStartLineNum] += outputLines[j][:stringEndCharNumInclusive+1]
									outputLines[stringStartLineNum] += "\\n"
									outputLines[stringEndLineNum] = " "*(stringEndCharNumInclusive+1) + inputLines[stringEndLineNum][stringEndCharNumInclusive+1:]
								else:
									OUTPUT("Coding bug")
									sys.exit()
									
						else:
							OUTPUT("Coding bug")
							sys.exit()
						
						# Reset these values						
						stringStartLineNum = LARGE_NEGATIVE_NUMBER
						stringStartCharNum = LARGE_NEGATIVE_NUMBER
						stringEndLineNum   = LARGE_NEGATIVE_NUMBER
						stringEndCharNumInclusive   = LARGE_NEGATIVE_NUMBER
						
				else:	# Start of string
						stringStartLineNum   = lineNum
						stringStartCharNum   = i
						continuingString = True
	
		lineNum += 1
		
	return 	outputLines

#inputLines = ['x = "Hi \n', ' there, \n', 'my friend!"; int y;\n']
#outputLines = convertMultiLineStringsIntoSingleLineStrings(inputLines)
#PRINT("inputLines =",inputLines)
#MUST_PRINT("outputLines =",outputLines)
#sys.exit()

###################################################################################
# Convert Single-Line Strings into Multi-Line Strings	
###################################################################################
def convertSingleLineStringsIntoMultiLineStrings(inputLines):
	if not inputLines:
		return []
	
	# Check that inputLines is a list of lines (strings ending with a newline). If it is a single string, make it a list
	if  isinstance(inputLines,list):
#		PRINT ("inputLines is indeed a list" )
		itemCount = 0
		while itemCount < len(inputLines):
			if not checkIfString(inputLines[itemCount]):
				PRINT ("Exiting - inputLines is not a list of proper strings - ", inputLines )
				return False
				sys.exit()
			elif not inputLines[itemCount] or inputLines[itemCount][-1] != '\n':
#				PRINT ("Appending newline to the end of inputLines[",itemCount,"]" )
				inputLines[itemCount] = inputLines[itemCount] + '\n'
			itemCount = itemCount + 1
		PRINT ("inputLines is indeed a list of proper strings - ", inputLines )
	else:
#		PRINT ("inputLines is NOT a list" )
		if checkIfString(inputLines):
#			PRINT (("Checking if inputLines=<%s> has a newline at the end"%(inputLines)) )
			if inputLines[-1] != '\n':
#				PRINT ("Appending newline to the end of inputLines" )
				inputLines = inputLines + '\n'
#			PRINT ("Converting the inputLines <",inputLines,">, which is a basic string but not a list, into a list" )
			inputLines = [inputLines]
#			PRINT ("Now the listified inputLines = ",inputLines )
		else:
			OUTPUT ("Exiting - Unknown object type - inputLines = <",inputLines,">" )
			return False
			sys.exit()

	outputLines = inputLines
	
	continuingString = False
	stringStartLineNum = LARGE_NEGATIVE_NUMBER
	stringStartCharNum = LARGE_NEGATIVE_NUMBER
	stringEndLineNum   = LARGE_NEGATIVE_NUMBER
	stringEndCharNumInclusive   = LARGE_NEGATIVE_NUMBER
	
	lineNum = 0
	while True:
		if lineNum>=len(inputLines):
			break
		else: 
			PRINT("Processing line #",lineNum," = ",inputLines[lineNum])
			pass
		line = inputLines[lineNum]
		for i in range(len(line)):
			if line[i] == '"':
				if continuingString:
					if i>0 and line[i-1]=="\\":
						pass
					else: #End of string
						stringEndLineNum   = lineNum
						stringEndCharNumInclusive   = i
						
						if stringEndLineNum != stringStartLineNum:	# String does not start and end on the same line; error
							errorMessage = "ERROR in convertSingleLineStringsIntoMultiLineStrings: stringEndLineNum (%d) != stringStartLineNum (%d)"%(stringEndLineNum, stringStartLineNum)
							errorRoutine(errorMessage)
							return False
						elif "\\n" not in line[stringStartCharNumInclusive:stringEndCharNumInclusive+1]: # simple string, do nothing
							pass
						else:
							stringToSplit = line[stringStartCharNumInclusive:stringEndCharNumInclusive+1]
							splitString = stringToSplit.split("\\n")
							if len(splitString) <= 1:
								errorMessage = "ERROR in convertSingleLineStringsIntoMultiLineStrings: expecting at least one newline in string <%s>"%stringToSplit
								errorRoutine(errorMessage)
								return False
								
							#Convert the outputlines (TBD - not done)
							for j in range(len(outputLines)):
								if outputLines[j][-1] != "\n":
									OUTPUT("Line",j, "does not end with newline - exiting")
									sys.exit()
								if j < stringStartLineNum or j > stringEndLineNum:
									pass
								elif j == stringStartLineNum:
									outputLines[stringStartLineNum] = outputLines[stringStartLineNum][:-1] + "\\n"
								elif stringStartLineNum < j < stringEndLineNum:
									outputLines[stringStartLineNum] += outputLines[j]
									outputLines[stringStartLineNum]= outputLines[stringStartLineNum][:-1]+"\\n"
									outputLines[j] = "\n"
								elif j == stringEndLineNum:
									outputLines[stringStartLineNum] += outputLines[j][:stringEndCharNumInclusive+1]
									outputLines[stringStartLineNum] += "\\n"
									outputLines[stringEndLineNum] = " "*(stringEndCharNumInclusive+1) + inputLines[stringEndLineNum][stringEndCharNumInclusive+1:]
								else:
									OUTPUT("Coding bug")
									sys.exit()
									
					
						# Reset these values						
						stringStartLineNum = LARGE_NEGATIVE_NUMBER
						stringStartCharNum = LARGE_NEGATIVE_NUMBER
						stringEndLineNum   = LARGE_NEGATIVE_NUMBER
						stringEndCharNumInclusive   = LARGE_NEGATIVE_NUMBER
						
				else:	# Start of string
						stringStartLineNum   = lineNum
						stringStartCharNum   = i
						continuingString = True
	
		lineNum += 1
		
	return 	outputLines


######################################################################################	
# TO-DO: How to handle newlines (our program is not consistent on this)
#
# When this is called, we have already called preProcess(), which has removed comments and converted multiline macros into single line.
#
# It outputs a list of the following things: 
#
# 1) A simple list of string tokens (only this thing is being used now)
# 2) List of tokens, but for each token, we include yet another list of all the occurrences. Mostly used for multi-line tokens.
# 3) A linewise list of tokens with lots of informations (like from which line and char they start and end, whether the tokens are starting/ending
######################################################################################	

def tokenizeLines(lines):
	global funcName
	funcName = "tokenizeLines"
#	global preprocessingDirectives, runtimeDirectives, twoCharOperatorList, threeCharOperatorList
	tokenList = []	# A simple list of string tokens (only this thing is being used now)
	tokenListInfo = []	# List of tokens, but for each token, we include yet another list of all the occurrences. Mostly used for multi-line tokens.
	linewiseTokenInfo = []	# tells for every line, [token, overall token#, starting line#, starting char#, ending line#, ending char# (inclusive), whethere the token starts/ends on this line]
	currentToken = ""
	lineNumber = -1
	continuingMacro = False

	if not lines:
		return [[],[],[]]
	
	# Check that lines is a list of Lines (strings ending with a newline). If it is a single string, make it a list
	if  isinstance(lines,list):
#		PRINT ("lines is indeed a list" )
		itemCount = 0
		while itemCount < len(lines):
			if not checkIfString(lines[itemCount]):
				PRINT ("Exiting - lines is not a list of proper strings - ", lines )
				return False
				sys.exit()
			elif not lines[itemCount] or lines[itemCount][-1] != '\n':
#				PRINT ("Appending newline to the end of lines[",itemCount,"]" )
				lines[itemCount] = lines[itemCount] + '\n'
			itemCount = itemCount + 1
#		PRINT ("lines is indeed a list of proper strings - ", lines )
	else:
#		PRINT ("lines is NOT a list" )
		if checkIfString(lines):
#			PRINT (("Checking if lines=<%s> has a newline at the end"%(lines)) )
			if lines[-1] != '\n':
#				PRINT ("Appending newline to the end of lines" )
				lines = lines + '\n'
#			PRINT ("Converting the lines <",lines,">, which is a basic string but not a list, into a list" )
			lines = [lines]
#			PRINT ("Now the listified lines = ",lines )
		else:
			PRINT ("Exiting - Unknown object type - lines = <",lines,">" )
			return False
			sys.exit()
	
	tokenIndex = 0		# Total token count = 1 + max(tokenIndex). This is NOT just within a single line, it is for ALL the lines overall
	
	currentTokenStartLineNum = LARGE_NEGATIVE_NUMBER
	currentTokenStartCharNum = LARGE_NEGATIVE_NUMBER
	currentTokenEndLineNum = LARGE_NEGATIVE_NUMBER
	currentTokenEndCharNumInclusive = LARGE_NEGATIVE_NUMBER
		
	
	for line in lines:
	
		lineNumber += 1
		currentLinetokenList = []
		currentLineTokenListInfo = []		# each item is a list of <currentToken, currentTokenStartCharNum, currentTokenEndCharNumInclusive>
		i = 0
		continuingString = False	# In Standard C, a string is demarcated by a double-quote
		continuingChar = False	# In Standard C, a char is demarcated by a single-quote
		currentLineIsPreProcessorDirective = False
		currentLineIsRuntimeDirective = False
		
		while i < len(line):	# Process all the chars within this current line
			c = line[i]
			if c:
				if continuingString == True and continuingChar == True:
					errorMessage = "We cannot have conntinuation of both single-quoted and double-quoted string"
					errorRoutine(errorMessage)
					return False
				elif continuingString == True or continuingChar == True:
					currentToken += c
					# Ending a string liternal token
					if c in ('"','\'') and currentToken[-2]!="\\":	# TO-DO should not it be -2 instead of -1, since we already added the double-quote char?
						if c == '"':
							continuingString = False
						if c == '\'':
							continuingChar = False
							
						currentLinetokenList.append(currentToken)
						currentTokenEndLineNum = lineNumber
						currentTokenEndCharNumInclusive = i
						currentLineTokenListInfo.append([currentToken, tokenIndex, currentTokenStartLineNum, currentTokenStartCharNum, currentTokenEndLineNum, currentTokenEndCharNumInclusive])
						currentTokenStartLineNum = LARGE_NEGATIVE_NUMBER
						currentTokenStartCharNum = LARGE_NEGATIVE_NUMBER
						currentTokenEndLineNum = LARGE_NEGATIVE_NUMBER
						currentTokenEndCharNumInclusive = LARGE_NEGATIVE_NUMBER
						currentToken = ""
						tokenIndex += 1
				elif c in ('"','\''):		# The assumption is that the string liternal starts here
						currentToken += c
						if c == '"':
							continuingString = True
						elif c == '\'':
							continuingChar = True
						else:
							sys.exit()
						currentTokenStartLineNum = lineNumber
						currentTokenStartCharNum = i
						currentTokenEndCharNumInclusive = i
#				elif (currentToken == "" and re.search('[#A-Za-z0-9_]',c)) or (currentToken != "" and re.search('[A-Za-z0-9_]',c)):		# Alphanumeric (and preprocessor directives)
				elif re.search('[A-Za-z0-9_]',c):		# Alphanumeric (and preprocessor directives)
					if currentToken == "":	# The token starts here
						currentTokenStartLineNum = lineNumber
						currentTokenStartCharNum = i
					currentToken += c
					currentTokenEndCharNumInclusive = i
				elif c == '.' and currentToken.isdigit() and '.' not in currentToken:
					if currentToken == "":	# The token starts here
						currentTokenStartLineNum = lineNumber
						currentTokenStartCharNum = i
					currentToken += c
					currentTokenEndCharNumInclusive = i
				elif re.search('\s',c):					# Whitespace characters
					if currentToken != "":
						currentTokenIndex = tokenIndex
						if currentToken == "long" and currentLinetokenList and currentLinetokenList[-1]=="long":
							del currentLinetokenList[-1]
							currentToken = "long long"
							currentTokenIndex = currentLineTokenListInfo[-1][1]			# We need to pick up the token index from the previous token
							currentTokenStartLineNum = currentLineTokenListInfo[-1][2]	# We need to pick up the starting position from the previous token
							currentTokenStartCharNum = currentLineTokenListInfo[-1][3]	# We need to pick up the starting position from the previous token
							tokenIndex = currentTokenIndex # Because we will increement it 
							del currentLineTokenListInfo[-1]	# After noting down that information, we can delete it
						currentLinetokenList.append(currentToken)
						currentTokenEndLineNum = lineNumber
						currentTokenEndCharNumInclusive = i-1		# Do not count the whitespace TO-DO: What about first char in current line is whitespace?
						currentLineTokenListInfo.append([currentToken, currentTokenIndex, currentTokenStartLineNum, currentTokenStartCharNum, currentTokenEndLineNum, currentTokenEndCharNumInclusive])
						currentTokenStartLineNum = LARGE_NEGATIVE_NUMBER
						currentTokenStartCharNum = LARGE_NEGATIVE_NUMBER
						currentTokenEndLineNum = LARGE_NEGATIVE_NUMBER
						currentTokenEndCharNumInclusive = LARGE_NEGATIVE_NUMBER
						if currentLinetokenList[0]== preProcessorSymbol and currentToken in preprocessingDirectives:
							currentLineIsPreProcessorDirective = True
							PRINT("currentLine =<", line,">is preProcessorDirective")
						currentToken = ""
						tokenIndex += 1
						
				elif ord(c) >= 32 and ord(c) <= 126:	# Other non-alphanumeric valid characters like the !, #, $, &, ', (, ), {,}, *, +, comma, -, ., /, :, ;, <, =, >, ?, `, ~
				
					if currentToken != "":	# The current char cannot be added to the existing token, so first add the current token
						currentLinetokenList.append(currentToken)
						currentTokenEndLineNum = lineNumber
#						currentTokenEndCharNumInclusive = i
						currentLineTokenListInfo.append([currentToken, tokenIndex, currentTokenStartLineNum, currentTokenStartCharNum, currentTokenEndLineNum, currentTokenEndCharNumInclusive])
						currentTokenStartLineNum = LARGE_NEGATIVE_NUMBER
						currentTokenStartCharNum = LARGE_NEGATIVE_NUMBER
						currentTokenEndLineNum = LARGE_NEGATIVE_NUMBER
						currentTokenEndCharNumInclusive = LARGE_NEGATIVE_NUMBER
						if currentLinetokenList[0]== preProcessorSymbol and currentToken in preprocessingDirectives:
							currentLineIsPreProcessorDirective = True
							PRINT("currentLine =<", line,">is preProcessorDirective")
						currentToken = ""
						tokenIndex += 1

					# Find out if this is a single-char token, or not
					tokenConsumed = c
					singleCharToken = True
					lastCharIndexToBeConsumedInThisToken = i
					for keyword in keywordsSorted:
						keywordLength = len(keyword)
						if i+keywordLength <= len(line) and line[i:i+keywordLength]==keyword:
							singleCharToken = False
							lastCharIndexToBeConsumedInThisToken = i+keywordLength-1
							tokenConsumed = line[i:lastCharIndexToBeConsumedInThisToken+1]
							break

					# Remember, the statement '#define NEWMACRO(define) #define' is valid, and the second '#define' is interpreted as two tokens: '#' followed by 'define'.
					
					currentLinetokenList.append(tokenConsumed)
					currentTokenStartLineNum = lineNumber
					currentTokenStartCharNum = i
					currentTokenEndLineNum = lineNumber
					currentTokenEndCharNumInclusive = lastCharIndexToBeConsumedInThisToken
					currentLineTokenListInfo.append([tokenConsumed, tokenIndex, currentTokenStartLineNum, currentTokenStartCharNum, currentTokenEndLineNum, currentTokenEndCharNumInclusive])
					tokenIndex += 1
					i = lastCharIndexToBeConsumedInThisToken

					# We do not need to explicitly set the currentToken to "" because if it were not blank, we would deal with it first and make it blank.
					# Observe that we are directly adding the char c (not the currentToken) to the currentLinetokenList and currentLineTokenListInfo
					currentTokenStartLineNum = LARGE_NEGATIVE_NUMBER
					currentTokenStartCharNum = LARGE_NEGATIVE_NUMBER
					currentTokenEndLineNum = LARGE_NEGATIVE_NUMBER
					currentTokenEndCharNumInclusive = LARGE_NEGATIVE_NUMBER
					
				else:
					OUTPUT ("Exiting - unknown character <%s> at char index of (%d) within line=<%s>" %(c,i,line) )
					sys.exit()
					return False
				
				#Takes care of the case where the line ends without a whitespace or newline at the end
				if i == len(line)-1 and currentToken != "":
#					PRINT ("hit i=",i,", the last character <",c,">" )
					currentLinetokenList.append(currentToken)
					currentTokenEndLineNum = lineNumber
					currentTokenEndCharNumInclusive = i
					currentLineTokenListInfo.append([currentToken, tokenIndex, currentTokenStartLineNum, currentTokenStartCharNum, currentTokenEndLineNum, currentTokenEndCharNumInclusive])
					currentTokenStartLineNum = LARGE_NEGATIVE_NUMBER
					currentTokenStartCharNum = LARGE_NEGATIVE_NUMBER
					currentTokenEndLineNum = LARGE_NEGATIVE_NUMBER
					currentTokenEndCharNumInclusive = LARGE_NEGATIVE_NUMBER
					currentToken = ""
					tokenIndex += 1
#					PRINT ("Hit EOL" )
				
				
			else:
				OUTPUT ("HOW DID THE CONTROL COME HERE?" )
				sys.exit()
				if currentToken != "":
					currentLinetokenList.append(currentToken)
					currentTokenEndCharNumInclusive = currentTokenStartCharNum + len(currentToken)
					currentLineTokenListInfo.append([currentToken, tokenIndex, currentTokenStartLineNum, currentTokenStartCharNum, currentTokenEndLineNum, currentTokenEndCharNumInclusive])
					currentTokenStartLineNum = LARGE_NEGATIVE_NUMBER
					currentTokenStartCharNum = LARGE_NEGATIVE_NUMBER
					currentTokenEndLineNum = LARGE_NEGATIVE_NUMBER
					currentTokenEndCharNumInclusive = LARGE_NEGATIVE_NUMBER
					currentToken = ""
					tokenIndex += 1
				PRINT ("Hit EOL" )
				break
				
			i += 1	# Within the current line, increase the char pointer
			
		if (currentLineIsPreProcessorDirective or continuingMacro) and currentLinetokenList[-1] =="\\":
			del currentLinetokenList[-1]
			if currentLineTokenListInfo[-1][0] == "\\":
				del currentLineTokenListInfo[-1]
			continuingMacro = True
		elif (currentLineIsPreProcessorDirective or continuingMacro) and currentLinetokenList[-1] !="\\":
			continuingMacro = False
			
		PRINT ("For Line # ", lineNumber, ", currentLinetokenList = ", currentLinetokenList )
		tokenList.extend (currentLinetokenList)
		PRINT("\nFor currentLineTokenListInfo below, each member is a tuple <currentToken, tokenIndex, currentTokenStartLineNum, currentTokenStartCharNum, currentTokenEndLineNum, currentTokenEndCharNumInclusive>","\n","="*50)
		PRINT ("For Line # ", lineNumber, ", currentLineTokenListInfo = ", currentLineTokenListInfo )
		linewiseTokenInfo.append (currentLineTokenListInfo)

	# Check that tokenListInfo and linewiseTokenInfo are lists of lists
	


	# Sanity check - verify that tokenList and tokenListInfo are in order

	
	tokenListReconstructed = []
	lastTokenIndex = -1
	tokenIndexListFromLines = []
	for tokenListInfoForOneLine in linewiseTokenInfo:
		PRINT("\nCurrently handling tokenListInfoForOneLine =",tokenListInfoForOneLine)
		i = 0
		while i < len(tokenListInfoForOneLine):
			PRINT("\nCurrently handling tokenListInfoForOneLine[",i,"] =",tokenListInfoForOneLine[i])
			if tokenListInfoForOneLine[i]:	# Not blank
				token = tokenListInfoForOneLine[i][0]
				tokenIndex = tokenListInfoForOneLine[i][1]
				if tokenIndex not in tokenIndexListFromLines:
					tokenIndexListFromLines.append(tokenIndex) 
				currentTokenStartLineNum = tokenListInfoForOneLine[i][2]
				currentTokenStartCharNum = tokenListInfoForOneLine[i][3]
				currentTokenEndLineNum = tokenListInfoForOneLine[i][4]
				currentTokenEndCharNumInclusive = tokenListInfoForOneLine[i][5]
				
				PRINT("For tokenListInfoForOneLine[",i,"], token =", token, "tokenIndex =",tokenIndex)
				if tokenIndex != lastTokenIndex:
					tokenListInfo.append([token, tokenIndex, [[currentTokenStartLineNum, currentTokenStartCharNum, currentTokenEndLineNum, currentTokenEndCharNumInclusive]]])
					tokenListReconstructed.append(token)
					lastTokenIndex = tokenIndex
				else:
					PRINT("WARNING: tokenIndex (", tokenIndex, " == lastTokenIndex (", lastTokenIndex,")!!")
					tokenListInfo[-1][2].append([currentTokenStartLineNum, currentTokenStartCharNum, currentTokenEndLineNum, currentTokenEndCharNumInclusive])
					
			else:
				PRINT("\nWARNING: tokenListInfoForOneLine[",i,"] is blank!!")
			i += 1

	if tokenList != tokenListReconstructed or len(tokenListInfo) != len(tokenList) or (tokenIndexListFromLines and max(tokenIndexListFromLines)!= len(tokenList)-1):
		if tokenList != tokenListReconstructed:
			OUTPUT("\n\n\nERROR: Mismatching tokenList and tokenListReconstructed!!!")
		if len(tokenListInfo) != len(tokenList):
			OUTPUT("\nlen(tokenListInfo) =",len(tokenListInfo),"does not match with len(tokenList) =",len(tokenList))
		if tokenIndexListFromLines and max(tokenIndexListFromLines)!= len(tokenList)-1:
			OUTPUT("\nmax(tokenIndexListFromLines) = ",max(tokenIndexListFromLines),"does not match with len(tokenList)-1 =", len(tokenList)-1)
		OUTPUT("\n\ntokenIndexListFromLines =",tokenIndexListFromLines)
		OUTPUT("\nmax(tokenIndexListFromLines)=",max(tokenIndexListFromLines),"len(tokenList)-1=", len(tokenList)-1)
		OUTPUT("\n\n\nlinewiseTokenInfo =",linewiseTokenInfo)
		OUTPUT("\n\n\ntokenListReconstructed =",tokenListReconstructed)
		OUTPUT("\n\n\ntokenList =",tokenList)
		errorMessage = "The token indices from tokenList, tokenListInfo and linewiseTokenInfo are out of sync!"
		errorRoutine(errorMessage)
		return False
	for i in range(len(tokenList)):
		if tokenList[i] != tokenListInfo[i][0] or i != tokenListInfo[i][1]:
			PRINT("\n\ntokenList =",STR(tokenList))
			PRINT("\n\ntokenListInfo =",STR(tokenListInfo))
			errorMessage = "tokenList and tokenListInfo are out of sync!"
			errorRoutine(errorMessage)
			return False
		
	return [tokenList, tokenListInfo, linewiseTokenInfo]



####################################################################################################################
# This function takes two inputs.
# 1) inputLines - list of lines (strings), each delimited by a newline character (MUST)
# 2) inputList - list of tokens that we want to search in the tokenized version of the inputLines
# 3) lookFromTokenIndex - An optional token index, which tell NOT took for the inputList before this token. This is useful when you want to exclude some part of the inputLines.
# Output is a 5-item list, where each item is [tokenStartIndex,startLineNumber,startLineCharNumber,endLineNumber,endLineCharNumber]
# This means that we can find the inputList stream of tokens at the tokenStartIndex-th position in the tokenized version of the inputLines.
# Also, we can find it starting from inputLines[startLineNumber][startLineCharNumber] and ending at inputLines[endLineNumber][endLineCharNumber] 
####################################################################################################################
# TO-DO: If the inputList contains tokens ending with a newline, how is it to be handled (because inputLines does not capture end-of-line newlines)
# TO-DO: Not sure if the inputList tokens contain a quoted string literal, how it will be handled

def findTokenListInLines(inputLines, inputList, lookFromTokenIndex = 0):
#	global PRINT_DEBUG_MSG
#	PRINT_DEBUG_MSG = True
	
	# Take care of the special cases - the blank ones
	if (not inputList) and (not inputLines):
		return [0,0,0,0,0]
	elif not inputList and inputLines:	# Blank inputList but non-blank inputLines
		PRINT ("The inputList (matching pattern to be searched) is blank <",inputList,">" )
		return [0,-1,-1,-1,-1]
	elif not inputLines and inputList:	# Blank inputLines but non-blank inputList
		return [-1000000,-1,-1,-1,-1]
		
	# Check that inputLine is a list of Lines (strings ending with a newline). If it is a single string, make it a list
	if  isinstance(inputLines,list):
#		PRINT ("inputLines is indeed a list" )
		itemCount = 0
		while itemCount < len(inputLines):
			if not checkIfString(inputLines[itemCount]):
				PRINT ("Exiting - inside findTokenListInLines(inputLines, inputList), inputLines is not a list of proper strings - ", inputLines )
				return False
				sys.exit()
#			elif inputLines[itemCount][-1] != '\n':
#				PRINT ("Appending newline to the end of inputLines[",itemCount,"]" )
#				inputLines[itemCount] = inputLines[itemCount] + '\n'
			itemCount = itemCount + 1
#		PRINT ("inputLines is indeed a list of proper strings - ", inputLines )
	else:
#		PRINT ("inputLines is NOT a list" )
		if checkIfString(inputLines):
			if inputLines[-1] != '\n':
#				PRINT ("Appending newline to the end of inputLines" )
				inputLines = inputLines + '\n'
#			PRINT ("Converting the inputLines <",inputLines,">, which is a basic string but not a list, into a list" )
			inputLines = [inputLines]
#			PRINT ("Now the listified inputLines = ",inputLines )
		else:
			PRINT ("Unknown object type - inputLines = <",inputLines,"> - exiting" )
			PRINT ("Exiting - inside findTokenListInLines(inputLines, inputList), inputLines is Unknown object type - ", inputLines )
			return False
			sys.exit()
			
	# Check that inputList is a list of strings. If it is a single string, make it a list
	if  isinstance(inputList,list):
#		PRINT ("inputList is indeed a list" )
		for item in inputList:
			if not checkIfString(item):
				PRINT ("Exiting - inputList is not a list of proper strings - ", inputList )
				return False
				sys.exit()
			elif item != item.strip():
				PRINT (("inputList contains token <%s> that has whitespaces at their beginning or end - exiting"%item) )
				PRINT ("inputLines =",inputLines,"inputList =",inputList )
				return False
				sys.exit()
				
#		PRINT ("inputList is indeed a list of proper strings - ", inputList )
	else:
#		PRINT ("inputList is NOT a list" )
		if checkIfString(inputList):
#			PRINT ("Converting the inputList <",inputList,">, which is a basic string but not a list, into a list" )
			inputList = [inputList]
#			PRINT ("Now the listified inputList = ",inputList )
		else:
			errorMessage = "Unknown object type - inputList = <" + STR(inputList) + "> - exiting"
			errorRoutine(errorMessage)
			return False
	
	if not checkIfIntegral(lookFromTokenIndex):
		errorMessage = "ERROR in findTokenListInLines() - lookFromTokenIndex (" + STR(lookFromTokenIndex) + ") is not integral"
		errorRoutine(errorMessage)
		return False
	elif lookFromTokenIndex < 0:
		errorMessage = "ERROR in findTokenListInLines() - illegal value of lookFromTokenIndex (" + STR(lookFromTokenIndex) + ") - is not positive"
		errorRoutine(errorMessage)
		return False
		
	
	tokenizedLinesResult = tokenizeLines(inputLines)
	if tokenizedLinesResult == False:
		errorMessage = "ERROR in findTokenListInLines after calling tokenizeLines(inputLines)"
		errorRoutine(errorMessage)
		return False
	else:
		tokenizedLines = tokenizedLinesResult[0]
		
	PRINT ("tokenizedLines =",tokenizedLines)
	lineCharPositions = []	# For token #N in tokenizedLines, lineCharPositions[N] = [[startLineNum,startCharNum],[endLineNum,endCharNum]]

	# First find out the starting and ending <line,char> for each token
	tokenNum = 0
	tokenCharNum = 0
	matchingToken = False		# This tells if we are matching chars of a token, or matching whitespaces (if False)
	lastTokenMatched = False
	for lineNum in range(len(inputLines)):
		if lastTokenMatched:
			break
		for charNum in range(len(inputLines[lineNum])):
			if inputLines[lineNum][charNum]==tokenizedLines[tokenNum][tokenCharNum]:
				if tokenCharNum == 0:	# First char of the token matched
					start = [lineNum,charNum]
				if tokenCharNum == len(tokenizedLines[tokenNum])-1:	# Last char of the token matched
					end = [lineNum,charNum]
					lineCharPositions.append([start,end])
					if tokenNum == len(tokenizedLines)-1:
						lastTokenMatched = True
						break
					else:
						tokenNum += 1
						tokenCharNum = 0
				else:
					tokenCharNum += 1
			elif re.match("\s",inputLines[lineNum][charNum]):
				pass
			else:
				PRINT("For tokenNum =",tokenNum,", inputLines[",lineNum,"][",charNum,"] = ",inputLines[lineNum][charNum]," is non-whitespace, non-token char - should never happen")
				sys.exit()

	PRINT ("lineCharPositions =",lineCharPositions)

	# Next see if the inputList occurs as a substring of the tokenizedLines
	if len(tokenizedLines) - lookFromTokenIndex < len(inputList):
		return [-1000000,-1,-1,-1,-1]
		
	matchStartIndex = -1000000	# Invalid value
	for k in range(len(tokenizedLines) - lookFromTokenIndex - len(inputList) + 1):
		i = lookFromTokenIndex + k
		if tokenizedLines[i] == inputList[0]:
			matchStartIndex = i
			mismatchFound = False
			for j in range(len(inputList)):
				if tokenizedLines[i+j] != inputList[j]:
					mismatchFound = True
					matchStartIndex = -1000000
					break
			if mismatchFound == False:
				PRINT ("inputList = ",inputList,"found starting at token #",matchStartIndex,"of tokenizedLines =",tokenizedLines)
				break
				
	if matchStartIndex < 0:
		PRINT ("Did not find any match :-(" )
		return [-1000000,-1,-1,-1,-1]
	else:
		returnValue = [matchStartIndex,lineCharPositions[matchStartIndex][0][0],lineCharPositions[matchStartIndex][0][1],lineCharPositions[matchStartIndex+len(inputList)-1][1][0],lineCharPositions[matchStartIndex+len(inputList)-1][1][1]]
		PRINT("Match found! returnValue =",returnValue)
		return returnValue
		

#inputLines = ['(a,b);\n', '\n', '\#define ADD_ONE(x) x+1']
#inputList = ['(', 'a', ',', 'b', ')']
		
#inputLines = ["b c","\n",'\n'," 	efgh \n", "a d"]
#inputList = ["c","efgh","a","a"]

#result1 = findTokenListInLines(inputLines, inputList)
#PRINT("result1 =",result1)
#PRINT("result2 =",result2)
#sys.exit()

####################################################################################################################
#  THE most important function. It takes in a tokenStream, and returns an AST
####################################################################################################################
def parseArithmeticExpression(arithmeticExpression):
#	PRINT ("arithmeticExpression to be parsed = ", arithmeticExpression )
#	PRINT ("len(arithmeticExpression) = ", len(arithmeticExpression) )
	
#	arithmeticExpressionNode = Node (arithmeticExpression, "arithmeticExpression")
#	parentNode.add_child(arithmeticExpressionNode)

	# Earlier this had a bug that if the input was a string instead of a list, it would break up string into individual chars
	if checkIfString(arithmeticExpression):
		return [arithmeticExpression]
	elif not isinstance(arithmeticExpression,list):
		errorMessage = "ERROR in parseArithmeticExpression: supplied input <%s> is neither a string nor a list"%(STR(arithmeticExpression))
		errorRoutine(errorMessage)
		return False

	global cDataTypes, cKeywords

	# The operator precedence table has the following format:
	# Rows at the beginning of this table (lower indices) have higher precedence over the later rows (higher indices).
	# Each row is a 2-member tuple. The first member is a set of the operators with equal precedence.
	# The second member indicates which operand(s) the Operator takes, and in what order. This tells if it is Left-to-Right associative, or Right-to-Left.
	# +1 means the operand lies to the operator's right (naturally, -1 means to the left)
	operatorPrecedence = [ 	[['##'],[-1,+1]],						# Left-to-Right (presumably), Concatenate	# TO-DO fix the associativity
#							[['++','--','()','[]','.','->'],[-1]],	# Left-to-Right, postfix increment/decrement
							[['++','--','()','[]'],[-1]],			# Left-to-Right, postfix increment/decrement
							[['.','->'],[-1,+1]],					# Left-to-Right, struct member assignment
							[['++','--','+','-','!','~','(typecast)','*','&','sizeof','_Alignof'],[+1]],	#Right-to-Left, prefix increment/decrement, unary +-
							[['/','*','%'],[-1,+1]],				# Left-to-Right
							[['-','+'],[-1,+1]],					# Left-to-Right, Addition and subtraction
							[['<<','>>'],[-1,+1]],					# Left-to-Right, Bitwise left/right shift operators
							[['<','<=','>','>='],[-1,+1]],			# Left-to-Right, relational
							[['==','!='],[-1,+1]],					# Left-to-Right, relational
							[['&'],[-1,+1]],						# Left-to-Right, bitwise AND
							[['^'],[-1,+1]],						# Left-to-Right, bitwise XOR
							[['|'],[-1,+1]],						# Left-to-Right, bitwise OR
							[['&&'],[-1,+1]],						# Left-to-Right, logical AND
							[['||'],[-1,+1]],						# Left-to-Right, logical OR
							[['?'],[+3,+1,-1]],						# Right-to-Left, Ternary conditional ?:
							[['=','+=','-=','*=','/=','%=','<<=','>>=','&=','^=','|='],[+1,-1]], # Right-to-Left, Assignments
							[[','],[-1,+1]]]						# Left-to-Right, comma

	operatorSet = []
	i=0
	while i<len(operatorPrecedence):
		operatorSet = operatorSet + operatorPrecedence[i][0]
		i += 1
	operatorSet = operatorSet + [':']	# Need to add it separately since it does not get covered automatically
#	PRINT ("operatorSet = ", operatorSet )

	# Not sure why we are doing this
	if len(arithmeticExpression) < 1:		# Question: Why is this?
		return arithmeticExpression
	elif len(arithmeticExpression) == 1 and arithmeticExpression[0] not in cDataTypes: #Question: Why only cDataTypes, instead of cDataTypes+cKeywords?
		return arithmeticExpression

	
	# Before applying the Operator precedence rule repeatedly, there are some cases where the list is better handled manually (like typecasting, function calls, array indexing etc.)
	
	# We try to "condense" the multiple consecutive elements of the arithmeticExpression list into one, thereby reducing the list size
	operatorOperandArray = []
	i=0
	while i < len(arithmeticExpression):
	
		# Handle the case that the expression is a datatype
#		PRINT ("Input arithmeticExpression = ", arithmeticExpression )
#		PRINT ("Currently handling arithmeticExpression[",i,"] =", arithmeticExpression[i] )
#		Remember that cDataTypes = ["char","double","float","int", "long","short","void","signed","unsigned"]

		if arithmeticExpression[i] in cDataTypes:	# We try to ensure that we cover the case like "unsigned short int" etc.
#			PRINT ("\n\n\n\n\n\n\narithmeticExpression[i] in cDataTypes:\n\n\n\n\n\n" )
			dataTypeIndex = i+1
#			PRINT ("dataTypeIndex = ", dataTypeIndex )
			# We might have data type consisting of multiple words, like unsigned short int 
			# We need to handle the pointer ("*") and array ("[]") later, and recall that we can have array[arithmeticExpression] type also
			while dataTypeIndex <len(arithmeticExpression) and arithmeticExpression[dataTypeIndex] in cDataTypes:
				dataTypeIndex += 1
#			PRINT ("Last dataTypeIndex = ", dataTypeIndex )
			newDataTypeToken = ["datatype",arithmeticExpression[i:dataTypeIndex]]
			operatorOperandArray.append(newDataTypeToken)
			i=dataTypeIndex-1
			
		# Handle parenthesized expressions: Strip the braces, and put them as a single list item
		elif arithmeticExpression[i] == "(":
			PRINT("\nFound first bracket at i=",i,"- before doing anything, operatorOperandArray =",operatorOperandArray)
			if matchingBraceDistance(arithmeticExpression[i:]) < 1:
				PRINT ("ERROR - no matching brace for ",arithmeticExpression[i]," ... exiting" )
				return False
				sys.exit()
			j= i + matchingBraceDistance(arithmeticExpression[i:])
			# There could be multiple cases: Simple braces, function call (including sizeof), and typecasting
			#Function call (including sizeof)
#			if i>0 and arithmeticExpression[i-1] not in removeItemsIn2ndListFrom1st(cKeywords, ["sizeof"]) and arithmeticExpression[i-1] not in operatorSet:
			if operatorOperandArray and operatorOperandArray[-1] not in cKeywords and operatorOperandArray[-1] not in operatorSet: # Function call
#				PRINT ("Found function call\n" )
				functionName = operatorOperandArray[-1]
				del operatorOperandArray[-1]
				parseArithmeticExpressionOutput = parseArithmeticExpression(arithmeticExpression[i+1:j])
				if parseArithmeticExpressionOutput == False:
					PRINT ("ERROR after calling parseArithmeticExpression(arithmeticExpression[i+1:j]) for arithmeticExpression[",i,"+1:",j,"] = ",arithmeticExpression[i+1:j] )
					return False
					sys.exit()
				operatorOperandArray.append(["function()", functionName, ["()",parseArithmeticExpressionOutput]])
				i = j
				
			# The arithmeticExpression[j] is the ending brace for the typecasting type. The variable being typecast will start from j+1
			elif j+1<len(arithmeticExpression) and arithmeticExpression[j+1] not in cKeywords and arithmeticExpression[j+1] not in operatorSet:
				PRINT ("Found typecasting\n" )
				#The next token to be typecast is either a variable or yet another parenthesized expression
				typecastVarEndIndex = j+1
				if arithmeticExpression[j+1] == "(":	#yet another parenthesized expression
					if matchingBraceDistance(arithmeticExpression[j+1:]) < 1:
						PRINT ("ERROR - no matching brace for ",arithmeticExpression[j+1]," ... exiting" )
						return False
						sys.exit()
					typecastVarEndIndex = j+1 + matchingBraceDistance(arithmeticExpression[j+1:])
				parseArithmeticExpressionOutput1 = parseArithmeticExpression (arithmeticExpression[i+1:j])
				parseArithmeticExpressionOutput2 = parseArithmeticExpression(arithmeticExpression[j+1:typecastVarEndIndex+1])
				if parseArithmeticExpressionOutput1 == False:
					PRINT ("ERROR after calling parseArithmeticExpression (arithmeticExpression[i+1:j]) for arithmeticExpression[",i,"+1:",j,"] =",arithmeticExpression[i+1:j] )
					return False
				elif parseArithmeticExpressionOutput2 == False:
					PRINT ("ERROR after calling parseArithmeticExpression(arithmeticExpression[j+1:typecastVarEndIndex+1]) for arithmeticExpression[",j,"+1:",typecastVarEndIndex,"+1] =",arithmeticExpression[j+1:typecastVarEndIndex+1] )
					return False
				newTypecastToken = ["typecast",["()",parseArithmeticExpressionOutput1], parseArithmeticExpressionOutput2]
				operatorOperandArray.append(newTypecastToken)
				i = typecastVarEndIndex
			else:
				parseArithmeticExpressionOutput = parseArithmeticExpression(arithmeticExpression[i+1:j])
				if parseArithmeticExpressionOutput == False:
					PRINT ("ERROR after calling parseArithmeticExpression(arithmeticExpression[i+1:j]) for arithmeticExpression[",i,"+1:",j,"] = ", arithmeticExpression[i+1:j] )
					return False
				operatorOperandArray.append(["()", parseArithmeticExpressionOutput])
				i = j
			PRINT("\nAfter handling first bracket at i=",i,"- operatorOperandArray =",operatorOperandArray,"\n")
			
		# Flowery (2nd) bracket: Handle parenthesized expressions: Strip the braces, and put them as a single list item
		elif arithmeticExpression[i] == "{" :
			if matchingBraceDistance(arithmeticExpression[i:]) < 1:
				PRINT ("ERROR - no matching brace for ",arithmeticExpression[i]," ... exiting" )
				return False
				sys.exit()
			j= i + matchingBraceDistance(arithmeticExpression[i:])
			parseArithmeticExpressionOutput = parseArithmeticExpression(arithmeticExpression[i+1:j])
			if parseArithmeticExpressionOutput == False:
				PRINT ("ERROR after calling parseArithmeticExpression(arithmeticExpression[i+1:j]) for arithmeticExpression[",i,"+1:",j,"] = ",arithmeticExpression[i+1:j] )
				return False
			operatorOperandArray.append(["{}", parseArithmeticExpressionOutput])
			i = j
		# Third bracket
		elif arithmeticExpression[i] == "[" :
			PRINT("\nBefore handling third bracket at i=",i,"- operatorOperandArray =",operatorOperandArray)
			if matchingBraceDistance(arithmeticExpression[i:]) < 1:
				PRINT ("ERROR - no matching brace for ",arithmeticExpression[i]," ... exiting" )
				return False
				sys.exit()
			j= i + matchingBraceDistance(arithmeticExpression[i:])
			parseArithmeticExpressionOutput = parseArithmeticExpression(arithmeticExpression[i+1:j])
			if parseArithmeticExpressionOutput == False:
				PRINT ("ERROR after calling parseArithmeticExpression(arithmeticExpression[i+1:j]) for arithmeticExpression[",i,"+1:",j,"] =",arithmeticExpression[i+1:j] )
				return False
			# Now note to what array variable this attaches to
			arrayVariableName = operatorOperandArray[-1]
			del operatorOperandArray[-1]
			operatorOperandArray.append([arrayVariableName,["[]", parseArithmeticExpressionOutput]])
			i = j
			PRINT("\nAfter handling third bracket at i=",i,"- operatorOperandArray =",operatorOperandArray,"\n")
		else:
#			PRINT ("Adding arithmeticExpression[",i,"] = ", arithmeticExpression[i] )
			operatorOperandArray.append(arithmeticExpression[i])
		i += 1

	#Check if operatorOperandArray has a single member, and that itself is a list. If it is, then return that single member
	if len(operatorOperandArray)==1 and isinstance(operatorOperandArray[0],list):
		operatorOperandArray = operatorOperandArray[0]
		
#	PRINT ("\nIncoming arithmeticExpression = <", arithmeticExpression, ">\nAfter handling the parenthesization, function call, it translates into" )
#	PRINT ("operatorOperandArray = ", operatorOperandArray, "\nNow we will apply the operator precedence and condense this even further." )
	
	while True: 
#		PRINT ("\n\noperatorOperandArray[]", operatorOperandArray, "currently has",len(operatorOperandArray),"members" )
		operatorOperandArrayOrigLen = len(operatorOperandArray)
		if len(operatorOperandArray) <= 1:
#			PRINT ("\n\n\n\n\n" )
			break
		newToken = []
		operatorAppliedToOperand = False
		# Look for the highest-precedence available operator
		for j in range(len(operatorPrecedence)):
			if operatorAppliedToOperand:
				break
			for k in range(len(operatorPrecedence[j][0])):
				if operatorAppliedToOperand:
					break
				for x in range(len(operatorOperandArray)):
					# For Left-to-Right (or Right-to-Left) associativity we scan accordingly
					if operatorPrecedence[j][1][0] >= +1:
#						PRINT ("Special case for Right-to-Left associativity" )
						i = len(operatorOperandArray)-1-x
#						PRINT ("i=",i,"x=",x,"len(operatorOperandArray)=",len(operatorOperandArray),"operatorOperandArray=",operatorOperandArray )
					else:
						i = x
					if operatorAppliedToOperand:
						break
					if operatorPrecedence[j][0][k] == operatorOperandArray[i]:
						hasValidOperands = True
						for operandOffset in range(len(operatorPrecedence[j][1])):
							# Ensure that the operator currently has sufficient operands
							if ((i+operatorPrecedence[j][1][operandOffset] >= len(operatorOperandArray)) or 
							    (i+operatorPrecedence[j][1][operandOffset] <0) or 
							    (operatorOperandArray[i+operatorPrecedence[j][1][operandOffset]] in operatorSet)):
								hasValidOperands = False
								PRINT ("hasValidOperands =",hasValidOperands,"for",operatorPrecedence[j][1] )
						# Special rules for operators that can be interpreted as either unary or binary. 
						if hasValidOperands and operatorOperandArray[i] in ("+","-","*","&") and i>0 and len(operatorPrecedence[j][1])==1 and operatorOperandArray[i-1] not in operatorSet:
							hasValidOperands = False
						# Also handle the ternary operator
						elif hasValidOperands and operatorOperandArray[i] == "?" and operatorOperandArray[i+2] != ":":
							hasValidOperands = False
						
						if hasValidOperands:
							operatorAppliedToOperand = True
							minIndex = i + min(0,min(operatorPrecedence[j][1]))
							maxIndex = i + max(0,max(operatorPrecedence[j][1]))
#							PRINT ("x =",x, "i =",i,"j =",j,"k =",k, "operator =",operatorPrecedence[j][0][k], "minIndex = ", minIndex, "maxIndex = ", maxIndex,"operatorOperandArray[minIndex:maxIndex+1]=",operatorOperandArray[minIndex:maxIndex+1] )
							newToken = operatorOperandArray[minIndex:maxIndex+1]
#							PRINT ("deleting newToken =",newToken, "starting at index", minIndex,"and ending before index", maxIndex+1 )
							del operatorOperandArray[minIndex:maxIndex+1]
#							PRINT ("After deleting, operatorOperandArray = ",operatorOperandArray )
							operatorOperandArray.insert(minIndex,newToken)
#							PRINT ("After inserting",newToken, "\noperatorOperandArray = ",operatorOperandArray,"\n" )
							break
		if operatorOperandArrayOrigLen < len(operatorOperandArray):
			PRINT ("The numbe of operands should not increase - exiting!!!\n\n\n" )
			PRINT ("operatorOperandArrayOrigLen =",operatorOperandArrayOrigLen,"operatorOperandArray =",operatorOperandArray )
			return False
			sys.exit()
		elif operatorOperandArrayOrigLen == len(operatorOperandArray):
#			PRINT ("No longer able to apply the operators - exiting the loop!!!\n\n\n" )
			break
			
	#Check if operatorOperandArray has a single member, and that itself is a list. If it is, then return that single member
	if len(operatorOperandArray)==1 and isinstance(operatorOperandArray[0],list):
#		PRINT ("Single-member List, hence returning operatorOperandArray[0]=",operatorOperandArray[0] )
		return operatorOperandArray[0]
	else:
#		PRINT ("multi-member List, hence returning operatorOperandArray =",operatorOperandArray )
		return operatorOperandArray


#input = ['S1','[','0',']','+','c']
#input2 = ['min','[','0',']','+','max', '[','1', ']']
#input2 = ['min','(','0',')','+','1']
#result = parseArithmeticExpression(input2)
#OUTPUT("parseArithmeticExpression(input2=",input2,") = result =",result)
#sys.exit()
'''
###############################################
# Testing if the evaluation realy works
###############################################
from random import seed
from random import randint
from random import random
seed(10)
for _ in range(0,1000):
	exprList = []
	exprStr = ""
	for _ in range(10):
		valueInt = randint(0,10)
		valueFloat = random()
#		print valueInt, valueFloat
		exprList.append(str(valueInt))
		exprStr+=(str(valueInt))
		exprList.append("+" if valueFloat < 0.5 else "-")
		exprStr+=("+" if valueFloat < 0.5 else "-")
	exprList.append("0")
	exprStr+="0"
	print "exprStr =",exprStr,"eval(",exprStr,") =",eval(exprStr)
	result = evaluateArithmeticExpression(parseArithmeticExpression(exprList))
	print exprList,"=",exprList,"evaluates to",result[1]
	final = ("SUCCESS" if result[1] == eval(exprStr) else "FAIL")
	if final == "FAIL":
		print "ERROR"
		sys.exit()
sys.exit()
'''

########################################################################################################################################################
# This function takes in an input STRING (which is NOT a list) containing an address/size in human-readable formats, and returns the decimal equivalent
# For example, inputString = "1GB+5MB-384KB" will yeild [True, 1078591488]. Recall that we cannot send just False in case of an error 
# because False (equivalent of 0) is a valid return value.
########################################################################################################################################################
def convertByteUnits2Decimal(inputString):

	dicSize = {"KB":"*(1<<10)","MB":"*(1<<20)","GB":"*(1<<30)","TB":"*(1<<40)","PB":"*(1<<50)","EB":"*(1<<60)","ZB":"*(1<<70)","YB":"*(1<<80)"}
	
	if not checkIfString(inputString):
		return [False,None]
		
#	PRINT (dicSize)
	convertedString = inputString
	for key,value in dicSize.items():
#		PRINT ("Replaceing all occurrences of ",key,"with",value,"in convertedString =",convertedString)
		convertedString = convertedString.replace(key,value)
	PRINT ("convertedString =",convertedString)
	
	tokenizeLinesResult = tokenizeLines(convertedString)
	if tokenizeLinesResult == False:
		errorMessage = "ERROR in convertByteUnits2Decimal() tokenizing <%s>"%convertedString
		errorRoutine(errorMessage)
		return [False,None]
	else:
		tokenizeLinesResult = tokenizeLinesResult[0]
	
	parseArithmeticExpressionResult = parseArithmeticExpression(tokenizeLinesResult)
	if parseArithmeticExpressionResult == False:
		errorMessage = "ERROR in convertByteUnits2Decimal() parsing <%s>"%tokenizeLinesResult
		errorRoutine(errorMessage)
		return [False,None]
		
	evaluateArithmeticExpressionResult = evaluateArithmeticExpression(parseArithmeticExpressionResult)
	if evaluateArithmeticExpressionResult[0] == False:
		errorMessage = "ERROR in convertByteUnits2Decimal() evaluating <%s>"%evaluateArithmeticExpressionResult
		errorRoutine(errorMessage)
		return [False,None]
		
	num = evaluateArithmeticExpressionResult[1]
	PRINT ("Result = ",num)
	if isinstance(num,float):
		result = int(num + 0.01)	# A hack to cover the case when the number is actual very near to an integral value, but just LESS than that value. So, we give it a bit of a push
	else:
		result = num
	return [True, result]

#inputString = "1KB/33"
#print convertByteUnits2Decimal(inputString)
#sys.exit()

############################################################################################
# Given an AST (this NOT a tokenstream), this method outputs the corresponding string
############################################################################################
def outputTextArithmeticExpressionFromAST (arithmeticExpressionAST):
	PRINT ("\n\nIncoming already-listified AST string = ", arithmeticExpressionAST )
	if checkIfString(arithmeticExpressionAST):
		PRINT ("It's a string - returning as it is!" )
		return arithmeticExpressionAST
	elif isinstance(arithmeticExpressionAST,list):
		# If it is a list of lists, but contains only a single member, remove one level of listification
		if len(arithmeticExpressionAST) == 1:
#			PRINT ("Returning",arithmeticExpressionAST[0] )
			return outputTextArithmeticExpressionFromAST (arithmeticExpressionAST[0])
		else:	
			if not isASTvalid(arithmeticExpressionAST):
				PRINT ("\nWARNING - outputting Text from arithmeticExpressionAST may not work because the inputList is not a valid AST\n" )

			outputString = ""
			i = 0
			while i < len(arithmeticExpressionAST):
				PRINT ("\nhandling arithmeticExpressionAST[",i,"] =", arithmeticExpressionAST[i], "outputString = <%s>"% outputString )
				if i==0 and (arithmeticExpressionAST[i] == "()" or arithmeticExpressionAST[i] == "{}" or arithmeticExpressionAST[i] == "[]" or arithmeticExpressionAST[i] == "<>" ): 
					PRINT ("Found", arithmeticExpressionAST[i], "for i =",i )
					if len(arithmeticExpressionAST) == 2:
						outputTextArithmeticExpressionFromASTOutput = outputTextArithmeticExpressionFromAST(arithmeticExpressionAST[i+1])
						if outputTextArithmeticExpressionFromASTOutput == False:
							PRINT ("Inside outputTextArithmeticExpressionFromAST, error after calling outputTextArithmeticExpressionFromAST(arithmeticExpressionAST[i+1]) for arithmeticExpressionAST[",i,"+1] =",arithmeticExpressionAST[i+1] )
							return False
						else:
							outputString += arithmeticExpressionAST[i][0]+ ' ' + outputTextArithmeticExpressionFromASTOutput + ' ' + arithmeticExpressionAST[i][1]
					else:
						PRINT ("Inside outputTextArithmeticExpressionFromAST, unknown tokens for",arithmeticExpressionAST[i] )
						return False
						sys.exit()
					i += 1	# We are eating up one extra token
				elif i==0 and arithmeticExpressionAST[0]=="function()": 
					if len(arithmeticExpressionAST)!=3:
						PRINT ("Inside outputTextArithmeticExpressionFromAST, invalid function call",arithmeticExpressionAST )
						return False
						sys.exit()
					else:
						outputTextArithmeticExpressionFromASTOutput = outputTextArithmeticExpressionFromAST(arithmeticExpressionAST[2])
						if outputTextArithmeticExpressionFromASTOutput == False:
							PRINT ("Error after calling outputTextArithmeticExpressionFromAST(arithmeticExpressionAST[2]) for arithmeticExpressionAST[2] =",arithmeticExpressionAST[2] )
							return False
						else:
							outputString += arithmeticExpressionAST[1]+ ' ' + outputTextArithmeticExpressionFromASTOutput
							i += 2 # We are eating up two extra tokens
				elif i==0 and arithmeticExpressionAST[0]=="datatype": 
					if len(arithmeticExpressionAST)!=2:
						PRINT ("Inside outputTextArithmeticExpressionFromAST, invalid datatype expression",arithmeticExpressionAST )
						return False
						sys.exit()
					else:
						for item in arithmeticExpressionAST[1]:
							if item not in cDataTypes:
								PRINT ("Inside outputTextArithmeticExpressionFromAST, item", item,"in arithmeticExpressionAST[1] = ",arithmeticExpressionAST[1], "doesn't belong to cDataTypes =",cDataTypes )
								return False
								sys.exit()
						outputString +=  ' ' + ' '.join(arithmeticExpressionAST[1])
						i += 2 # We are eating up two extra tokens
					
				else:
					outputTextArithmeticExpressionFromASTOutput = outputTextArithmeticExpressionFromAST(arithmeticExpressionAST[i])
					if outputTextArithmeticExpressionFromASTOutput == False:
						PRINT ("ERROR after calling outputTextArithmeticExpressionFromAST(arithmeticExpressionAST[i]) for arithmeticExpressionAST[",i,"] =",arithmeticExpressionAST[i] )
						return False
					else:
#						PRINT ("found no () for i=",i )
						outputString +=  ' ' + outputTextArithmeticExpressionFromAST(arithmeticExpressionAST[i])
#				PRINT ("After completion of loop for i=",i,"outputString =", "outputString = <%s>"% outputString )
				i += 1
			
			outputString = outputString.strip()
			
			# Cross-verify that we indeed got the right string that would have yielded the same arithmeticExpressionAST
			tokenizeLinesOutput = tokenizeLines(outputString)
			if tokenizeLinesOutput == False:
				PRINT ("ERROR in outputTextArithmeticExpressionFromAST after calling tokenizeLines(outputString) for outputString = ", outputString )
				return False
			else:
				tokenizeLinesOutput = tokenizeLinesOutput[0]
				
			outputStringTokenizedAndParsed = parseArithmeticExpression(tokenizeLinesOutput)
			if outputStringTokenizedAndParsed == False:
				PRINT ("ERROR after calling parseArithmeticExpression(tokenizeLinesOutput) for tokenizeLinesOutput =",tokenizeLinesOutput )
				return False
				sys.exit()
			lhsAST = removeUnnecessaryListification(arithmeticExpressionAST)
			rhsAST = removeUnnecessaryListification(outputStringTokenizedAndParsed)
			if lhsAST != rhsAST:
				# Why this is a warning and not an error is the following. For example, suppose the input AST is ['a','+',[['b','-','c'],'*','d']]. 
				# This AST  will yield a+b-c*d, not a+(b-c)*d because the parenthesization is missing in the input AST. 
				# In other words, the Tokenstream-->Text transformation is losing information that we can never get back.
				# Now, if we tokenize and parse a+b-c*d, we will get ['a','+',['b','-',['c','*','d']]], which is different from ['a','+',[['b','-','c'],'*','d']].
				PRINT ("WARNING - somehow the outputString <",outputString,">\nwhich tokenizes/parses into <",outputStringTokenizedAndParsed,">\ndoesn't match the arithmeticExpressionAST <",arithmeticExpressionAST,"> - exiting" )
				PRINT ("lhsAST = ",lhsAST, "\nrhsAST = ",rhsAST )
#				sys.exit()

			return outputString

	else:
		PRINT ("\n\nERROR inside outputTextArithmeticExpressionFromAST - unknown passed object type", type(arithmeticExpressionAST) )
		return False
		sys.exit()

#inputList = [[['S1', ['[]', ['0']]], ['[]', ['1']]], '.', 'c']
#PRINT_DEBUG_MSG = True
#res = evaluateArithmeticExpression(inputList)
#PRINT(res)
#sys.exit()

#str = "2+3+func(c+d)*(n)"
#strTokenized = tokenizeLines(str)
#strAST = parseArithmeticExpression(strTokenized)
#strAST = ['a','+',[['b','-','c'],'*','d']]
#strASTtextified = outputTextArithmeticExpressionFromAST (strAST)
#PRINT ("strASTtextified = ",strASTtextified )
#PRINT ("\nThe Original str=<%s>, \nstrTokenized=<%s>, \nstrAST=<%s>, \nstrASTtextified =<%s>"%(str,strTokenized,strAST,strASTtextified) )
#sys.exit()

############################################################################################################################
# This function takes in an input STRING, and does the following. If the string is numeric, it returns the numeric value.
# On the other hand, if the string is non-numberic, it tokenizes it and returns its tokenized list
############################################################################################################################
def getNumericValueOrTokenizedString (inputString):
	if checkIfNumber(inputString):	# If by mistake we passed in a numeric, send that back instead of a False, since False in Python equates to 0
		return inputString
	elif not checkIfString(inputString):
		return False
#	elif inputString.isnumeric():	# Do not use checkIfIntegral here, since this is a string
	elif checkIfStringIsNumeric(inputString):	# Do not use checkIfIntegral here, since this is a string
		PRINT(inputString, "is numeric")
		return int(inputString)
	else:
		PRINT(inputString, "is NOT numeric")
		# Tokenize it
		tokenizeLinesResult = tokenizeLines(inputString)
		if tokenizeLinesResult == False:
			errorMessage = "ERROR in getNumericValueOrTokenizedString() tokenizing <%s>"%inputString
			errorRoutine(errorMessage)
			return False
		else:
			return tokenizeLinesResult[0]

############################################################################################################################
# This function returns the runtime value 
############################################################################################################################
def getRuntimeValue(inputList):
	if checkIfNumber(inputList):
		return [True, inputList]
	elif checkIfString(inputList): 
#		if inputList.isnumeric():
		if checkIfStringIsNumeric(inputList):
			return [True, int(inputList)]
		elif re.match(r'^[0-9]+$|^[0-9]+\.[0-9]+$',inputList):
			return [True, float(inputList)]
		else:
			tokenizeLinesResult = tokenizeLines(inputList)
			if tokenizeLinesResult == False:
				errorMessage = "ERROR in getRuntimeValue() tokenizing <%s>"%inputList
				errorRoutine(errorMessage)
				return [False, None]
			else:
				inputList = tokenizeLinesResult[0]
		
	#By now, it must be a list
	if not isinstance(inputList, list):
		return [False, None]
	else:
		parseArithmeticExpressionResult = parseArithmeticExpression(inputList)
		if parseArithmeticExpressionResult == False:
			errorMessage = "ERROR in getRuntimeValue() parsing <%s>"%(STR(inputList))
			errorRoutine(errorMessage)
			return [False,None]
			
		evaluateArithmeticExpressionResult = evaluateArithmeticExpression(parseArithmeticExpressionResult)
		if evaluateArithmeticExpressionResult[0] == False:
			errorMessage = "ERROR in getRuntimeValue() evaluating <%s>"%STR(evaluateArithmeticExpressionResult)
			errorRoutine(errorMessage)
			return [False,None]
		else:
			return [True,evaluateArithmeticExpressionResult[1]]

##################################################################################################################################################################################
# This function returns a tuple of <success/failure, count>. We cannot return a single thing because 0 is same as False in Python, and 0 is a valid return value for this routine
# This function will count ALL the combined occurrences of the same item as only ONE occurrence, and count it only once.
# So, essentially it returns how many of those itemsToCheck actually occur in the inputList
##################################################################################################################################################################################
def totalOccurrenceCount(inputList, itemsToCheck):
	if not inputList:
		errorMessage = "Blank inputList to totalOccurrenceCount()"
		errorRoutine(errorMessage)
		return [False,0]
	elif not isinstance(inputList, list):
		errorMessage = "ERROR - Unknown input object to totalOccurrenceCount() " + STR(inputList) + " - exiting"
		errorRoutine(errorMessage)
		return [False,0]
	elif not itemsToCheck:
		errorMessage = "Blank itemsToCheck to totalOccurrenceCount()"
		errorRoutine(errorMessage)
		return [False,0]
	elif not isinstance(itemsToCheck, list):
		errorMessage = "ERROR - Unknown input object to totalOccurrenceCount() " + STR(itemsToCheck) + " - exiting"
		errorRoutine(errorMessage)
		return [False,0]

	returnStatus = True
	returnCount = 0
	
	for item in itemsToCheck:
		itemCount = 0
		for listItem in inputList:
			if item == listItem:
				itemCount += 1
		if itemCount > 0:
			returnCount += 1
			if itemCount > 1:
				errorMessage = "WARNING: Duplicate "+ STR(item)
				errorRoutine(errorMessage)
				returnStatus = False
	
	return [returnStatus,returnCount]

def noConflictingOccurrences(inputList, itemsToCheck):
	returnStatus = totalOccurrenceCount(inputList, itemsToCheck)
	if returnStatus[0] == False:
		return False
	elif returnStatus[0] == True:
		occurrenceCount = returnStatus[1]
		if occurrenceCount > 1:
			errorMessage = "ERROR: We cannot have conflicting "+ STR(itemsToCheck) +  " in < " + STR(inputList) + " >"
			errorRoutine(errorMessage)
			return False
	return True

#######################################################################################################################################################
# This function takes a list of tokens representing a fragment of single variable declaration statement. It returns a list of two items:
# 1. True / False, depending on whether the syntax is correct or not
# 2. Yet another dictionary. This list will have the following key-values: 
#    a. ["distance"] - the "distance" of of the last token (which should be a ")" - the 2nd one) within this __attribute_(( attributes )) statement 
#       from the first "(" right after the __attribute__ token.
#        Only this key-value pair is mandatory within the dictionary. Rest all are optional
#    b. ["packed"] - should be True, if there
#    c. ["aligned"] - should be a value that is a proper two's power
#######################################################################################################################################################
def parseAttribute(inputList, i=0):
	PRINT ("Inside parseAttribute(inputList=<",inputList,">, i=",i)
	if not inputList:
		OUTPUT ("Blank input to parseAttribute()" )
		errorMessage = "Blank input to parseAttribute()"
		errorRoutine(errorMessage)
		return [False, None]
	elif not isinstance(inputList,list):
		errorMessage = "Input to parseAttribute() is not a list"
		errorRoutine(errorMessage)
		return [False, None]
	elif inputList[i:i+3] != [ATTRIBUTE_STRING,"(","("]:
		errorMessage = "Input to parseAttribute() does not have __attribute__ at index %d - inputList[%d:%d+3] =%s"%(i,i,i,STR(inputList[i:i+3]))
		errorRoutine(errorMessage)
		return [False, None]

	lastIndexToDisplay = i+inputList[i:].index(";") if ";" in inputList[i:] else len(inputList)

	d = matchingBraceDistance(inputList[i+1:])
	
	if d <1 or inputList[i+1+d] != ")" or inputList[i+1+d-1] != ")":
		OUTPUT ("i =",i,"d =",d, "inputList =", inputList[i:lastIndexToDisplay+1])
		errorMessage = "ERROR in parseAttribute() - no matching \"))\" following the __attribute__(( %s"%STR(inputList[i+1:i+1+d+1])
		errorRoutine(errorMessage)
		return [False, None]
	else:
		attributes = {"distance":d}
#		parenthesizedArguments = inputList[i+2:i+1+d]
		
		arguments = inputList[i+3:i+d]
		PRINT ("Going to parse arguments =",arguments)
		
		k = 0
		while (k < len(arguments)):
			PRINT("Currently handling __attribute__((",arguments[k],"))")
			if arguments[k] in (",",")"):
				k += 1
			elif arguments[k] in ("packed","__packed__"):
				attributes[PACKED_STRING] = True
				k += 1
			elif arguments[k] in ("aligned","__aligned__"):
				if k == len(arguments)-1 or arguments[k+1] in (")",",","packed","__packed__"):		# TO-DO: Need to put other keywords here
					attributes[ALIGNED_STRING] = ALIGNED_DEFAULT_VALUE
					k += 1
				elif arguments[k+1] != "(" or ")" not in arguments[k+2:]:
					errorMessage = "ERROR in parseAttribute() - aligned(%s) is not valid"%(STR(arguments[k+1]))
					errorRoutine(errorMessage)
					return [False,attributes]
				else:
					distance = matchingBraceDistance(arguments[k+1:])
					if distance < 1:
						errorMessage = "ERROR in parseAttribute() - aligned(%s) is not valid due to no end brace"%(STR(arguments[k+1:]))
						errorRoutine(errorMessage)
						return [False,attributes]
					else:
						item = arguments[k+2:k+1+distance]
						PRINT("Currently going to resolve the item=",item)
						parseArithmeticExpressionResult = parseArithmeticExpression(item)
						if parseArithmeticExpressionResult == False:
							errorMessage = "ERROR in parseAttribute() - error calling parseArithmeticExpression(parenthesized alignment value of = <%s> "%(STR(item), STR(parseArithmeticExpressionResult))
							errorRoutine(errorMessage)
							return [False,attributes]
						else:
							evaluateArithmeticExpressionResult = evaluateArithmeticExpression(parseArithmeticExpressionResult)
							if evaluateArithmeticExpressionResult[0] != True:
								errorMessage = "ERROR in parseAttribute() - error calling evaluateArithmeticExpression(AST = <%s>) after an aligned statement"%(STR(parseArithmeticExpressionResult))
								errorRoutine(errorMessage)
								return [False,attributes]
							else:
								result = evaluateArithmeticExpressionResult[1]
								if not checkIfIntegral(result) or result <1:
									errorMessage = "ERROR in parseAttribute() - output (%s) from evaluateArithmeticExpression() after a __attribute__((aligned)) statement is not integral or <1"%(STR(result))
									errorRoutine(errorMessage)
									return [False,attributes]
								elif result & (result-1) != 0:	# check that it is proper power of 2
									errorMessage = "ERROR in parseAttribute() - output (%s) from evaluateArithmeticExpression() after a __attribute__((aligned)) statement must be a power of 2"%(STR(result))
									errorRoutine(errorMessage)
									return [False,attributes]
								elif ALIGNED_STRING in getDictKeyList(attributes):
									attributes[ALIGNED_STRING] = max(result,attributes[ALIGNED_STRING])
									PRINT("Assigned the result =",result,"to the aligned, while the content of current pragmaPackStack is",pragmaPackStack)
									k = k+1+distance
								else:
									attributes[ALIGNED_STRING] = result
									PRINT("Assigned the result =",result,"to the aligned, while the content of current pragmaPackStack is",pragmaPackStack)
									k = k+1+distance
			else:
				errorMessage = "ERROR in parseAttribute() - unsupported arguments[k=%d] in __aligned__ ((%s))"%(k,STR(arguments[k]))
				errorRoutine(errorMessage)
				return [False,attributes]
				
				
		PRINT ("For the inputList = <", flattenList(inputList[i:i+1+d+1]),"> Returning attributes =",attributes)
		return [True,attributes]
								



	
#######################################################################################################################################################
# This function takes a list of tokens representing a single variable declaration statement, and returns the index where its type specifier ends;
# Basically, the very next token should be either the "*", "(" or the variable identifier itself.
# For example, for this statement <singed long int i;>, it will return 2
#######################################################################################################################################################
def findTypeSpecifierEndIndex(inputList):
	global structuresAndUnions, suDict
	typeSpecifierEndIndex = -1000		# Invalid value. We cannot return False, since False is same as 0 in Python, and 0 is valid return value.
	if not inputList:
		PRINT ("Blank input to findTypeSpecifierEndIndex()" )
		return typeSpecifierEndIndex
	elif not isinstance(inputList,list):
		PRINT ("ERROR - Unknown input object to findTypeSpecifierEndIndex()", inputList," - exiting" )
		return typeSpecifierEndIndex

	baseTypeSpecifier = ['void','char','short','int','long','float','double', 'long long']
	typeSpecifierImplicit = ['signed','unsigned']     # TO-DO: need to add <struct-or-union-specifier> <enum-specifier> <typedef-name>
#	storageClassSpecifier = [ 'auto','register','static','extern','typedef']	#just keep them here to tell you what they are
#	typeQualifier = ['const','volatile']										#just keep them here to tell you what they are
	
	#TO-DO: add the typedefs too
	derivedTypeSpecifier = []
	if typedefs:
		derivedTypeSpecifier.extend(getDictKeyList(typedefs))

#	if typedefsBuiltin:
#		derivedTypeSpecifier.extend(getDictKeyList(typedefsBuiltin))
		
	# Currently not using, since this list will be changing dynamically
	typeSpecifier = deepCopy(baseTypeSpecifier)
	if derivedTypeSpecifier:
		typeSpecifier.extend(derivedTypeSpecifier[:])

	# We take a rather conservative approach in parsing the __attribute__ statements. You see, there can be multiple __attribute__ statements inside a single
	# variable declaration, and they can appear at a number of places.
	i = 0
	while i<len(inputList):
		if inputList[i] == ATTRIBUTE_STRING:
			parseAttributeResult = parseAttribute(inputList[i:])
			if parseAttributeResult[0] != True:
				errorMessage = "ERROR in findTypeSpecifierEndIndex() after calling parseAttribute()"
				errorRoutine(errorMessage)
				return typeSpecifierEndIndex
			else:
				d = parseAttributeResult[1]["distance"]
				typeSpecifierEndIndex = i+1+d
				i = typeSpecifierEndIndex
		# TO-DO - to add the other qualifiers with the struct/union declaration
		elif inputList[i] == "enum":
			if inputList[i+1] not in getDictKeyList(enums):
				OUTPUT ("ERROR in findTypeSpecifierEndIndex() - enum", inputList[i+1]," has no previous declaration - exiting" )
				return typeSpecifierEndIndex
			else:
				typeSpecifierEndIndex = i+1
				i = typeSpecifierEndIndex
		# I am not exactly sure whether I should add code for the re-definition of the same struct
		# TO-DO
		elif inputList[i] == "struct" or inputList[i] == "union":
			lastItemConsumedIndex = i
			# There might be multiple __attribute__ statements right after the struct/union keyword
			while inputList[lastItemConsumedIndex+1] == ATTRIBUTE_STRING:
				parseAttributeResult = parseAttribute(inputList[lastItemConsumedIndex+1:])
				if parseAttributeResult[0] != True:
					errorMessage = "ERROR in findTypeSpecifierEndIndex() after calling parseAttribute()"
					errorRoutine(errorMessage)
					return typeSpecifierEndIndex
				else:
					d = parseAttributeResult[1]["distance"]	# Distance of the last brace from the first brace within the __attribute__ (( ...  )) statement
#					lastItemConsumedIndex = lastItemConsumedIndex+1+d		# Possible bug????
					lastItemConsumedIndex = lastItemConsumedIndex+1+d+1
			if inputList[lastItemConsumedIndex+1] != "{":
				lastItemConsumedIndex = lastItemConsumedIndex + 1
				structName = inputList[lastItemConsumedIndex]
				structOrUnionType = inputList[i]
				if inputList[lastItemConsumedIndex] not in getDictKeyList(suDict):
					PRINT ("ERROR: in findTypeSpecifierEndIndex() - struct", inputList[lastItemConsumedIndex+1]," has no previous declaration - hopefully it will be declared later" )
					PRINT ("Adding the empty declaration of struct",structName," to the structuresAndUnions array in findTypeSpecifierEndIndex()")
					structuresAndUnions.append({"name":structName})
					suDict[structName] = [len(structuresAndUnions)-1]
#				else:
#					structuresAndUnions.append({"name":structName})
#					suDict[structName].append(len(structuresAndUnions)-1)
					suDictCount = 0
					for key in getDictKeyList(suDict):
						if not isinstance(suDict[key], list) or len(suDict[key])==0:	# Sanity check
							errorMessage = "ERROR in findTypeSpecifierEndIndex(): For structName "+key+" , entry ("+STR(suDict[key])+") exists in suDict but it is illegal (not a proper list)"
							errorRoutine(errorMessage)
							sys.exit()
						else:
							suDictCount += len(suDict[key])
					if len(structuresAndUnions) != suDictCount:
						errorMessage = "ERROR in findTypeSpecifierEndIndex(): len(structuresAndUnions) = "+STR(len(structuresAndUnions))+" while len(getDictKeyList(suDict)) = "+STR(len(getDictKeyList(suDict)))+ " !!!"
						errorRoutine(errorMessage)
						sys.exit()
					structuresAndUnions[suDict[structName][-1]]["type"] = structOrUnionType
					structuresAndUnions[suDict[structName][-1]]["structId"] = suDict[structName][-1]
					structuresAndUnions[suDict[structName][-1]]["parentStructName"] = "--Global--"
					structuresAndUnions[suDict[structName][-1]]["components"] = []
			typeSpecifierEndIndex = lastItemConsumedIndex
			i = typeSpecifierEndIndex
		elif ((inputList[i] in baseTypeSpecifier) or (inputList[i] in derivedTypeSpecifier) or (inputList[i] in typeSpecifierImplicit) 
			or (inputList[i] in storageClassSpecifier) or (inputList[i] in typeQualifier) or (inputList[i] in getDictKeyList(typedefs))) :
			typeSpecifierEndIndex = i
		else:
			break
		i = i+1
		
	PRINT ("From findTypeSpecifierEndIndex(), returning return value of ",typeSpecifierEndIndex,"for inputList =",STR(inputList) )
	return typeSpecifierEndIndex

#######################################################################################################################################################
#This function takes a list of tokens representing a single variable declaration statement, and checks its legality and calculates its size on stack;
#######################################################################################################################################################
def parseVariableDeclaration(inputList):
#	PRINT=OUTPUT
	global typedefs, structuresAndUnions, suDict, dummyUnnamedBitfieldCount
	PRINT ("="*30,"\nInside parseVariableDeclaration()\n","="*30,"\n" )
	PRINT ("inputList =",inputList )
	if not inputList:
		return False
	elif checkIfString(inputList):
		tokenizeLinesResult = tokenizeLines(inputList)
		if tokenizeLinesResult == False:
			PRINT ("ERROR in parseVariableDeclaration after calling tokenizeLines(inputList) for inputList (actually a string) =",inputList )
			return False
		else:
			tokenizeLinesOutput = tokenizeLinesResult[0]
			return parseVariableDeclaration(tokenizeLinesOutput)
	elif not isinstance(inputList,list):
		PRINT ("ERROR - Unknown input object to parseVariableDeclaration()", inputList," - exiting" )
		return False
		sys.exit()

	functionCheckResult = checkIfFunctionDefinition(inputList)
	if functionCheckResult[0]==False and ";" not in inputList:
		PRINT ("No semicolon in inputList" )
		errorMessage = "ERROR in parseVariableDeclaration() - every variable declaration must end with a semicolon - exiting"
		errorRoutine(errorMessage)
		return False
#				sys.exit()
	declarationEndIndex = len(inputList)
	if ';' in inputList:
		nextSemicolonIndex = inputList.index(";")
		declarationEndIndex = nextSemicolonIndex
	if functionCheckResult[0]==True:
		functionDeclarationEndIndex = functionCheckResult[1]
		declarationEndIndex = functionDeclarationEndIndex if functionDeclarationEndIndex < declarationEndIndex else declarationEndIndex
	
	if len(inputList) <3:
		PRINT ("ERROR in parseVariableDeclaration() - A variable declaration statement must have at least 3 terms" )
		return False
		sys.exit()
	elif inputList[declarationEndIndex] not in (";","}"):
		PRINT ("ERROR in parseVariableDeclaration() - A variable declaration statement must end with a semicolon" )
		return False
		sys.exit()
	elif not braceInterleavingLegal(inputList[:declarationEndIndex+1]):
		PRINT ("ERROR in parseVariableDeclaration() - A variable declaration statement contains braces that are not interleaved properly" )
		return False
		sys.exit()
		
	typeSpecifierEndIndex = findTypeSpecifierEndIndex(inputList)
	
	PRINT ("After calling findTypeSpecifierEndIndex() for inputList = ",STR(inputList),", the result typeSpecifierEndIndex =",typeSpecifierEndIndex )
	
	# Now that we know where the "base" type specifier ends, we perform a battery of checks to see if this is valid.
	
	if typeSpecifierEndIndex < 0:
		PRINT ("typeSpecifierEndIndex =",typeSpecifierEndIndex )
		errorMessage = "ERROR in parseVariableDeclaration() calling findTypeSpecifierEndIndex() for inputList = "+STR(inputList)
		errorRoutine(errorMessage)
		return False
	
	if 	typeSpecifierEndIndex <0 or typeSpecifierEndIndex > len(inputList)-3:	# The last two items must be at the minimum 2 items before the end of statement;
		PRINT ("ERROR in parseVariableDeclaration() - not enough tokens left after type specifier at typeSpecifierEndIndex=",typeSpecifierEndIndex,"for inputList =",inputList )
		PRINT ("inputList = ",inputList,"typedefs =",typedefs,"typedefs.keys() =",getDictKeyList(typedefs) )
		return False
		sys.exit()
	
	typeSpecifierList = inputList[:typeSpecifierEndIndex+1]

	baseTypeSpecifier = ['void','char','short','int','long','long long','float','double']
	typeSpecifierImplicit = ['signed','unsigned']     # TO-DO: need to add <struct-or-union-specifier> <enum-specifier> <typedef-name>
#	storageClassSpecifier = [ 'auto','register','static','extern','typedef']
#	typeQualifier = ['const','volatile']
	
	regularTypes = baseTypeSpecifier + typeSpecifierImplicit

	baseType = ""
	signedOrUnsigned = "signed"		# Default value

	# PORT: Another difference between PYTHON 2 and 3. For a dict.keys() yields a list for Python 2, but class of "dict_keys" for Python 3
	PRINT ("type(typedefs.keys()) = ",type(typedefs.keys()))
	PRINT ("type(enums.keys()) = ",type(enums.keys()))

	PRINT("typeSpecifierList =",typeSpecifierList)
	PRINT("getDictKeyList(suDict) =",getDictKeyList(suDict))

	# First check if there is any derived type
	derivedTypesIntypeSpecifierList 	= commonItems(typeSpecifierList, getDictKeyList(typedefs))
	structUnionTypesIntypeSpecifierList = commonItems(typeSpecifierList, getDictKeyList(suDict))
	enumTypesIntypeSpecifierList 		= commonItems(typeSpecifierList, getDictKeyList(enums))
	regularTypesIntypeSpecifierList 	= commonItems(typeSpecifierList, regularTypes)
	
	if derivedTypesIntypeSpecifierList:
		errorMessage = "ERROR in parseVariableDeclaration() for inputList = <%s> - we should never see any derived type (%s) in this routine, because all derived typed should have been re-converted into their original typedef form before "%(STR(inputList),STR(derivedTypesIntypeSpecifierList))
		errorRoutine(errorMessage)
		return False

	# Derived type - I coded this originally without realizing that this routine should never see any derived type. Still leaving it since no harm
	if len(derivedTypesIntypeSpecifierList)>1:
		errorMessage = "ERROR in parseVariableDeclaration(): We have multiple derived types (" + STR(derivedTypesIntypeSpecifierList) + ") for the same type declaration < " + STR(typeSpecifierList) + " >"
		errorRoutine(errorMessage)
		return False
	elif len(derivedTypesIntypeSpecifierList)==1:
		# For a derived type, we should not have any re-declaration
		if structUnionTypesIntypeSpecifierList or regularTypesIntypeSpecifierList:
			errorMessage = "ERROR in parseVariableDeclaration(): We have re-declaration (" + STR(structUnionTypesIntypeSpecifierList + regularTypesIntypeSpecifierList) + ") of already-derived type (" + STR(derivedTypesIntypeSpecifierList) + ") for the declaration < " + STR(typeSpecifierList) + " >"
			errorRoutine(errorMessage)
			return False
		else:
			baseType = derivedTypesIntypeSpecifierList[0]

	
	elif len(structUnionTypesIntypeSpecifierList)>1:	# pre-defined struct / union
		errorMessage = "ERROR in parseVariableDeclaration(): We have multiple struct/union types (" + STR(structUnionTypesIntypeSpecifierList) + ") for the same type declaration < " + STR(typeSpecifierList) + " >"
		errorRoutine(errorMessage)
		return False
	elif len(structUnionTypesIntypeSpecifierList)==1:
		# For a derived type, we should not have any re-declaration
		if regularTypesIntypeSpecifierList or enumTypesIntypeSpecifierList or derivedTypesIntypeSpecifierList:	# Checking for derivedTypesIntypeSpecifierList should be redundant
			errorMessage = "ERROR in parseVariableDeclaration(): We have re-declaration (" + STR(regularTypesIntypeSpecifierList) + STR(enumTypesIntypeSpecifierList) + STR(derivedTypesIntypeSpecifierList)+ ") of already-derived type (" + STR(structUnionTypesIntypeSpecifierList) + ") for the declaration < " + STR(typeSpecifierList) + " >"
			errorRoutine(errorMessage)
			return False
		else:
			baseType = structUnionTypesIntypeSpecifierList[0]

	elif len(enumTypesIntypeSpecifierList)>1:	# pre-defined enums
		errorMessage = "ERROR in parseVariableDeclaration(): We have multiple enum types (" + STR(enumTypesIntypeSpecifierList) + ") for the same type declaration < " + STR(typeSpecifierList) + " >"
		errorRoutine(errorMessage)
		return False
	elif len(enumTypesIntypeSpecifierList)==1:
		# For a derived type, we should not have any re-declaration
		if regularTypesIntypeSpecifierList or structUnionTypesIntypeSpecifierList or derivedTypesIntypeSpecifierList:	# Checking for derivedTypesIntypeSpecifierList should be redundant
			errorMessage = "ERROR in parseVariableDeclaration(): We have re-declaration (" + STR(regularTypesIntypeSpecifierList) + STR(structUnionTypesIntypeSpecifierList) + STR(derivedTypesIntypeSpecifierList)+ ") of already-derived type (" + STR(structUnionTypesIntypeSpecifierList) + ") for the declaration < " + STR(typeSpecifierList) + " >"
			errorRoutine(errorMessage)
			return False
		else:
#			baseType = enumTypesIntypeSpecifierList[0]
			baseType = "int"

	
	elif regularTypesIntypeSpecifierList:	# Regular declarations

		if noConflictingOccurrences(typeSpecifierList, ["float","double"]) == False:
			return False
		elif "float" in typeSpecifierList or "double" in typeSpecifierList:
			baseType = "float" if "float" in typeSpecifierList else "double"
			items2check = ["signed","unsigned","short","long","long long","char","int","void"]
			for item in items2check:
				if item in typeSpecifierList:
					errorMessage = "ERROR in parseVariableDeclaration(): for a base type of " + STR(baseType) + ", we cannot have conflicting " + STR(item) + " in type declaration < " + STR(typeSpecifierList) + " >"
					errorRoutine(errorMessage)
					return False
		if noConflictingOccurrences(typeSpecifierList, ["char","void"]) == False:
			return False
		elif "char" in typeSpecifierList or "void" in typeSpecifierList:
			baseType = "char" if "char" in typeSpecifierList else "void"
			items2check = ["short","int","long","long long"]
			for item in items2check:
				if item in typeSpecifierList:
					errorMessage = "ERROR in parseVariableDeclaration(): for a base type of " + STR(baseType) + ", we cannot have conflicting " + STR(item) + " in type declaration < " + STR(typeSpecifierList) + " >"
					errorRoutine(errorMessage)
					return False
		elif noConflictingOccurrences(typeSpecifierList, ["short","long","long long"]) == False:
			return False
		elif commonItems(typeSpecifierList,["short","long","long long"]):
			baseType = "short" if "short" in typeSpecifierList else "long" if "long" in typeSpecifierList else "long long"
		elif "int" in typeSpecifierList or "signed" in typeSpecifierList or "unsigned" in typeSpecifierList:
			baseType = "int"
		
		if baseType in ("char","short","int","long","long long"):
			if noConflictingOccurrences(typeSpecifierList, ["signed","unsigned"]) == False:
				return False
			elif "unsigned" in inputList[:typeSpecifierEndIndex+1]:
				signedOrUnsigned = "unsigned"

		# At this point, the baseType should be populated

		# It should never come here
	else:
		OUTPUT ("\n","==="*50)
		OUTPUT ("ERROR in parseVariableDeclaration(): The control should never have come here")
		OUTPUT ("typeSpecifierEndIndex =",typeSpecifierEndIndex,", typeSpecifierList =",typeSpecifierList)
		OUTPUT ("typedefs.keys() =", getDictKeyList(typedefs))
		OUTPUT ("derivedTypesIntypeSpecifierList =", derivedTypesIntypeSpecifierList)
		OUTPUT ("suDict.keys() =", getDictKeyList(suDict))
		OUTPUT ("structUnionTypesIntypeSpecifierList =",structUnionTypesIntypeSpecifierList)
		OUTPUT ("enums.keys() =", getDictKeyList(enums))
		OUTPUT ("enumTypesIntypeSpecifierList =",enumTypesIntypeSpecifierList)
		OUTPUT ("regularTypes =", regularTypes)
		OUTPUT ("regularTypesIntypeSpecifierList =",regularTypesIntypeSpecifierList)
		errorMessage = "ERROR in coding: Cannot resolve type declaration " + STR(typeSpecifierList)
		errorRoutine(errorMessage)
		return False

	PRINT ("Value of baseType =<" + STR(baseType) + "> in typeSpecifierList =<" + STR(typeSpecifierList) + ">")


	# Now, if there are any __attribute__ statements up to the typeSpecifierEndIndex, get their outputs.
	baseAttributes = {}		# This applies to ALL the variables declared by a single vairable declaration statement
	variableSpecificAttributes = {}		# This only applies to individual variables. This is additive to the baseAttributes
	
	k = 0
	while (k <= typeSpecifierEndIndex):
		if inputList[k] != ATTRIBUTE_STRING: 
			k += 1
		else:
			parseAttributeResult = parseAttribute(inputList[k:typeSpecifierEndIndex+1])
			if parseAttributeResult[0] != True:
				errorMessage = "ERROR in parseVariableDeclaration() after calling parseAttribute() for inputList[k(%d):typeSpecifierEndIndex(%d)+1] = <%s>]"%(k,typeSpecifierEndIndex,STR(inputList[k:typeSpecifierEndIndex+1]))
				errorRoutine(errorMessage)
				return False
			else:
				PRINT("parseAttributeResult[1] = ",parseAttributeResult[1])
				for (key, value) in parseAttributeResult[1].items():
					if (key == ALIGNED_STRING) and (ALIGNED_STRING in getDictKeyList(baseAttributes)):
						baseAttributes[key] = max(value, baseAttributes[key])
					else:
						baseAttributes[key] = value		# Yes, this will overwrite existing values, but we do not care
				d = parseAttributeResult[1]["distance"]
				k += 1+d+1

	PRINT ("baseAttributes =",baseAttributes)

	if (baseType == ""):
		errorMessage = "ERROR in parseVariableDeclaration(): Somehow illegal value of baseType =<" + STR(baseType) + "> in typeSpecifierList =<" + STR(typeSpecifierList) + ">"
		errorRoutine(errorMessage)
		return False

	i = typeSpecifierEndIndex+1
	
	declarationStatementEndReached = False
	
	# Now we have gotten the main variable type. Now, there might be multiple variable names defined in the same declaration statement.
	# Some of those variables might be pointers too.
	# We presume that every such declaration segment has a <leftBoundary>.
	# The rightBoundary will be a semicolon, comma, or a "=" when we are initializing
	
	returnListOf5tuples = []

	# For the first declaration
	leftBoundary = typeSpecifierEndIndex
	
	while i<len(inputList) and declarationStatementEndReached == False:
		# This code snippet below assumes that we have LEGAL C code. It will not work if you give it illegal C code where we have non-contiguous *
		# TO-DO: Handle that case
		
		PRINT ("\n\n","==="*50,"\nStarting new cycle of parsing from inputList[",i,"] = ", inputList[i],"\n","==="*50,"\n" )

		isBitField	= False
		isInitialized = False
		currentDeclarationSegmentStartIndex = i
		
		# There might be multiple levels of indirections and parenthesization. The first item not like that is the variable name.
		# TO-DO: Verify that this is indeed the correct assumption
		while True:
			if inputList[i] == "*" or inputList[i] == "(" : # TO-DO: const might appear here too
				i = i+1
			elif inputList[i] == ATTRIBUTE_STRING:
				parseAttributeResult = parseAttribute(inputList[i:])
				if parseAttributeResult[0] != True:
					errorMessage = "ERROR in parseVariableDeclaration() after calling parseAttribute() for inputList[i(%d):] = <%s>]"%(i,STR(inputList[i:]))
					errorRoutine(errorMessage)
					return False
				else:
					PRINT("parseAttributeResult[1] = ",parseAttributeResult[1])
					for (key, value) in parseAttributeResult[1].items():
						if key == ALIGNED_STRING and ALIGNED_STRING in getDictKeyList(variableSpecificAttributes):
							variableSpecificAttributes[key] = max(variableSpecificAttributes[key],value)
						else:
							variableSpecificAttributes[key] = value		
					d = parseAttributeResult[1]["distance"]
					i += 1+d+1
			else:
				break
		PRINT ("variableSpecificAttributes =",variableSpecificAttributes)
		
		if inputList[i] == "[" or inputList[i] == "[]" :
			PRINT("inputList =",inputList)
			errorMessage = "ERROR in parseVariableDeclaration(): Cannot have array on the base type itself: expected identifier or '(' before '[' token in inputList =<"+STR(inputList)+">"
			errorRoutine(errorMessage)
			return False
		
		# TO-DO: No variable name (bitwise alignment)
		variableNameIndex =  i
		variableName = inputList[variableNameIndex]
		
		if inputList[i] == ':':
			# Recall that the bitfield width need not be a straightaway number - it could be an arithmatic expression too
			if i+2 < len(inputList) and ('=' in inputList[i+2:] or ',' in inputList[i+2:] or ';' in inputList[i+2:]):
				PRINT("Found case of unnamed bitfield specifier (resets the bitfield boundary)");
				variableName = dummyUnnamedBitfieldNamePrefix + STR(dummyUnnamedBitfieldCount)
				dummyUnnamedBitfieldCount += 1
			else:
				errorMessage = "ERROR in parseVariableDeclaration(): Illegal usage of <:> in bitfield specification for inputList =<"+STR(inputList)+">"
				errorRoutine(errorMessage)
				return False
		elif not re.match("^[_a-zA-Z]+[_0-9a-zA-Z]*",inputList[i]):
			errorMessage = "ERROR in parseVariableDeclaration(): <"+ STR(inputList[i])+"> is not a valid identifier name in inputList =<"+STR(inputList)+">"
			errorRoutine(errorMessage)
			return False
		
		if baseType in getDictKeyList(suDict) and "isDynamic" in getDictKeyList(structuresAndUnions[suDict[baseType][-1]]):
			isDynamic = structuresAndUnions[suDict[baseType][-1]]["isDynamic"]
		else:
			isDynamic = False			# Defaulting it for every declared variable
#		arrayDimensions2 = []		# Blank for a non-array variable
		variableDescription = variableName + " is"
		PRINT ("\n\n=======================================\nvariableNameIndex = ",variableNameIndex," variable name = ", variableName,"\n=======================================\n\n" )

		
		# The Q &D is to begin with the variable name, scan rightward until you hit a ")", then go back to the variable name and scan leftward until you hit a "(".
		# Then "step out" of the pair of braces, and repeat the process. For example, let's examine this really weird declaration:
		#
		#         void **(*(*weird)[6])(char, int);
		#
		# weird is a pointer to an array of 6 pointers to functions, each function accepting a char and an int as argument, and each returning a pointer to a pointer to void.
		#
		#
		# 		int (*Weirder(const char code)) (int, float) ;
		#
		# Weirder is a function that takes in a char as its argument, and returns a pointer to a function (basically a function pointer) 
		# that takes in (int, float) as its argument and returns an int.
		#

		# The way we implement this as follows. We need to "consume" the inputList[leftBoundary+1:]
		# There are two "counters" (I am not using the term pointer to avoid confusion). The "right" counter moves to the right, the "left" counter moves left.
		# Every time they move, they "consume" tokens. Once the "left" counter reaches leftBoundary and the "right" counter reaches the end, we are done;
		
#		PRINT ("Going to check the legal interleaving of braces in inputList[leftBoundary+1:] = inputList[",leftBoundary,"+1:] =",inputList[leftBoundary+1:], "has unmatched braces" )
		
		if not braceInterleavingLegal(inputList[leftBoundary+1:]):
			errorMessage = "ERROR in parseVariableDeclaration() - the inputList[leftBoundary+1:] =" + STR(inputList[leftBoundary+1:]) + "has unmatched braces" 
			errorRoutine(errorMessage)
			return False
			
		
		# Usually, we start scanning both to the left and right from the variableNameIndex. However, for zero-width bitfield, there is no variableNameIndex.
		leftCounterPrevious = leftCounter = variableNameIndex
		if variableName.startswith(dummyUnnamedBitfieldNamePrefix):
			rightCounterPrevious = rightCounter = variableNameIndex -1
		else:
			rightCounterPrevious = rightCounter = variableNameIndex
		
		while (leftCounter>leftBoundary and rightCounter<len(inputList)-1):
			# First scan to the right
			rightCounter = rightCounter + 1
			if inputList[rightCounter]==")":
				if matchingBraceDistanceReverse(inputList[:rightCounter+1]) < 1:
					errorMessage = "ERROR in parseVariableDeclaration(): Cannot find matching brace in reverse in " +STR(matchingBraceDistanceReverse(inputList[:rightCounter+1]))+ " - exiting!!" 
					errorRoutine(errorMessage)
					return False
				leftCounter = rightCounter - matchingBraceDistanceReverse(inputList[:rightCounter+1])
				if leftCounter >= leftCounterPrevious:	# Should never happen
					PRINT ("ERROR - leftCounter =", leftCounter, "leftCounterPrevious =",leftCounterPrevious )
					sys.exit()
				if leftCounter < leftCounterPrevious:	# Should always happen
					# Verify that all intermediate tokens are '*' only
					k = leftCounter + 1
					while k < leftCounterPrevious:
						if inputList[k] == "*":
							variableDescription = variableDescription + " pointer to "
						else:
							errorMessage = "ERROR in parseVariableDeclaration() - unexpected token inputList["+STR(k)+"] =" + STR(inputList[k])
							errorRoutine(errorMessage)
							return False
						k = k + 1
				leftCounterPrevious = leftCounter
				rightCounterPrevious = rightCounter
			elif inputList[rightCounter]=="[" or inputList[rightCounter]=="[]":
				PRINT ("\n\n\nHit an array - Currently, variableDescription =<%s>\n\n\n"%variableDescription)
				# We need to handle the case that a function cannot return an array.
				str2search = "and returns a "
				if len(variableDescription)>len(str2search) and ("function" in variableDescription) and (variableDescription[-len(str2search):]==str2search):
					errorMessage = "ERROR in parseVariableDeclaration() - the inputList =" + STR(inputList) + " has a function returning an array" 
					errorRoutine(errorMessage)
					return False
				 
			
				# We have a problem of when a multi-dimensional array is declared with parenthesis in between the array dimensions, like int (a[2])[3]; instead of just int a[2][3];
				# In that case, instead of producing "array of size 2 X 3", the code might produce "array of size 2 array of size 3".
				# To prevent this kind of things, we first check if the current variableDescription is already ending with array declaration (like "array of size 2".
				# If yes, instead of adding yet another "array of size 3", we just add " X 3".
				if re.search(r" array of size\s+\d+(\s+X\s+\d+)*\s*$",variableDescription):
					PRINT ("variableDescription = <%s> currently ends with an \"array of size N\" kind of statement"%variableDescription )
					variableDescription = variableDescription + " X "
				else:
					PRINT ("variableDescription = <%s> does not end with an \"array of size N\" kind of statement"%variableDescription )
					variableDescription = variableDescription + " array of size "
				k = rightCounter
				dimensionCount = 0
				# Our current tokenizer combines "()" or "[]" into a single token if there is no space in between (TO-DO)
				while (inputList[k]=="[" or inputList[k]=="[]"):
					dimensionCount = dimensionCount + 1		# starts from 1, not zero
					if inputList[k]=="[]": # Array size NOT specified
						matchingBraceIndex = k
						PRINT ("Array size NOT specified for ARRAY variable",variableName )
						if dimensionCount > 1:
							PRINT ("ERROR in parseVariableDeclaration() - array size must be specified for array level",dimensionCount )
							errorMessage = "ERROR in parseVariableDeclaration() - array size must be specified for array level "+STR(dimensionCount)
							errorRoutine(errorMessage)
							return False
						else:
							variableDescription = variableDescription + "TBD"
					else:
						if matchingBraceDistance(inputList[k:]) < 1:
							errorMessage = "ERROR in parseVariableDeclaration() - Cannot find matching brace distance for "+STR(inputList[k:])
							errorRoutine(errorMessage)
							return False
						matchingBraceIndex = k + matchingBraceDistance(inputList[k:])
#						PRINT ("matchingBraceIndex =",matchingBraceIndex )
						if dimensionCount > 1:
							variableDescription = variableDescription + " X "
						# This code block below will never be hit in our current Tokenizer (which considers "[]" a single token), still kept for future-proofing
						if matchingBraceIndex == k+1: # Array size NOT specified
							PRINT ("Array size NOT specified for array variable <",variableName,">" )
							if dimensionCount > 1:
								errorMessage = "ERROR in parseVariableDeclaration() - array size must be specified for array level "+STR(dimensionCount)
								errorRoutine(errorMessage)
								return False
							else:
								variableDescription = variableDescription + "TBD"
						else:
							# Remember that we cannot just pass an expression directly to evaluateArithmeticExpression() - we have to pass an AST
							currentArrayDimensionTokens = inputList[k+1:matchingBraceIndex]
							parseArithmeticExpressionOutput = parseArithmeticExpression(currentArrayDimensionTokens)
							if parseArithmeticExpressionOutput == False:
								errorMessage = "ERROR in parseVariableDeclaration() after calling parseArithmeticExpression(inputList[k+1:matchingBraceIndex]) for inputList["+STR(k)+"+1:"+STR(matchingBraceIndex)+"] = "+STR(currentArrayDimensionTokens)
								errorRoutine(errorMessage)
								return False
							else:
								evaluateArithmeticExpressionOutput = evaluateArithmeticExpression(parseArithmeticExpressionOutput)
								PRINT("evaluateArithmeticExpression(parseArithmeticExpressionOutput=",parseArithmeticExpressionOutput,") is evaluateArithmeticExpressionOutput =",evaluateArithmeticExpressionOutput)
								if evaluateArithmeticExpressionOutput[0] != True:
									PRINT ("ERROR while calculating array dimensions, after calling evaluateArithmeticExpression(parseArithmeticExpressionOutput) for parseArithmeticExpressionOutput =",parseArithmeticExpressionOutput )
									errorMessage = "ERROR in parseVariableDeclaration() - for variable " + variableName + ", array dimension <%s> not a proper arithmetic expression"%STR(inputList[k+1:matchingBraceIndex])
									errorRoutine(errorMessage)
									return False
								elif evaluateArithmeticExpressionOutput[1] == LOGICAL_TEST_RESULT_INDETERMINATE:	# Dynamic array
									isDynamic = True
									PRINT("STR(currentArrayDimensionTokens) = <"+STR(currentArrayDimensionTokens)+">")
									# Do not use STR(currentArrayDimensionTokens) straightaway, since that will print the listified version of the string.
									# For example, if we have the array dimension specified as a+b (where a and b are variables we do not know the value),
									# then we want to add just a+b in the variableDescription. If we add STR(currentArrayDimensionTokens), then we will be
									# adding the following string instead:		['a', '+', 'b']
									# This will create problem later since we will be splitting the variable string based on space.
									currentArrayDimensionTokensString = ""
									for token in currentArrayDimensionTokens:
										# If the current word ends with a alphanumeric character and the next token starts with one, insert a $ which we will remove later.
										# This is a kludge, because we need to remove ALL spaces from the variable array dimension expression, but for expressions like this:
										# 		int i[(unsigned char)c], j[c + 2];
										# If we remove all the spaces from the dimension, for the j we will be fine since we will get "c+2". But for i we will get "(unsignedchar)c"
										# which is NOT fine. So, we insert an artificial separator.
										if currentArrayDimensionTokensString and re.match(r'^.*[a-zA-Z0-9_]$',currentArrayDimensionTokensString) and re.match(r'^[a-zA-Z0-9_].*$',token):
											currentArrayDimensionTokensString += '$'
										currentArrayDimensionTokensString += token
									variableDescription = variableDescription + currentArrayDimensionTokensString
#									arrayDimensions2.append(currentArrayDimensionTokens)
								elif evaluateArithmeticExpressionOutput[1] <1:
									errorMessage = "ERROR in parseVariableDeclaration() - for variable " + variableName + ", array dimension <%s> evaluates to %d, which is not allowed"%(list2plaintext(inputList[k+1:matchingBraceIndex]),evaluateArithmeticExpressionOutput[1])
									errorRoutine(errorMessage)
									return False
								else:
									variableDescription = variableDescription + str(evaluateArithmeticExpressionOutput[1])
#									arrayDimensions2.append(evaluateArithmeticExpressionOutput[1])
									
					k = matchingBraceIndex + 1
				rightCounter = matchingBraceIndex
				rightCounterPrevious = rightCounter
			# Our current tokenizer combines "()" or "[]" into a single token (TO-DO)
			elif inputList[rightCounter]=="(" or inputList[rightCounter]=="()":
#				PRINT ("pointer to " )
				rightCounterPrevious = rightCounter
				if inputList[rightCounter]=="()":
					variableDescription = variableDescription + " of type function that accepts no Argument and returns a "
				else:
					if matchingBraceDistance(inputList[rightCounter:]) < 1:
						errorMessage = "ERROR in parseVariableDeclaration() - for variable " + variableName + ", No match for %s ... exiting"%STR(inputList[rightCounter:])
						errorRoutine(errorMessage)
						return False
					rightCounter = rightCounter + matchingBraceDistance(inputList[rightCounter:])
					argList = parseArgumentList(inputList[rightCounterPrevious:rightCounter+1])
					if argList == False:
						PRINT ("Error while parsing the argument list in ",inputList[rightCounterPrevious:rightCounter+1]," - exiting!" )
						errorMessage = "ERROR in parseVariableDeclaration() - for variable " + variableName + ", error while parsing the argument list in %s - exiting!"%STR(inputList[rightCounterPrevious:rightCounter+1])
						errorRoutine(errorMessage)
						return False
					variableDescription = variableDescription + " of type function that accepts Argument list "  + str(argList) + " and returns a "
				rightCounterPrevious = rightCounter
		
			########################################################################################
			# Handle bitfields		
			#########################################################################################
			elif inputList[rightCounter]==":":

				# TO-DO: Need to handle the case of no-variable-name bitfield (only for aligning)

			
				rightCounter = rightCounter+1		# Consume the ":"
				PRINT ("Bitfield variable!!!")
				
				PRINT ("Current variableDescription = <",variableDescription,">")
				
				if baseType not in ("char","short","int","long","long long"):
					errorMessage = "ERROR: bit field declataion not allowed for baseType = <" + STR(baseType) +">)"
					errorRoutine(errorMessage)
					return False
				elif "*" in inputList[currentDeclarationSegmentStartIndex:variableNameIndex]:
					errorMessage = "ERROR: Pointer not allowed for bit field declataion for "+STR(variableName)
					errorRoutine(errorMessage)
					return False
				elif "array of size" in variableDescription:
					errorMessage = "ERROR: Arrays not allowed for bit field declataion for "+STR(variableName)
					errorRoutine(errorMessage)
					return False
				
				bitFieldWidthExpressionStartIndex = rightCounter
				
				# We are assuming that by now all the preprocessing (macro stuff) etc. has happened. Hence, we are assuming that there are no commas within the bitfield width.
				# TO-DO: Verify that there cannot really be any comma.
				nextCommaIndex = 10000000000000		# Arbitrarily large value
				nextEqualToIndex = 10000000000000	# Arbitrarily large value
				nextAttributeIndex = 10000000000000	# Arbitrarily large value
				nextSemicolonIndex = rightCounter + inputList[rightCounter:].index(';')
				if ',' in inputList[rightCounter:nextSemicolonIndex]:
					nextCommaIndex = rightCounter + inputList[rightCounter:nextSemicolonIndex].index(',')
				if '=' in inputList[rightCounter:nextSemicolonIndex]:
					nextEqualToIndex = rightCounter + inputList[rightCounter:nextSemicolonIndex].index('=')
				if '__attribute__' in inputList[rightCounter:nextSemicolonIndex]:
					nextAttributeIndex = rightCounter + inputList[rightCounter:nextSemicolonIndex].index('__attribute__')
				bitFieldWidthExpressionEndIndexInclusive = min(nextSemicolonIndex,nextCommaIndex,nextEqualToIndex,nextAttributeIndex)-1
				bitFieldWidthExpression = inputList[bitFieldWidthExpressionStartIndex:bitFieldWidthExpressionEndIndexInclusive+1]
				PRINT ("The bitfield width expression is from start index ",bitFieldWidthExpressionStartIndex, "to end index ",bitFieldWidthExpressionEndIndexInclusive,"(inclusive) = ",bitFieldWidthExpression)

				parseArithmeticExpressionOutput = parseArithmeticExpression(bitFieldWidthExpression)
				if parseArithmeticExpressionOutput == False:
					errorMessage = "ERROR after calling parseArithmeticExpression(bitFieldWidthExpression = <" + STR(bitFieldWidthExpression) +">)"
					errorRoutine(errorMessage)
					return False
				else:
					evaluateArithmeticExpressionOutput = evaluateArithmeticExpression(parseArithmeticExpressionOutput)
					if evaluateArithmeticExpressionOutput[0] != True:
						errorMessage = "ERROR in bitfield width calculation after calling evaluateArithmeticExpression(parseArithmeticExpressionOutput) for parseArithmeticExpressionOutput ="+ STR(parseArithmeticExpressionOutput)
						errorRoutine(errorMessage)
						return False
					else:
						if evaluateArithmeticExpressionOutput[1] == LOGICAL_TEST_RESULT_INDETERMINATE:
							bitFieldWidth = bitFieldWidthExpression		# Just leave it as it is
							isDynamic = True
						else:
							bitFieldWidth = evaluateArithmeticExpressionOutput[1]
							if bitFieldWidth > primitiveDatatypeLength[baseType]*BITS_IN_BYTE:
								errorMessage = "ERROR: Bitfield width of " + STR(bitFieldWidth) + "cannot be larger than the size (" + STR(primitiveDatatypeLength[baseType]) + ") of the base datatype (" +STR(baseType)+")"
								errorRoutine(errorMessage)
								return False
							elif bitFieldWidth < 0:
								errorMessage = "ERROR: Bitfield width of " + STR(bitFieldWidth) + "cannot be negative for bit variable " + variableName
								errorRoutine(errorMessage)
								return False
							elif bitFieldWidth == 0 and not variableName.startswith(dummyUnnamedBitfieldNamePrefix):
								errorMessage = "ERROR: Bitfield width of " + STR(bitFieldWidth) + "cannot be 0 for bit variable " + variableName
								errorRoutine(errorMessage)
								return False
						
						isBitField = True
						PRINT (variableName,"is a bitfield,",bitFieldWidth,"bits wide")
						rightCounterPrevious = rightCounter
						rightCounter = bitFieldWidthExpressionEndIndexInclusive

			######################################################################################
			# Handle the __attribute__ statements at the end of individual variable declaration
			######################################################################################
			elif inputList[rightCounter]== ATTRIBUTE_STRING:
				while True:
					if inputList[rightCounter] == ATTRIBUTE_STRING:
						parseAttributeResult = parseAttribute(inputList[rightCounter:])
						if parseAttributeResult[0] != True:
							errorMessage = "ERROR in parseVariableDeclaration() after calling parseAttribute() for inputList[rightCounter(%d):] = <%s>]"%(rightCounter,STR(inputList[rightCounter:]))
							errorRoutine(errorMessage)
							return False
						else:
							PRINT("parseAttributeResult[1] = ",parseAttributeResult[1])
							for (key, value) in parseAttributeResult[1].items():
								if key == ALIGNED_STRING and ALIGNED_STRING in getDictKeyList(variableSpecificAttributes):
									variableSpecificAttributes[key] = max(variableSpecificAttributes[key], value)
								else:
									variableSpecificAttributes[key] = value		# Yes, this will overwrite existing values, but we do not care
							d = parseAttributeResult[1]["distance"]
							rightCounter += 1+d	# We do not advance the counter to the next token - that will automatically be done the first thing within the while loop
							PRINT("After processing the __attribute__, inputList[rightCounter(",rightCounter,")] =",inputList[rightCounter])
					else:
						break
				PRINT ("variableSpecificAttributes =",variableSpecificAttributes)

			###########################################################################
			# Handle End of individual variable declaration, including initialization
			###########################################################################
#			elif inputList[rightCounter]=="{":
#				MUST_PRINT("variableDescription =",variableDescription)
#				MUST_PRINT("variableName = inputList[",variableNameIndex,"] =",variableName)
#				MUST_PRINT("rest of inputList =",inputList[rightCounter:])
			elif ((variableDescription.startswith(variableName+" is of type function") and inputList[rightCounter]=="{" and rightCounter<len(inputList)-1 and '}' in inputList[rightCounter+1:]) 
			     or inputList[rightCounter]==";" or inputList[rightCounter]=="," or inputList[rightCounter]=="="):
			    
				if leftBoundary < leftCounter:	# Should always happen
					# Verify that all intermediate tokens are '*' only
					# TO-DO: Can const be here?
					k = leftCounter - 1
					while k > leftBoundary:
						if inputList[k] == "*":
							variableDescription = variableDescription + " pointer to "
						else:
							PRINT ("ERROR in parseVariableDeclaration() during end-of-declaration and initialization - unexpected token inputList[",k,"] =",inputList[k] )
							return False
							sys.exit
						k = k - 1

				if inputList[rightCounter] == '=':	# Initialization
					if "typedef" in inputList[:typeSpecifierEndIndex+1]:
						errorMessage = "ERROR in parseVariableDeclaration("+STR(inputList)+") - initialization not allowed for TYPEDEF variable "+STR(variableName)+" since derived types by themselves hold no storage"
						errorRoutine(errorMessage)
						return False
					isInitialized = True
					initializationStartIndex = rightCounter
					rightCounter = rightCounter+1		# Consume the "="
					nextCommaIndex = -10000
					nextSemicolonIndex = rightCounter + inputList[rightCounter:].index(';')
					if ',' in inputList[rightCounter:]:
						# Remember that a comma can be also part of an array initialization
						k = rightCounter
#						PRINT ("Checking initialization value - inspecting", inputList[k:] )
						while k < len(inputList):
							if inputList[k] == "(" or inputList[k] == "{" or inputList[k] == "[":
								d = matchingBraceDistance(inputList[k:])
								if d < 1:
									PRINT ("Cannot find matching distance for",inputList[k:]," - exiting" )
									return False
									sys.exit()
#								PRINT ("Found brace",inputList[k]," at k =",k,"corresponding match is at distance",d )
								k = k + d + 1
#								PRINT ("k value incremented to ",k )
							elif inputList[k] == ",":
								nextCommaIndex = k
								break
							else:
								k = k + 1
					
					if nextCommaIndex >= 0 and nextCommaIndex < nextSemicolonIndex:
						initializationEndIndex = nextCommaIndex - 1
					else:
						initializationEndIndex = nextSemicolonIndex-1;
					initializationValue = inputList[rightCounter:initializationEndIndex+1]
					
					PRINT ("variableName ",variableName,"is initialized to the value",initializationValue )
					rightCounter = initializationEndIndex+1
					if initializationEndIndex == nextSemicolonIndex-1:
						declarationStatementEndReached = True

				# We do want to keep the function declarations, but we want to ignore actual function implementations. So when we realize that found an implementation,
				# we just note down its implementation as its initialization value.
				elif (variableDescription.startswith(variableName+" is of type function") and inputList[rightCounter]=="{" and rightCounter<len(inputList)-1 and '}' in inputList[rightCounter+1:]):
					initializationStartIndex = rightCounter
					currentDeclarationSegmentEndIndexInclusive = rightCounter + matchingBraceDistance(inputList[rightCounter:])
					rightCounter = currentDeclarationSegmentEndIndexInclusive
					isInitialized = True
					initializationValue = inputList[initializationStartIndex:currentDeclarationSegmentEndIndexInclusive+1]
				else:
					initializationValue = ""
					
				# Reset the leftBoundary for the next segment of variable declaration, if any
				leftBoundary = rightCounter
				
				currentDeclarationSegmentEndIndexInclusive = rightCounter
				
#		variableDescription = variableDescription + " of type " + ("unsigned " if signedOrUnsigned == "unsigned" else "")+ inputList[typeSpecifierEndIndex] 
		variableDescription = variableDescription + " of type " + ("unsigned " if signedOrUnsigned == "unsigned" else "")+ baseType 
		if initializationValue != "":
			variableDescription = variableDescription + ", which is initialized to the value " + list2plaintext(initializationValue,"")
			if len(initializationValue)==1 and checkIfString(initializationValue[0]) and initializationValue[0][0]=='"' and initializationValue[0][-1]=='"':
				PRINT("String initialization, The characters are",initializationValue[0][1:-1])
				tempList = []
				for x in initializationValue[0][1:-1]:
					tempList.extend(["'"+x+"'",','])
				decomposedString = ['{']+tempList+['0','}']
				PRINT("initializationValue =",initializationValue,"has been decomposed into",decomposedString)
				initializationValue = decomposedString
		PRINT ("For variable <", variableName, ">, variableDescription = ",variableDescription )

		# Calculate the size of the variable
		# The strategy is: We try to find out if the variable is an array or not. If it is an array, its size
		
		isArray = False		# Default value
		
		maxSize = len(variableDescription) + 1	#just an arbitrarily large index that is larger than the possible index value
		tempStr = variableDescription.strip().split(variableName+" is ")[1].strip()
		PRINT ("tempStr =", tempStr )
		
		size = -1  #just giving a wrong value
		multiplier = 1
		arrayDimensions = []	# If this is an array, it will give the array dimensions. Otherwise, it will be blank
		PRINT ("\n\nGoing to determnine the size of tempStr=<%s>\n\n"%(tempStr) )
		# If tempStr starts with the word "pointer to", then we know right away its size
		arrayOfSizeStr = "array of size "
		ofTypeStr = " of type "
		
		if (len(tempStr)>=len(arrayOfSizeStr)) and (tempStr[0:len(arrayOfSizeStr)] == arrayOfSizeStr):	# Basically, startswith() :-)
			PRINT ("Detected ARRAY ! ! !" )
			isArray = True
			restOfString = tempStr[len(arrayOfSizeStr):].split(" ")		# Works only for non-Dynamic array
#			restOfString = tempStr[len(arrayOfSizeStr):].split(ofTypeStr,1)		# Works only for non-Dynamic array
#			PRINT ("After only keeping the substring between \"array of size \" and \" of type \" substrings, restOfString =",restOfString )
			PRINT ("restOfString =",restOfString )
			newArrayDimension = restOfString[0]
			if "$" in newArrayDimension:
				PRINT(	"Before replacing the artificially-inserted \"$\" with \" \" in newArrayDimension =",newArrayDimension)
				newArrayDimension = newArrayDimension.replace("$"," ")
				PRINT("After replacing the artificially-inserted \"$\" with \" \" in newArrayDimension =",newArrayDimension)
			PRINT("newArrayDimension =",newArrayDimension)
#			tempStr = restOfString[1]		# Newly added
			# This only works because we have ensured that variable array dimensions do not contain any space in them
			getNumericValueOrTokenizedStringResult = getNumericValueOrTokenizedString(newArrayDimension)
			if getNumericValueOrTokenizedStringResult == False:	# TO-DO: False also means zero, so may want to change it
				errorMessage = "ERROR in parseVariableDeclaration() understanding <%s>"%newArrayDimension
				errorRoutine(errorMessage)
				return False
			else:
				arrayDimensions.append(getNumericValueOrTokenizedStringResult)
				PRINT("arrayDimensions =",arrayDimensions)
			
			k = 1
			
			# Thanks to typedefs, we could end up with multiple "array of size 2 array of size 3" statement instead of a simple "array of size 2 X 3" statement
			while (restOfString[k] == "X") or (len(restOfString)>=k+4 and restOfString[k:k+3]==["array","of","size"]):
				PRINT ("Multi-dimensional array detected!" )
				if restOfString[k] == "X":
					PRINT ("k = ",k,"restOfString[k] =",restOfString[k], "restOfString[k+1] =",restOfString[k+1] )
					newArrayDimension = restOfString[k+1]
					PRINT ("Adding new dimension of",newArrayDimension)
					# This only works because we have ensured that variable array dimensions do not contain any space in them
					getNumericValueOrTokenizedStringResult = getNumericValueOrTokenizedString(newArrayDimension)
					if getNumericValueOrTokenizedStringResult == False:	# TO-DO: False also means zero, so may want to change it
						errorMessage = "ERROR in parseVariableDeclaration() understanding <%s>"%newArrayDimension
						errorRoutine(errorMessage)
						return False
					else:
						arrayDimensions.append(getNumericValueOrTokenizedStringResult)
						PRINT("arrayDimensions =",arrayDimensions)
					k = k + 2
				elif len(restOfString)>=k+4 and restOfString[k:k+3]==["array","of","size"]:
					newArrayDimension = restOfString[k+3]
					if "$" in newArrayDimension:
						PRINT("Before replacing the artificially-inserted \"$\" with \" \" in newArrayDimension =",newArrayDimension)
						newArrayDimension = newArrayDimension.replace("$"," ")
						PRINT("After replacing the artificially-inserted \"$\" with \" \" in newArrayDimension =",newArrayDimension)
					PRINT ("Adding new dimension of",newArrayDimension)
					# This only works because we have ensured that variable array dimensions do not contain any space in them
					getNumericValueOrTokenizedStringResult = getNumericValueOrTokenizedString(newArrayDimension)
					if getNumericValueOrTokenizedStringResult == False:	# TO-DO: False also means zero, so may want to change it
						errorMessage = "ERROR in parseVariableDeclaration() understanding <%s>"%newArrayDimension
						errorRoutine(errorMessage)
						return False
					else:
						arrayDimensions.append(getNumericValueOrTokenizedStringResult)
						PRINT("arrayDimensions =",arrayDimensions)
					k = k + 4
				else:
					PRINT ("ERROR in parseVariableDeclaration(): We should have never been here" )
					sys.exit()
			
			if ["TBD"] in arrayDimensions[1:]:
				errorMessage = "ERROR in parseVariableDeclaration() array dimension <%s> allows TBD only as the topmost dimension!"%STR(arrayDimensions)
				errorRoutine(errorMessage)
				return False
			elif arrayDimensions[0] == ["TBD"]:
				if isInitialized:	# Initialialized
					PRINT("initializationValue =",initializationValue)
					if initializationValue[0] != '{' or initializationValue[-1] != '}':
						errorMessage = "ERROR in parseVariableDeclaration() - the initialization value for array  <%s> allows TBD only as the topmost dimension!"%STR(initializationValue)
						errorRoutine(errorMessage)
						return False
					initializationValueWithoutCurlyBraces = []
					PRINT("Before removing the '{'s, the initializationValue =",initializationValue)
					for item in initializationValue:
						if item not in ('{','}'):
							initializationValueWithoutCurlyBraces.append(item)
					PRINT("After removing the '{'s from the initializationValue, initializationValueWithoutCurlyBraces =",initializationValueWithoutCurlyBraces)
					initializationValueBraced = ['{']+ initializationValueWithoutCurlyBraces + ['}']
					parseArgumentListResult = parseArgumentList(initializationValueBraced)
					if parseArgumentListResult == False:
						errorMessage = "ERROR in parseVariableDeclaration() - the initialization value for array  variable "+variableName+" has illegal initialization value - "%STR(initializationValueBraced)
						errorRoutine(errorMessage)
						return False
					else:
						initializationItemCount = len(parseArgumentListResult)
						if len(arrayDimensions)==1:
							arrayDimensions[0]=initializationItemCount
						else:
							tempProduct = listItemsProduct(arrayDimensions[1:])
							if initializationItemCount%tempProduct != 0:
								errorMessage = "ERROR in parseVariableDeclaration() - the initialization value for array  variable "+variableName+" has total "+STR(initializationItemCount)+" items but it is NOT a multiple of "+STR(tempProduct)+" (obtained from mentioned diameters "+STR(arrayDimensions[1:])
								errorRoutine(errorMessage)
								return False
							else:
								X = integerDivision(initializationItemCount, tempProduct)
								PRINT("Setting the arrayDimensions[0] to", X)
								arrayDimensions[0] = X
								PRINT("Now going to replace the 'TBD' with",STR(X),"in variableDescription =",variableDescription)
								substring2replace = variableName+" is array of size TBD"
								newSubstring = variableName+" is array of size "+STR(X)
								variableDescription = variableDescription.replace(substring2replace, newSubstring, 1)
								PRINT("After replacing the 'TBD' with",STR(X),"in variableDescription =",variableDescription)
				else:	# Not initialized
					isDynamic = True
					'''
					if len(arrayDimensions)==1:
						PRINT("Array variable",variableName,"is not initialized - its dimension must be determined by infinite recursing")
					else:
						errorMessage = "ERROR in parseVariableDeclaration(): Multidimensional array <%s> with TBD as the topmost dimension must be initialized!"%STR(arrayDimensions)
						errorRoutine(errorMessage)
						return False
					'''
			else:
				PRINT("All array dimensions (",STR(arrayDimensions),") explicitly declared")
				
			PRINT("\nFor array variable",variableName,", arrayDimensions =",arrayDimensions)
#			PRINT("arrayDimensions2 =",arrayDimensions2,"\n")
			totalNumberOfArrayElements = listItemsProduct(arrayDimensions)
			if totalNumberOfArrayElements == False:
				errorMessage = "ERROR in parseVariableDeclaration(): Error calling listItemsProduct(arrayDimensions=%s)"%STR(arrayDimensions)
				errorRoutine(errorMessage)
				return False
			elif not (isinstance(totalNumberOfArrayElements, list) or checkIfIntegral(totalNumberOfArrayElements)):
				errorMessage = "ERROR in parseVariableDeclaration(): Error calling listItemsProduct(arrayDimensions=%s) - the output (%s) is neither integral nor a list"%(STR(arrayDimensions),STR(totalNumberOfArrayElements))
				errorRoutine(errorMessage)
				return False
			
				
			PRINT ("BEFORE RE substituion, tempStr = <%s>"%(tempStr) )
			# We have the typedef array problem where we end up with situations like:
			#	typedef int INT_ARRAY[2];
			#   typedef INT_ARRAY INT_ARRAY_ARRAY[3];
			# Now, we will see statements like 
			# tempStr = array of size 2
			#\S will match any non-whitespace character, so it is a MUST that all array dimension expressions do NOT have any whitespace in them (i.e., "A+B" is OK, "A + B" is not)
			tempStr = re.sub(r"^(array of size\s+\S+(\s+X\s+\S+)*\s+)+","",tempStr)
			PRINT ("AFTER RE substituion, tempStr = <%s>"%(tempStr) )
			PRINT("\nFor array variable",variableName,", arrayDimensions =",arrayDimensions)
			
		if tempStr[0:7] == "pointer":
			datatype = "pointer"
			size = 4
		elif tempStr[0:7] == "of type":
			initializationTextHint = ", which is initialized to the value"
			if initializationTextHint in tempStr[8:]:
				initializationIndex = tempStr[8:].index(initializationTextHint)
				datatype = tempStr[8:8+initializationIndex]
			else:
				datatype = tempStr[8:]
			PRINT ("Checking for datatype = <%s>"%(datatype) )
			if datatype.startswith("unsigned"):
				datatype = datatype[9:]
			if datatype.startswith("function"):
				size = 0	# A function pointer has a size. A function does not need any storage. Pure C does not allow structs to have functions in them.
			elif datatype in getDictKeyList(primitiveDatatypeLength):
				size = primitiveDatatypeLength[datatype]
			elif datatype in getDictKeyList(typedefs):
				# It typedefs into a structure/union
				if isinstance(typedefs[datatype],list) and len(typedefs[datatype])==2 and (typedefs[datatype][0] == "enum" or typedefs[datatype][0] == "struct" or typedefs[datatype][0] == "union"):
					structOrUnionName = typedefs[datatype][1]
					PRINT ("Checking for size of datatype", datatype,"which is actually a ",typedefs[datatype][0],structOrUnionName )
					if structuresAndUnions[suDict[structOrUnionName][-1]] and ("size" in structuresAndUnions[suDict[structOrUnionName][-1]]):
						size = int(structuresAndUnions[suDict[structOrUnionName][-1]]["size"])
					else:
						PRINT ("typedefs = ",typedefs )
						PRINT ("structuresAndUnions =",structuresAndUnions )
						errorMessage = "ERROR in parseVariableDeclaration() - unknown size of struc/union datatype <"+structOrUnionName+"> - exiting"
						errorRoutine(errorMessage)
						return False
						sys.exit()
				# It typedefs into some other regular variable declaration
				else: 
					item = typedefs[datatype]
					PRINT ("The typedef", datatype,"resolves into",item )
					if len(item) != 5:
						errorMessage = "ERROR in parseVariableDeclaration() - len(tuple) is not 5 - exiting"
						errorRoutine(errorMessage)
						return False
						sys.exit()
					else:
						size = typedefs[datatype][1]
			elif datatype in getDictKeyList(enums):
				# In C, enum sizes are not specified of at least an INT
				size=primitiveDatatypeLength["int"]
				PRINT ("The size of Enum <",datatype,"> is assumed to be same as an Integer,",size )
				
			elif datatype in getDictKeyList(suDict):
				PRINT ("Checking for size of datatype", datatype )
				if "size" in structuresAndUnions[suDict[datatype][-1]]:
					size = int(structuresAndUnions[suDict[datatype][-1]]["size"])
				else:
					PRINT ("typedefs = ",typedefs )
					PRINT ("structuresAndUnions =",structuresAndUnions )
					errorMessage = "ERROR in parseVariableDeclaration() - unknown size of struc/union datatype <"+datatype+"> - exiting"
					errorRoutine(errorMessage)
					return False
					sys.exit()
			else:
				PRINT ("typedefs = ",typedefs )
				PRINT ("structuresAndUnions =",structuresAndUnions )
				errorMessage = "ERROR in parseVariableDeclaration() - unknown datatype <"+datatype+"> - exiting"
				errorRoutine(errorMessage)
				return False
				sys.exit()
		else:
			OUTPUT ("Coding ERROR in parseVariableDeclaration() - how did we end up here? tempStr = <",tempStr,"> - exiting" )
			sys.exit()
			
		arrayElementSize = size		# Size of a single array element
#		PRINT ("size =",size)
		if not isArray:
			pass	
		elif checkIfIntegral(totalNumberOfArrayElements):
			size = arrayElementSize * totalNumberOfArrayElements 	# Size of the whole variable. 
		elif isinstance(totalNumberOfArrayElements, list):
			size = [str(arrayElementSize),'*']+totalNumberOfArrayElements
		else:
			errorMessage = "ERROR in parseVariableDeclaration(): For variable %s, couldn't calculatie the overall size since the array dimension (%s) is neither int nor list "%(variableName,list2plaintext(totalNumberOfArrayElements,""))
			errorRoutine(errorMessage)
			return False
		
		PRINT ("For variable",variableName,", final size =",size )

		if isArray != True and isArray != False:	# Just doubly making sure
			OUTPUT ("ERROR - illegal value for isArray = <",isArray,"> - exiting!" )
			sys.exit()

		# Unless the variable is an array or a struct, the initializationValue cannot have any curly braces around it
		if not (datatype in getDictKeyList(suDict) and baseType in getDictKeyList(suDict)) and isInitialized and not isArray:
			if isinstance(initializationValue,list) and (initializationValue[0]=='{' or initializationValue[-1]=='}'):
				errorMessage = "ERROR in parseVariableDeclaration(): For variable %s of type %s, the supplied initialization value <%s> is illegal because it has curly braces"%(variableName, datatype, list2plaintext(initializationValue))
				errorRoutine(errorMessage)
				return False
		
		# TO-DO: Right now we do not handle the case of the an array of structs getting initialized at the same time. Just regular structs.
		# We check for both datatype and baseType since we do not want to include pointers to structures
		if datatype in getDictKeyList(suDict) and baseType in getDictKeyList(suDict) and isInitialized and not isArray:
			if datatype != baseType:
				OUTPUT("Bad coding in parseVariableDeclaration() - datatype (",datatype,") != baseType (", baseType,")")
				sys.exit()
			verifyStructInitializationResult = checkStructInitializationStatically(datatype,initializationValue)
			if verifyStructInitializationResult == False:
				errorMessage = "ERROR in parseVariableDeclaration(): For variable %s of type Struct %s, the supplied initialization value is illegal"%(variableName, datatype)
				errorRoutine(errorMessage)
				return False
			
		
		# Observe that we have added one extra element (typeSpecifierEndIndex) to this list. We store this because this is one item that can NEVER be recovered later.
		# The reason is, suppose we are having recursive typedef statements. 
		#
		# 		typedef int INT2[2];
		#		typedef INT2 INT3[3];
		#
		# Now, when we are doing this compilation the line "typedef INT2 INT3[3];" for the first time, INT3 is not yet part of the typedefs dictionary (though INT2 is).
		# So the typeSpecifierEndIndex will stop at INT2. However, once this statement is compiled, if we for some reason re-compile this, now INT3 is also part of the typedefs,
		# so typeSpecifierEndIndex will now stop at INT3, which is wrong. So, in order to preserve the compile-time-environment for the first-time-compilation, we need to
		# store this item separately.
		
		# Merge the baseAttributes and variableSpecificAttributes. Overwrites will happen except in case of Aligned, where the max value will prevail
		attributes = {}
		for key,value in baseAttributes.items():
			attributes[key] = value
		for key,value in variableSpecificAttributes.items():
#			if key == ALIGNED_STRING and ALIGNED_STRING in getDictKeyList(variableSpecificAttributes):	# Possible bug?
			if key == ALIGNED_STRING and ALIGNED_STRING in getDictKeyList(attributes):
				attributes[key] = max(value,attributes[key])
			else:
				attributes[key] = value
			
		variableDescriptionExtended = {}
		variableDescriptionExtended["isArray"]=isArray
		variableDescriptionExtended["isDynamic"]=isDynamic
		variableDescriptionExtended["isBitField"]=isBitField
		if isBitField: 
			variableDescriptionExtended["bitFieldWidth"]=bitFieldWidth
		variableDescriptionExtended["description"]=variableDescription
		variableDescriptionExtended["arrayDimensions"]=arrayDimensions
		variableDescriptionExtended["datatype"]=datatype		# For  int * pInt; baseType is int, but datatype is pointer. That's the difference between baseType and datatype
																# for a declaration like "struct A a; ", the datatype is simply "A", not the list ['struct', 'A']
		variableDescriptionExtended["baseType"]=baseType		# It is the void/char/short/int/long/long long/float/double used in the variable declaration statement.
																# for a declaration like "struct A a; ", the baseType is simply "A", not the list ['struct', 'A']
		variableDescriptionExtended["signedOrUnsigned"]=signedOrUnsigned
		variableDescriptionExtended["arrayElementSize"]=arrayElementSize
		variableDescriptionExtended["typeSpecifierEndIndex"]=typeSpecifierEndIndex
		variableDescriptionExtended["enumType"]= enumTypesIntypeSpecifierList[0] if enumTypesIntypeSpecifierList else None
		enumTypesIntypeSpecifierList
		variableDescriptionExtended["variableNameIndex"]=variableNameIndex
		variableDescriptionExtended["currentDeclarationSegmentStartIndex"]=currentDeclarationSegmentStartIndex 
		variableDescriptionExtended["currentDeclarationSegmentEndIndexInclusive"]=currentDeclarationSegmentEndIndexInclusive
		variableDescriptionExtended["isInitialized"]=isInitialized
		if isInitialized:
			variableDescriptionExtended["initializationStartIndex"]=initializationStartIndex
			variableDescriptionExtended["initializationValue"] = initializationValue
		if attributes:
			variableDescriptionExtended["attributes"]=attributes
		
		# "type" : "struct/union", 
		# "size":size, 
		# "components":[[variable1 name, variable size, variable declaration statement, variable name Index within the declaration tokenList, variable description],...]}
		PRINT ("Now going to append to returnList, whose current content is" )
		for item in returnListOf5tuples:
			PRINT (item )
		returnList = []
		returnList.append(variableName)
		returnList.append(size)							# Variable size - for array, total size of ALL array elements combined
		returnList.append(inputList)
		returnList.append(variableNameIndex)	# This may look redundant now because we already have the variable name, but it will come handy later locating the variable position for coloring
		returnList.append(variableDescriptionExtended)
		
		returnListOf5tuples.append(returnList)
		
		variableSpecificAttributes = {}		# Reset this so that previous variable's attributes do not get repeated here
		
		i = rightCounter + 1

	if "typedef" in inputList[:typeSpecifierEndIndex+1]:	# The "typedef" can be anywhere within the base specifier
		for item in returnListOf5tuples:
			PRINT ("\n\n=============$$$$$$============\nAdding NEW typedef!!!\n=============$$$$$$============\n\n" )
			PRINT ("Adding typedefs[",item[0],"] =",item )
			typedefs[item[0]]=item
			
	PRINT ("returnListOf5tuples = ",returnListOf5tuples )
	return returnListOf5tuples


#str1 = "void **(*(*weird)[][7][8])(   ) = 3;"
#str1 = "int **x={a,b}, y[][1+7*8];"
#inputList=tokenizeLines(str1)
#parseVariableDeclaration(inputList)
#sys.exit()

#################################################################################################################################
# Return how many individual data items are there in a non-Dynamic struct
#################################################################################################################################
def totalItemCountInStruct(structName):
	if not checkIfString(structName) or structName not in getDictKeyList(suDict) or "components" not in getDictKeyList(structuresAndUnions[suDict[structName][-1]]):
		errorMessage = "ERROR in totalItemCountInStruct() - the supplied struct name ("+STR(structName)+") is not a valid string"
		errorRoutine(errorMessage)
		return [False, None]
	elif structuresAndUnions[suDict[structName][-1]]["isDynamic"]:	# Impossible to count number of data items in a dynamic structure statically
		return [True, None]
		
	totalCount = 0
	for structMember in structuresAndUnions[suDict[structName][-1]]["components"]:
		structMemberVariableName		= structMember[0]
		structMemberDescription 		= structMember[4]
		structMemberBaseType			= structMemberDescription["baseType"]
		structMemberDatatype			= structMemberDescription["datatype"]
		structMemberVariableId			= structMemberDescription["variableId"]
		if not variableDeclarations[structMemberVariableId][4]["isArray"]:
			multiplier = 1
		else:
			if variableDeclarations[structMemberVariableId][4]["isDynamic"]:
				EXIT("Coding bug in totalItemCountInStruct - struct "+ structName+ " contains dynamic array yet not declared dynamic")
			arrayDimensions = variableDeclarations[structMemberVariableId][4]["arrayDimensions"]
			multiplier = listItemsProduct(arrayDimensions)
		
		individualItemCount = 1 # should only 
		if structMemberBaseType == structMemberDatatype and structMemberDatatype in getDictKeyList(suDict):
			status = totalItemCountInStruct(structMemberDatatype)
			PRINT("totalItemCountInStruct(",structMemberDatatype,") =",status)
			if status[0] == False or not checkIfIntegral(status[1]):
				errorMessage = "ERROR in totalItemCountInStruct() - error after calling totalItemCountInStruct("+structMemberDatatype+")"
				errorRoutine(errorMessage)
				return [False, None]
			else:
				individualItemCount = status[1]
				
		totalCount += multiplier * individualItemCount
		
	return [True, totalCount]

#########################################################################################################################################3
# Return how many individual data items are there in a non-Dynamic array
#########################################################################################################################################3
def totalItemCountInArray(variableId):
#	PRINT=OUTPUT
	if not checkIfIntegral(variableId) or variableId >= len(variableDeclarations) or not variableDeclarations[variableId][4]["isArray"]:
		errorMessage = "ERROR in totalItemCountInStruct() - the supplied array variableId ("+STR(variableId)+") is not valid"
		errorRoutine(errorMessage)
		return [False, None]
	elif not isinstance(initializationValue, list) or len(initializationValue)<2 or initializationValue[0]!='{' or initializationValue[-1]!='}':
		errorMessage = "ERROR in totalItemCountInArray() - the initialization value for array variableId "+STR(variableId)+" cannot succeed since the supplied initialization value ("+list2plaintext(initializationValue)+") is not a valid list starting and ending with curly braces"
		errorRoutine(errorMessage)
		return [False, None]
	variableName 		= variableDeclarations[variableId][0]
	variableDescription = variableDeclarations[variableId][4]
	baseType			= variableDeclarations[variableId][4]["baseType"]
	datatype			= variableDeclarations[variableId][4]["datatype"]
	arrayDimensions		= variableDeclarations[variableId][4]["arrayDimensions"]
	isDynamic = False if "isDynamic" not in getDictKeyList(arrayVariableDescription) else arrayVariableDescription["isDynamic"]
	
	if isDynamic:
		return [False, None]
	else:
		arrayElementCount = listItemsProduct(arrayDimensions)
		if baseType == datatype and datatype in getDictKeyList(suDict): 
			if structuresAndUnions[suDict[datatype][-1]]["isDynamic"]:
				return [False, None]
			else:
				multiplier = totalItemCountInStruct(datatype)
		else:
			multiplier = 1
		return	[True, arrayElementCount*multiplier]

#########################################################################################################################################3
# This function recursively verifies if an Array can be initialized with a given list
#########################################################################################################################################3
def checkArrayInitializationStatically(variableId, initializationValue):
	if not checkIfIntegral(variableId) or variableId >= len(variableDeclarations) or not variableDeclarations[variableId][4]["isArray"]:
		errorMessage = "ERROR in checkArrayInitializationStatically() - the supplied array variableId ("+STR(variableId)+") is not valid"
		errorRoutine(errorMessage)
		return [False, None]
	elif not isinstance(initializationValue, list) or len(initializationValue)<2 or initializationValue[0]!='{' or initializationValue[-1]!='}':
		errorMessage = "ERROR in checkArrayInitializationStatically() - the initialization value for array variableId "+STR(variableId)+" ("+variableDeclarations[variableId][0]+") cannot succeed since the supplied initialization value ("+list2plaintext(initializationValue)+") is not a valid list starting and ending with curly braces"
		errorRoutine(errorMessage)
		return [False, None]
	variableName 		= variableDeclarations[variableId][0]
	variableDescription = variableDeclarations[variableId][4]
	baseType			= variableDeclarations[variableId][4]["baseType"]
	datatype			= variableDeclarations[variableId][4]["datatype"]
	arrayDimensions		= variableDeclarations[variableId][4]["arrayDimensions"]
	isDynamic = False if "isDynamic" not in getDictKeyList(arrayVariableDescription) else arrayVariableDescription["isDynamic"]

	totalItemCountInArrayStatus = totalItemCountInStruct(variableName)		# MANNA_MANNA changed from variableId
	if totalItemCountInArrayStatus[0]== True:
		arrayElementCount = totalItemCountInArrayStatus[1]
		
	if isinstance(initializationValue,list) and re.match(r'{}|{0(,0)*}',list2plaintext(initializationValue,"")):
		PRINT("Initialize to the default value!")
		return True
	else: 
		parseArgumentListResult = parseArgumentList(initializationValue)
		if parseArgumentListResult == False:
			errorMessage = "ERROR in checkArrayInitializationStatically() - the initialization value for array "+variableName+" has illegal initialization value - "+STR(initializationValue)
			errorRoutine(errorMessage)
			return False
		else:
			initializationItemCount = len(parseArgumentListResult)
			# TO-DO We currently know that this logic is not fully correct since it does not handle nested structs correctly.
			if not isDynamic and initializationItemCount > arrayElementCount:
				errorMessage = "ERROR in checkArrayInitializationStatically() - the initialization value for regular array "+variableName+" has illegal initialization value ("+STR(initializationValue)+") since it has more values ("+STR(initializationItemCount)+") than the structMemberCount ("+STR(structMemberCount)+")"
				errorRoutine(errorMessage)
				return False
		# Check if it is a auto-positional or explicit-positional initialization (where we mention the struct member name in any arbitrary order), like below
		#		int i[5] = {1,2,3,4,5};
		#		int i[5] = {[2] = 1, [0] = 1,2,3,4,5}	
		for item in parseArgumentListResult:
			if isinstance(item, list) and '=' in item:	# explicit-positional initialization
				if item[0] != '[' or item[item.index('=')-1]!=']' or item.index('=')==1 or item.index('=')==len(item)-1:
					errorMessage = "ERROR in checkArrayInitializationStatically() - named initialization value for regular array "+variableName+" has an illegal item ("+ list2plaintext(item) +") that does not follow the <.var = value> format - "+STR(initializationValue)
					errorRoutine(errorMessage)
					return False
				initArrayIndex = item[:item.index('=')]
				# Verify that it is of the [][][] format
				if re.match(r"(\[.*\])+",list2plaintext(initArrayIndex)):
					PRINT(list2plaintext(initArrayIndex),"is a valid array index")
				else:
					errorMessage = "ERROR in checkArrayInitializationStatically() - for regular array "+variableName+" - the initialization value has an illegal item ("+ list2plaintext(item) +") that contains a named variable "+initVariableName+" that is not a valid array element index"
					errorRoutine(errorMessage)
					return False
				initValue = item[item.index('=')+1:]
				if initValue[0]=="{" and initValue[-1]=="}" and datatype == baseType and datatype in getDictKeyList(suDict):
					status = checkStructInitializationStatically(datatype, initValue)
					if status == False:
						errorMessage = "ERROR in checkStructInitializationStatically() - for regular array "+variableName+" - for item ("+ list2plaintext(item) +"), tried to initialize variable "+ initVariableName+" (which itself is of type Struct "+structMemberBaseType+" ), to initialization value "+list2plaintext(initValue)+" but failed."
						errorRoutine(errorMessage)
						return False
					else:
						PRINT("In checkStructInitializationStatically() - for regular array "+variableName+" - for item ("+ list2plaintext(item) +"), tried to initialize variable "+ initVariableName+" (which itself is of type Struct "+structMemberBaseType+" ), to initialization value "+list2plaintext(initValue)+" and succeeded.")
				
	return True					
	
#########################################################################################################################################3
# This function recursively verifies if a struct can be initialized with a given list
#########################################################################################################################################3
def checkStructInitializationStatically(structName, initializationValue):
#	PRINT=OUTPUT
	if not checkIfString(structName):
		errorMessage = "ERROR in checkStructInitializationStatically() - the supplied struct name ("+STR(structName)+") is not a valid string"
		errorRoutine(errorMessage)
		return False
	elif structName not in getDictKeyList(suDict):
		errorMessage = "ERROR in checkStructInitializationStatically() - the initialization value for struct "+structName+" cannot succeed since "+structName+" is not a valid structure/union name"
		errorRoutine(errorMessage)
		return False
	elif "components" not in getDictKeyList(structuresAndUnions[suDict[structName][-1]]):
		errorMessage = "ERROR in checkStructInitializationStatically() - initialization value <"+list2plaintext(initializationValue)+"> provided for struct "+structName+", but the struct does not have any components yet."
		errorRoutine(errorMessage)
		return False
	elif not isinstance(initializationValue, list) or len(initializationValue)<2 or initializationValue[0]!='{' or initializationValue[-1]!='}':
		errorMessage = "ERROR in checkStructInitializationStatically() - the initialization value for struct "+structName+" cannot succeed since the supplied initialization value ("+list2plaintext(initializationValue)+") is not a valid list starting and ending with curly braces"
		errorRoutine(errorMessage)
		return False
	
	# If it is a dynamic struct, there is simply no way to know how to apply the initialization beforehand, since the very first member might be a dynamic array. 
	# Heck, even if we get a named initialization, those named member variables may not exist during runtime.
	isDynamic = structuresAndUnions[suDict[structName][-1]]["isDynamic"]
	totalItemCountInStructStatus = totalItemCountInStruct(structName)
	if totalItemCountInStructStatus[0]== True:
		structMemberCount = totalItemCountInStructStatus[1]
	elif not isDynamic:
		EXIT("ERROR in checkStructInitializationStatically() - for regular structs, the return value from totalItemCountInStruct("+structName+") should succeed.")
	# Alternatively, suppose a struct has 5 members, but it is initialized to {0,0,0}. It will still be considered initialized to default (zero) values
	# if initializationValue == ['{','}'] or initializationValue == ['{','0','}']:	# The most common way to initialize to zeroes.
	if isinstance(initializationValue,list) and re.match(r'{}|{0(,0)*}',list2plaintext(initializationValue,"")):
		PRINT("Initialize to the default value!")
		return True
	else: 
		parseArgumentListResult = parseArgumentList(initializationValue)
		if parseArgumentListResult == False:
			errorMessage = "ERROR in checkStructInitializationStatically() - the initialization value for  struct "+structName+" has illegal initialization value - "+STR(initializationValue)
			errorRoutine(errorMessage)
			return False
		else:
			initializationItemCount = len(parseArgumentListResult)
			# TO-DO We currently know that this logic is not fully correct since it does not handle nested structs correctly.
			if not isDynamic and initializationItemCount > structMemberCount:
				errorMessage = "ERROR in checkStructInitializationStatically() - the initialization value for regular struct "+structName+" has illegal initialization value ("+STR(initializationValue)+") since it has more values ("+STR(initializationItemCount)+") than the structMemberCount ("+STR(structMemberCount)+")"
				errorRoutine(errorMessage)
				return False
		
		# Check if it is a named initialization (where we mention the struct member name in any arbitrary order, like below
		#		struct S { int i; char c; float f;};
		#		struct S var = {.f = 1.2 , .c = 'A'}	// observe that i has not mentioned at all, and the order of initialization is random
		for item in parseArgumentListResult:
			if isinstance(item, list) and '=' in item:
				if item[0] != '.' or item.index('=')==1 or item.index('=')==len(item)-1:
					errorMessage = "ERROR in checkStructInitializationStatically() - named initialization value for Struct "+ structName+" has an illegal item ("+ list2plaintext(item) +") that does not follow the <.var = value> format - "+STR(initializationValue)
					errorRoutine(errorMessage)
					return False
				initVariableName = item[1:item.index('=')]
				initValue = item[item.index('=')+1:]
				splitNameResult = splitName(initVariableName,structName)	# This will verify all parent-child relationships
				if splitNameResult == False:
					errorMessage = "ERROR in checkStructInitializationStatically() - for Struct "+ structName+" - the initialization value has an illegal item ("+ list2plaintext(item) +") that contains a named variable "+initVariableName+" that is not a valid struct member"
					errorRoutine(errorMessage)
					return False
				# Now, suppose we have a statement like .a.b.c = {1,2,3} in the named initialization, then we know that the actually it is c which is getting initialized.
				initLastVariableName 	= splitNameResult[0][-1]
				initLastVariableIndices = splitNameResult[1][-1]
				initLastVariableId 		= splitNameResult[2][-1]
	
				initLastVariableDatatype = variableDeclarations[initLastVariableId][4]["datatype"]
				# We only call checkArrayInitializationStatically() if we have an initialization like .arrayVariable = someValue. If it is .arrayVariable[1] = someValue,
				# then we do not call checkArrayInitializationStatically since we are assigning the initialization value to an array element, not to the whole array variable.
				if variableDeclarations[initLastVariableId][4]["isArray"] and not initLastVariableIndices:
					status = checkArrayInitializationStatically(initLastVariableId, initValue)
					if status == False:
						errorMessage = "ERROR in checkStructInitializationStatically() after calling checkArrayInitializationStatically() - for Struct "+ structName+" - for item ("+ list2plaintext(item) +"), tried to initialize variable "+ initLastVariableName+" (which itself is an array of type "+initLastVariableDatatype+" ), to initialization value "+list2plaintext(initValue)+" but failed."
						errorRoutine(errorMessage)
						return False
					else:
						PRINT("In checkStructInitializationStatically() - for Struct "+ structName+" - for item ("+ list2plaintext(item) +"), tried to initialize variable "+ initVariableName+" (which itself is of type Struct "+structMemberBaseType+" ), to initialization value "+list2plaintext(initValue)+" and succeeded.")
				elif initLastVariableDatatype in getDictKeyList(suDict):
					status = checkStructInitializationStatically(initLastVariableDatatype, initValue)
					if status == False:
						errorMessage = "ERROR in checkStructInitializationStatically() - for Struct "+ structName+" - for item ("+ list2plaintext(item) +"), tried to initialize variable "+ initLastVariableName+" (which itself is of type Struct "+initLastVariableDatatype+" ), to initialization value "+list2plaintext(initValue)+" but failed."
						errorRoutine(errorMessage)
						return False
					else:
						PRINT("In checkStructInitializationStatically() - for Struct "+ structName+" - for item ("+ list2plaintext(item) +"), tried to initialize variable "+ initLastVariableName+" (which itself is of type Struct "+initLastVariableDatatype+" ), to initialization value "+list2plaintext(initValue)+" and succeeded.")
	return True					

############################################################################
# This routine does two things: 1) Checks if the directives are properly interleaved, and 2) For an IF (or LOOP) statement finds the corresponding ENDIF (or ENDLOOP).
# In other words, for the second use case, it does not care if there are some more extra runtime directives that are unmatched.
# The assumption is that before using the routine for the second use case, one should run it for the first use case first to ensure that there are no unmatched directives.
# The reason we need the 2nd use case is that in case there are nested if-elif-else-endif #RUNTIME statement, the outer if-elif-else-endif statements do NOT disappear once 
# we process them.  This is one of the main differences between the Preprocessing statements and #RUNTIME statements. For preprocessing statements, the moment we have processed
# the outermost if-then-else-endif, exactly ONE of those possible blocks will remain and all the if-then-else-endif statements in the outermost level will disappear.
# So, while dealing with nested preprocessing statements, you can be confident that if you start processing from the beginning, you will never encounter any "extra" then-else-endif
# statements. However, for runtime statements, those will absolutely remain.
# So, in the case of nested if-elif-else-endif runtime statements, if we supply the inputLines starting from the inner (nested) if, it will obviously see some extra (unmatched)
# else or endinf statements which actually belong to the outer if. So, if we see returnMatchingEnd == True, the moment we get a matched endif (or endloop), we return.
#
#  What this routine does is the following:
#
#  It takes as input an array of lines.
#
#  If the first line contains an #if, #ifdef or #ifndev (basically any preprocessor if statement),
#  then it will return an array of [lineNumber, token] where the tokens are the conditional ones.
# 
#  For example, suppose the program structure (with line numebrs is this)
# 
#  Line # 0: #if (some condition)
#  ...
#  Line # 4: #ifdef something
#  ...
#  Line # 7: #endif
#  Line # 8: #elif (some other condition)
#  ...
#  Line # 9: #elif (some other condition)
#  ...
#  Line # 15: #endif
#                                                                          
# This routine will return [ [0,"#if"], [8,"#elif"], [9,"#elif"], [15, "#endif"]
#
############################################################################
def checkPreprocessingDirectivesInterleaving(inputLines, returnMatchingEnd=False):
#	PRINT=OUTPUT
	if not inputLines:
		return []
	else:
		PRINT("\n\n","///"*50,"\nInside checkPreprocessingDirectivesInterleaving(inputLines,","True" if returnMatchingEnd else "False",")\n","///"*50,"\nwhere inputLines =\n",inputLines,"\n")
	
	# Check that inputLines is a list of Lines (strings ending with a newline). If it is a single string, make it a list
	if  isinstance(inputLines,list):
#		PRINT ("inputLines is indeed a list" )
		itemCount = 0
		while itemCount < len(inputLines):
			if not checkIfString(inputLines[itemCount]):
				PRINT ("Exiting - inputLines is not a list of proper strings - ", inputLines )
				return False
			elif not inputLines[itemCount] or inputLines[itemCount][-1] != '\n':
				inputLines[itemCount] = inputLines[itemCount] + '\n'
			itemCount = itemCount + 1
#		PRINT ("inputLines is indeed a list of proper strings - ", inputLines )
	else:
#		PRINT ("inputLines is NOT a list" )
		if checkIfString(inputLines):
#			PRINT (("Checking if inputLines=<%s> has a newline at the end"%(inputLines)) )
			if inputLines[-1] != '\n':
#				PRINT ("Appending newline to the end of inputLines" )
				inputLines = inputLines + '\n'
#			PRINT ("Converting the inputLines <",inputLines,">, which is a basic string but not a list, into a list" )
			inputLines = [inputLines]
#			PRINT ("Now the listified inputLines = ",inputLines )
		else:
			PRINT ("Exiting - Unknown object type - inputLines = <",inputLines,">" )
			return False

	#preprocessingDirectives = ('include', 'if', 'ifdef', 'ifndef', 'else', 'elif', 'endif', 'define', 'undef', 'line', 'error', 'pragma')

	# This essentially only keeps those lines starting with a preprocessingDirectives. We note the preprocessingDirective and its line number, and its nesting level
	onlyPreprocessingDirectives = []
	tempStackPreProcessorDirective = []
	
	lineNumber = 0
	preProcessorDirectiveNestingLevel = -1
	while lineNumber < len(inputLines):
		currLine = inputLines[lineNumber]
		tokenizeLinesResult = tokenizeLines(currLine)
		if tokenizeLinesResult == False:
			PRINT ("ERROR in checkPreprocessingDirectivesInterleaving() after calling tokenizeLines(currLine) for currLine =",currLine )
			return False
		else:
			currLineTokenList = tokenizeLinesResult[0]
			PRINT("\n\n","///"*50,"\nCurrently handling",currLineTokenList)
			'''
			if returnMatchingEnd and lineNumber == 0:
				if currLineTokenList and currLineTokenList[0] == preProcessorSymbol and len(currLineTokenList)>=2 and currLineTokenList[1] in ('if', 'loop'):
					PRINT("Current line is indeed a valid starting #RUNTIME statement")
				else:
					errorMessage = "ERROR in checkPreprocessingDirectivesInterleaving(): We are supposed to return the matching ending line distance, but the line # "+STR(lineNumber)+" <"+inputLines[lineNumber][:-1]+"> is not an IF or LOOP"
					errorRoutine(errorMessage)
					OUTPUT("inputLines = \n",inputLines)
					return False
			'''
			# Preprocessor directives
			if currLineTokenList and currLineTokenList[0] == preProcessorSymbol and len(currLineTokenList)>=2 and currLineTokenList[1] in preprocessingDirectives:
				PRINT("tempStackPreProcessorDirective =",tempStackPreProcessorDirective)
				PRINT("\n\n","///"*50,"\nCurrently handling",currLineTokenList[1])
				if currLineTokenList[1] in ('if', 'ifdef', 'ifndef'):	# We push to the stack
					preProcessorDirectiveNestingLevel += 1
					onlyPreprocessingDirectives.append([lineNumber, currLineTokenList[1], preProcessorDirectiveNestingLevel])
					tempStackPreProcessorDirective.append(currLineTokenList[1])
					PRINT("After appending", currLineTokenList[1],", tempStackPreProcessorDirective =",tempStackPreProcessorDirective)
					PRINT("After appending", currLineTokenList[1],", onlyPreprocessingDirectives =",onlyPreprocessingDirectives)
				elif currLineTokenList[1] in ('elif','else'):			# We push to the stack
					onlyPreprocessingDirectives.append([lineNumber, currLineTokenList[1], preProcessorDirectiveNestingLevel])
					tempStackPreProcessorDirective.append(currLineTokenList[1])
					PRINT("After appending", currLineTokenList[1],", tempStackPreProcessorDirective =",tempStackPreProcessorDirective)
					PRINT("After appending", currLineTokenList[1],", onlyPreprocessingDirectives =",onlyPreprocessingDirectives)
				elif currLineTokenList[1] == 'endloop':
					onlyRuntimeDirectives.append([lineNumber, currLineTokenList[1],preProcessorDirectiveNestingLevel])
					if tempStackRuntimeDirective[-1] in ('loop'):
						del tempStackRuntimeDirective[-1]
					else:
						errorMessage = "Error in checkPreprocessingDirectivesInterleaving(): The interleaving of loop-endloop at the runtime level is not correct"
						errorRoutine(errorMessage)
						return False
					preProcessorDirectiveNestingLevel -= 1
					# When the outermost endif at level 0 is popped, the preProcessorDirectiveNestingLevel returns to -1
					if returnMatchingEnd and preProcessorDirectiveNestingLevel == -1:
						break
				elif currLineTokenList[1] == 'endif':					# We pop the stack, and verify if we are indeed getting the items we are supposed to get
					onlyPreprocessingDirectives.append([lineNumber, currLineTokenList[1],preProcessorDirectiveNestingLevel])
					if not tempStackPreProcessorDirective:
						errorMessage = "ERROR in checkPreprocessingDirectivesInterleaving() - while processing line # "+STR(lineNumber)+"= <"+currLine+">, found that the interleaving of if-then-else at the preprocessor level is not correct - no if conditions before "+preProcessorSymbol+"endif"
						errorRoutine(errorMessage)
						return False
					elif tempStackPreProcessorDirective[-1] ==  'else':		# We allow only ONE else
						del tempStackPreProcessorDirective[-1]
					while True:	# There might be multiple elif statements, go through all of them and pop them from the stack
						if tempStackPreProcessorDirective and tempStackPreProcessorDirective[-1] ==  'else':
							errorMessage = "The interleaving of if-then-else at the preprocessor level is not correct - multiple "+preProcessorSymbol+"else statements"
							errorRoutine(errorMessage)
							return False
						elif tempStackPreProcessorDirective and tempStackPreProcessorDirective[-1] ==  'elif':
							del tempStackPreProcessorDirective[-1]
						else:
							break
					PRINT("The current tempStackPreProcessorDirective =",tempStackPreProcessorDirective)
					if tempStackPreProcessorDirective and tempStackPreProcessorDirective[-1] in ('if', 'ifdef', 'ifndef'):
						del tempStackPreProcessorDirective[-1]
					else:
						errorMessage = "The interleaving of if-then-else at the preprocessor level is not correct"
						errorRoutine(errorMessage)
						return False
					preProcessorDirectiveNestingLevel -= 1
					
					# When the outermost endif at level 0 is popped, the preProcessorDirectiveNestingLevel returns to -1
					if returnMatchingEnd and preProcessorDirectiveNestingLevel == -1:
						break
				elif len(currLineTokenList)>=2:
					PRINT("Ignoring preprocessingDirectives currLineTokenList[0:1] =",STR(currLineTokenList[0:2]))
				else:
					PRINT("Ignoring preprocessingDirectives currLineTokenList[0] =",STR(currLineTokenList))
					
		lineNumber += 1
	
	if tempStackPreProcessorDirective:	# Should be empty
		errorMessage = "The interleaving of if-then-else at the preprocessor level is not correct"
		errorRoutine(errorMessage)
		return False

	PRINT("onlyPreprocessingDirectives =",onlyPreprocessingDirectives)
	
	if not onlyPreprocessingDirectives:	# If there aren't any preprocessing (or #RUNTIME) statements
		return []
	
	# Now see if this is a legal interleaving of the outermost (nesting level 0) preprocessingDirectives
	returnValue = []
	
	i = 0
	while i<len(onlyPreprocessingDirectives):
		if onlyPreprocessingDirectives[i][2] == 0:	# We are only interested in nesting level of 0
			returnValue.append([onlyPreprocessingDirectives[i][0],onlyPreprocessingDirectives[i][1]])
			if onlyPreprocessingDirectives[i][1] == 'endif':
				break	# If there are multiple if-elif-else-endif statement blocks at the nesting level of 0, we only return the very first one and ignore the rest.
		i += 1
		
	# Sanity check - it must start with a mandatory single if, followed by optional elifs, followed by a single optional else, followed by a signle mandatory endif
	if len(returnValue) <2:
		OUTPUT("returnValue =",returnValue)
		OUTPUT("onlyPreprocessingDirectives =",onlyPreprocessingDirectives)
		errorMessage = "An if-then-else in preprocessor directive must have at least two rows (the beginning if and the ending endif)"
		errorRoutine(errorMessage)
		return False
	elif returnValue[0][1] not in ('if', 'ifdef', 'ifndef'):
		errorMessage = "The first term must be '"+preProcessorSymbol+"if', '"+preProcessorSymbol+"ifdef', or '"+preProcessorSymbol+"ifndef'"
		errorRoutine(errorMessage)
		return False
	elif returnValue[-1][1] not in ('endif'):
		errorMessage = "The last term must be '"+preProcessorSymbol+"endif'"
		errorRoutine(errorMessage)
		return False
	elif len(returnValue)>2:
		ifCount = 0
		elifCount = 0
		elseCount = 0
		endifCount = 0
		for row in returnValue:
			if row[1] in ('if', 'ifdef', 'ifndef'):
				ifCount += 1
			elif row[1] in ('elif'):
				elifCount += 1
			elif row[1] in ('else'):
				elseCount += 1
			elif row[1] in ('endif'):
				endifCount += 1
		if ifCount + elifCount + elseCount + endifCount != len(returnValue):
			errorMessage = "ERROR in checkPreprocessingDirectivesInterleaving() - ifCount(%d) + elifCount(%d) + elseCount(%d) + endifCount(%d) != len(returnValue)(%d)"%(ifCount, elifCount, elseCount, endifCount, len(returnValue))
			errorRoutine(errorMessage)
			return False
		elif ifCount > 1:
			errorMessage = "ERROR in checkPreprocessingDirectivesInterleaving() - multiple "+preProcessorSymbol+"if/"+preProcessorSymbol+"ifdef/"+preProcessorSymbol+"ifndef statements"
			errorRoutine(errorMessage)
			return False
		elif elseCount > 1:
			errorMessage = "ERROR in checkPreprocessingDirectivesInterleaving() - multiple "+preProcessorSymbol+"else statements"
			errorRoutine(errorMessage)
			return False
		elif endifCount > 1:
			errorMessage = "ERROR in checkPreprocessingDirectivesInterleaving() - multiple "+preProcessorSymbol+"endif statement"
			errorRoutine(errorMessage)
			return False
		elif elseCount == 1 and returnValue[-2][1] != 'else':
			errorMessage = "ERROR in checkPreprocessingDirectivesInterleaving() - the "+preProcessorSymbol+"else statement must be the penultimate one"
			errorRoutine(errorMessage)
			return False

	# The returnValue is an array of [lineNumber,ifthenelseendif]
	return returnValue
	
########################################################################################################
# The reason we made it a separate routine is because we will have to call it every time we
# include a file.
########################################################################################################	
def removeComments():
	global lines
	# Remove single-line comments
	i = 0
	while i < len(lines):
		if "//" in lines[i]:			
			lines[i] = lines[i][:lines[i].find("//")]
		i+= 1
	PRINT (lines )
	#PRINT ("len(lines) = ", len(lines) )
	
	# Remove Multi-line comments
	commentStartLineIndex = -1000	#Something illegal value
	commentStartCharIndex = -1000	#Something illegal value
	i = 0
	ongoingComment = False
	#TO-DO: Change the code so that commentEndCharIndex is indeed the last char # of the comment, not the char AFTER that
	while i < len(lines):
		# End a previously running comment
		if ongoingComment == True and "*/" not in lines[i]:
			lines[i]= ""			# Delete whole line; comment still continues
		else:
			if ongoingComment == True and "*/" in lines[i]:
				commentEndCharIndex = lines[i].index("*/")+1
				if i > commentStartLineIndex:
					lines[i]=lines[i][commentEndCharIndex+1:]
					ongoingComment = False
			if ongoingComment == False:
				while "/*" in lines[i] and "*/" in lines[i] and (lines[i].index("/*")+2 <=lines[i].index("*/")):	# make sure we do not count /*/ as a valid comment
					commentStartCharIndex = lines[i].index("/*")
					commentEndCharIndex = lines[i].index("*/")+1
					lines[i]=lines[i][:commentStartCharIndex]+lines[i][commentEndCharIndex+1:]
				if 	"/*" in lines[i]:
					ongoingComment = True
					commentStartCharIndex = lines[i].index("/*")
					lines[i]=lines[i][:commentStartCharIndex]
		i+= 1
	return

########################################################################################################
# The reason we made it a separate routine is because we will have to call it every time we
# include a file.
########################################################################################################	
def condenseMultilineMacroIntoOneLine():
	global lines
	# Handle multi-line macros to make them a single line
	#PRINT ("======================\nGoing to handle multi-line macros\n======================" )
	PRINT ("len(lines) = ", len(lines) )
	i = 0
	while i < len(lines):
		PRINT ((" line # %d = <%s>" % (i,lines[i])) )
		i = i+1
		
	i = 0
	ongoingMacro = False
	while i < len(lines):
		#PRINT ("searching for macro in", lines[i] )
		currLine = lines[i].strip()					# TO-DO: This could be a problem if a string liternal spans over multiple lines and any such line ends with a space
		# BUG - there is no guarantee that only #define macro defintions can span over multiple lines. Even an #if condition can.
#		if re.search(r'^\s*'+preProcessorSymbol+r'\s*define\s+.+', currLine): 
		if re.search(r'^\s*'+preProcessorSymbol+r'\s*.+', currLine): 
			ongoingMacro = True
			macroFoundInLine = i
			while currLine[-1:] == "\\":
				PRINT (("Found backslash at the end of currLine =<%s>" % currLine) )
				i = i+1
				if i < len(lines):
					PRINT ("Multiline macro extends to line # ", i )
					PRINT (("currLine = <%s>, currLine[:-1] = <%s>, lines[i].strip() = <%s>" % (currLine , currLine[:-1] , lines[i].strip())) )
					currLine = currLine[:-1] + lines[i].strip()
					lines[i] = ""
				else:
					PRINT ("ERROR  in condenseMultilineMacroIntoOneLine() - missing multi-line macro - Exiting!" )
					return False
					sys.exit()
			ongoingMacro = False
			lines[macroFoundInLine] = currLine
		i=i+1	
	return True
	
#MUST_PRINT(parseArithmeticExpression(['a',',','b',',','c',',','d']))
#sys.exit()

####################################################################################################################################################################	
# After a source file has been preprocessed (all macros applied and all included files inserted, it becomes very hard to figure out which line in the final source
# came from which line of which original file.
# This routine returns a triad (filename, path, line#) that tells exactly that.
####################################################################################################################################################################	
def findLineInOriginalSource(targetLineNumber):
	for row in srcFileDetails:
		for segmentNum in range(1,len(row)):
			if row[segmentNum][0]<= targetLineNumber <= row[segmentNum][1]:
				OUTPUT("Found the targetLineNumber=", targetLineNumber,"within segmentNum=",segmentNum,"in this row=\n",row)
				includedFileName = row[0][0]
				path = row[0][1]
				slash = "\\" if "\\" in os.getcwd() else "/" if "/" in os.getcwd() else ""
				path = path if path[-1]==slash else path+slash
				lineNumInFile=0
				# Add up all the lines upto segmentNum (where the targetLineNumber was found)
				for seg in range(1,segmentNum+1):
					PRINT("For segmentNum=",segmentNum,", seg =",seg,", row[seg]=", row[seg])
					if seg < segmentNum:
						# We add 1 extra for each segment
						PRINT("Adding ALL",row[seg][1]-row[seg][0]+1+1,"lines within this segments")
						lineNumInFile += row[seg][1]-row[seg][0]+1+1
					elif row[seg][0]<= targetLineNumber <= row[seg][1]:
						PRINT("Adding ",targetLineNumber-row[seg][0],"lines")
						lineNumInFile += targetLineNumber-row[seg][0]
					else:
						EXIT("BAD Coding in findLineInOriginalSource()!!")
				OUTPUT("The targetLineNumber=",targetLineNumber,"is approximately line#",lineNumInFile,"in file",row[0])
				originalLines = []
				if row[0][0] == "#ORIGINAL#":
					OUTPUT("This is part of the code pasted in the Code window - cannot fetch")
				elif os.path.isfile(path+includedFileName):
					with open(path+includedFileName, "r") as includedFile:
						try:
							includedLines = includedFile.readlines()
							if not checkIfStringOrListOfStrings(includedLines):
								errorMessage = "ERROR in findLineInOriginalSource(): Bad coding: input code file content is NOT string - type(includedLines) = "+STR(type(includedLines))
								errorRoutine(errorMessage)
								return False
							else:
								i = lineNumInFile
								while True:
									currLine = includedLines[i]
									originalLines.append(currLine)
									if re.search(r'^\s*'+preProcessorSymbol+r'\s*.+\\\s*$', currLine):
										i = i+1
									else:
										break
								OUTPUT("In the original source file",path+includedFileName,"the following line(s) from line#",lineNumInFile,"constitude the current line")
								OUTPUT(originalLines)
						except ValueError: # Empty file
							includedLines = [""]
				returnValue = [row[0][0],row[0][1],lineNumInFile]
				return returnValue
	return False

####################################################################################
# This routine handles the macro definition in an input line
####################################################################################
def defineMacroOnLine(line):		
#	PRINT=OUTPUT
	global currentMacroNames, macroDefinitions
			
	
	# If it is a macro definition (doesn't matter if re-definition), then we  add it to the macro dictionary as it is.
	# We do NOT perform any invocation on either the macro argument list or the macro body.
	#
	# If it is a macro definition statement, the C preprocessor will NOT touch that statement for macro expansion
	# For example,
	#
	#	#define CONSTANT 100
	#	#define TABLESIZE CONSTANT				// <=== C preprocessor will NOT replace this statement as #define TABLESIZE 100
	#
	#   printf("TABLESIZE = %d", TABLESIZE);	// Obviously it will print "TABLESIZE = 100"
	#
	#	#define CONSTANT 50
	#   printf("TABLESIZE = %d", TABLESIZE);	// Surprisingly, it will print "TABLESIZE = 50"
	#
	# Basically, what is happening is that first the preprocessor is replacing the original statement
	#
	# 		printf("TABLESIZE = %d", TABLESIZE);
	#
	# with this one:
	#
	# 		printf("TABLESIZE = %d", CONSTANT);
	#
	# Then it keeps searching again and finds that there is yet another instance of macro invocation (CONSTANT). So now it replaces this statement
	#
	# 		printf("TABLESIZE = %d", CONSTANT);
	#
	# with this one:
	#
	# 		printf("TABLESIZE = %d", 50);
	#
	# Now there is no more macro invocations in this last statement, hence it can give it to the compiler. Recall that a preprocessor is NOT part of the C language.
	#
	# This also has yet another surprising implication. The order of the macro definitions did not matter. We could also have had it like this
	# and it would have given us identical result:
	#
	#	#define TABLESIZE CONSTANT				
	#	#define CONSTANT 100
	#
	
	# Now that all possible modification has been done to the current line, let's re-tokenize
	macroTokenListResult = tokenizeLines(line)
	if macroTokenListResult == False:
		errorMessage = "ERROR in defineMacroOnLine(), after all macro invocations and #include statement processing has been done, right after calling tokenizeLines(currLine) for currLine = " + lines[i]
		errorRoutine(errorMessage)
		return False
	else:
		macroTokenList = macroTokenListResult[0]
	
	if macroTokenList and macroTokenList[0] == preProcessorSymbol and len(macroTokenList)>=2 and macroTokenList[1] == "define":
		
		#  Each row of this macros table will have 4 parts: [macroName, macroArguments, macroExpansionText, macroProperties]
		# (Recall that multi-line macros have alredy been converted to single-line macros).
		# Find out if this macro takes parameters or not. Remember that by now ALL multi-line macros have already been converted to single-line macros

		
		if len(macroTokenList) < 3:
			errorMessage = "ERROR in line <%s> - Macro must have a valid name -- exiting!"%line
			errorRoutine(errorMessage)
			return False
		elif not re.search("^\s*[a-zA-Z_]+\w*", macroTokenList[2]):
			errorMessage = "ERROR in defineMacroOnLine() - Macro must have a valid name <"+ STR(macroTokenList[2])+ "> -- exiting!" 
			errorRoutine(errorMessage)
			return False
		# Apparently anything can be a macro name - nothing is illegal
#		elif macroTokenList[2] in illegalVariableNames:
#			errorMessage = "ERROR in defineMacroOnLine() in line <%s> - Macro must have a valid name - <%s> is not allowed -- exiting!"%(line,macroTokenList[2])
#			errorRoutine(errorMessage)
#			return False
		
		macroName = macroTokenList[2]
		macroProperties = {}
		
		OUTPUT("\t\tline =",line)
		if re.search(r'^\s*'+preProcessorSymbol+r'\s*define\s+[a-zA-Z_]+\w*\s*$', line): # No argument, no body (basically, a blank macro)
			macroArguments = ""		# We do not use [] to differentiate the case when a macro behaves like a function with zero argument, like NEWMACRO()
			macroExpansionText = ""
			macroExpansionTextTokenized = []
		elif re.search(r'^\s*'+preProcessorSymbol+r'\s*define\s+[a-zA-Z_]+\w*\s+\S*', line): # No argument, but has a macro body
			macroArguments = ""		# We do not use [] to differentiate the case when a macro behaves like a function with zero argument, like NEWMACRO()
			macroExpansionText = re.sub(r'^\s*'+preProcessorSymbol+r'\s*define\s+[a-zA-Z_]+\w*\s+',"",line)
			macroExpansionTextTokenized = macroTokenList[3:]
		elif re.search(r'^\s*'+preProcessorSymbol+r'\s*define\s+[a-zA-Z_]+\w*\(', line) and macroTokenList[3] == '()': # blank list of arguments
			# Kludge - unfortunately, I implemented the '()' operator initially, so I must pay the price here
			PRINT ("Macro ", macroName,"takes EMPTY arguments" )
#			argumentList = ""
			macroArguments = []
			macroExpansionText = re.sub(r'^\s*'+preProcessorSymbol+r'\s*define\s+[a-zA-Z_]+\w*\(\s*\)\s+',"",line)
			macroExpansionTextTokenized = macroTokenList[4:]
		elif re.search(r'^\s*'+preProcessorSymbol+r'\s*define\s+[a-zA-Z_]+\w*\(', line): # Has arguments
			d = matchingBraceDistance(macroTokenList[3:]) 
			if d < 0:
				errorMessage = "ERROR in defineMacroOnLine() - No matching parenthesis for macro argument list - exiting!"
				errorRoutine(errorMessage)
				return False
			else:
				macroArguments = macroTokenList[3:3+d+1]		# MANNA_MANNA
				macroExpansionText = re.sub(r'^\s*'+preProcessorSymbol+r'\s*define\s+[a-zA-Z_]+\w*\([\w,]*\)\s+',"",line)
				macroExpansionTextTokenized = macroTokenList[3+d+1:]

			variadicMacro = False
			variadicMacroExplicitArgumentCount = 0
			variadicMacroArgSpecialName = ""
		
			PRINT ("Macro ", macroName,"takes arguments" )
			temp = re.sub(r'^\s*'+preProcessorSymbol+r'\s*define\s+[a-zA-Z_]+\w*\(', "",line)	# Keep in mind that the temp is missing the first '(' of the argument list
			PRINT ("temp = <",temp,">" )
			# There cannot be nested parenthesis inside the argument list for macro  definition (it is allowed during invocation, but not during definition)
			if ")" not in temp:
				errorMessage = "ERROR in defineMacroOnLine() - No ending parenthesis for macro argument list - exiting!"
				errorRoutine(errorMessage)
				return False
			else:
				endParenthesis = temp.index(')');
				if "(" in temp:
					newBeginParenthesis = temp.index('(');
					if newBeginParenthesis < endParenthesis:
						errorMessage = "ERROR in defineMacroOnLine() : \"\(\" may not appear in macro parameter list"
						errorRoutine(errorMessage)
						return False
				macroArgumentsDefined = "("+temp[:endParenthesis]+")"
				tokenizeLinesOutputResult = tokenizeLines(macroArgumentsDefined)
				if tokenizeLinesOutputResult == False:
					errorMessage = "ERROR in defineMacroOnLine(): exiting because tokenizeLines(macroArgumentsDefined) = False where macroArgumentsDefined ="+STR(macroArgumentsDefined)
					errorRoutine(errorMessage)
					return False
				else:
					tokenizeLinesOutput = tokenizeLinesOutputResult[0]
					if tokenizeLinesOutput[0] != '(' or tokenizeLinesOutput[-1] != ')':
						errorMessage = "Error in defineMacroOnLine(): Illegal argument list for macro %s: %s"%(macroName, STR(tokenizeLinesOutput))
						errorRoutine(errorMessage)
						return False
					
				# Variadic macros - check its input argument list format. Valid formats are ([arg1, arg2,...,argn,][specialName] ...)
				if tokenizeLinesOutput[-2]=='...':
					variadicMacro = True
					PRINT("Variadic macro found")
					if tokenizeLinesOutput[-3]!=',' and tokenizeLinesOutput[-3]!='(' : # We have a case like #define MacroName(args ...)
						variadicMacroArgSpecialName = tokenizeLinesOutput[-3]
						PRINT("Variadic macro argument it is referenced as",tokenizeLinesOutput[-3])
						PRINT("Now deleting this ... token from tokenizeLinesOutput =",tokenizeLinesOutput)
						del tokenizeLinesOutput[-2]	
						PRINT("After deleting", variadicMacroArgSpecialName, ", tokenizeLinesOutput =",tokenizeLinesOutput)
					else:
						tokenizeLinesOutput[-2] = '__VA_ARGS__'	# We do this so that in the expansion we can simply do regular replacements
					
					numTokensUnconsumed = len(tokenizeLinesOutput)-3
					if numTokensUnconsumed %2 != 0:
						errorMessage = "Error in defineMacroOnLine(): Illegal argument list for macro %s: %s"%(macroName, STR(tokenizeLinesOutput))
						errorRoutine(errorMessage)
						return False
					variadicMacroExplicitArgumentCount = integerDivision(numTokensUnconsumed,2)
					for t in range(variadicMacroExplicitArgumentCount):
						if tokenizeLinesOutput[2*(t+1)] != ',' or tokenizeLinesOutput[2*(t+1)-1] == ',':	# Recall that the tokenizeLinesOutput[0] = '('
							errorMessage = "Error in defineMacroOnLine(): Illegal argument list for macro %s: %s"%(macroName, STR(tokenizeLinesOutput))
							errorRoutine(errorMessage)
							return False
					PRINT("There are", variadicMacroExplicitArgumentCount,"explicit arguments before the ... in this variadic macro")
					
					
				# Remember that for variadic macros with a special name for ... , we have deleted that token	
				argumentList = parseArgumentList(tokenizeLinesOutput)
				if argumentList == False:
					errorMessage ("Error in defineMacroOnLine(): Error parsing for arguments in tokenized version of " + STR(tokenizeLinesOutput) )
					errorRoutine(errorMessage)
					return False
				PRINT ("The macro",macroName,"takes the following argument list:",argumentList )
				PRINT ("We have used argumentList = parseArgumentList(\"(\"+temp[:endParenthesis]+\")\"). If we had used argumentList = re.sub(\"\s*\",\"\",temp[:endParenthesis]).split(\",\"), then we would have gotten" )
				PRINT (re.sub("\s*","",temp[:endParenthesis]).split(","))	# Remove all the whitespace from the argumentlist first, and then split it 
				# argumentList = parseArgumentList("("+temp[:endParenthesis]+")")
				# Check that there are no repeated arguments. For example, we cannot have a macro like #define func1(a,b,a). All arguments must be unique
				argIndexI = 0
				while argIndexI < len(argumentList):
					argIndexJ = argIndexI + 1
					while argIndexJ < len(argumentList):
						if argumentList[argIndexI] == argumentList[argIndexJ]:
							errorMessage = "ERROR  in defineMacroOnLine() for argument list " + STR(tokenizeLinesOutput) + " for Macro <"+ macroName + "> has repeated argument, argumentList["+STR(argIndexI)+"] ="+ STR(argumentList[argIndexI]), " is same as argumentList[" + STR(argIndexJ)+"]="+ STR(argumentList[argIndexJ])
							errorRoutine(errorMessage)
							return False
						argIndexJ = argIndexJ + 1
					argIndexI = argIndexI + 1	

				PRINT("Valid argument list for macro ",macroName)
				
				# TO-DO: Can we have a case like where macro expansion text contains a quoted string literal that spills over to the next line?
				macroExpansionText = temp[endParenthesis+1:].strip()
				PRINT ("The macro",macroName,"expands into: <",macroExpansionText,">" )
				tokenizeLinesOutputResult = tokenizeLines(macroExpansionText)
				if tokenizeLinesOutputResult == False:
					errorMessage = "ERROR in defineMacroOnLine(): tokenizeLines(macroExpansionText) = False for macroExpansionText ="+macroExpansionText
					errorRoutine(errorMessage)
					return False
				else:
					tokenizeLinesOutput = tokenizeLinesOutputResult[0]
					
				if variadicMacro and variadicMacroArgSpecialName and '__VA_ARGS__' in tokenizeLinesOutput:
					errorMessage = "When we use a special symbol (%s) instead of the '...' for a variadic macro, the macro expansion text (%s) can no longer have '__VA_ARGS__' in it"%(variadicMacroArgSpecialName, list2plaintext(tokenizeLinesOutput))
					errorRoutine(errorMessage)
					return False
					
				macroExpansionTextAST = parseArithmeticExpression(tokenizeLinesOutput)
				if macroExpansionTextAST == False:
					errorMessage = "ERROR in defineMacroOnLine(): ERROR after calling parseArithmeticExpression(tokenizeLinesOutput) for tokenizeLinesOutput ="+STR(tokenizeLinesOutput)
					errorRoutine(errorMessage)
					return False
				else:
					PRINT ("============================\nmacroExpansionTextAST = \n", macroExpansionTextAST )

				# For variadic macros, when the macro expansion has special terms like __VA_OPT__(things) and ##__VA_ARGS__, 
				# special things happen when the __VA_ARGS__ part turns out to be null.
				#
				# For __VA_OPT__(things), the things part become omitted from the macro expansion when the __VA_ARGS__ part turns out to be null.
				# for ##__VA_ARGS__, the preceding comma is omitted if __VA_ARGS__ turns out to be null.
				#
				# So, for variadic macros with __VA_OPT__(things) and ##__VA_ARGS__ and when __VA_ARGS__ is indeed null, there is an alternative macro expansion.
				
				temp = tokenizeLinesOutput
				
				token__VA_ARGS__ = variadicMacroArgSpecialName if variadicMacroArgSpecialName else '__VA_ARGS__'
				
				PRINT("Before handling ## __VA_ARGS__, tokenizeLinesOutput for macro expansion text =",temp)
				while True:
					findIndex = findIndexOfSequenceInList([',','##',token__VA_ARGS__],temp) 
					if findIndex >= 0:
						del temp[findIndex:findIndex+3]
					else:
						break
				PRINT("After handling ## __VA_ARGS__, tokenizeLinesOutput for macro expansion text =",temp)
						
				while True:
					findIndex = findIndexOfSequenceInList(['__VA_OPT__','('],temp) 
					if findIndex >= 0:
						d = matchingBraceDistance(temp[findIndex+1:])
						if d < 0:
							errorMessage = "ERROR in preProcess - no matching ) for __VA_OPT__"
							errorRoutine(errorMessage)
							return False
						del temp[findIndex:findIndex+1+d+1]
					else:
						break
						
				if '__VA_OPT__' in temp:
					errorMessage = "ERROR in preProcess - illegal __VA_OPT__"
					errorRoutine(errorMessage)
					return False
				
				PRINT("After handling __VA_OPT__(), tokenizeLinesOutput for macro expansion text =",temp)

				while True:	# There still might be some __VA_ARGS__ without any preceding ## or __VA_OPT__
					findIndex = findIndexOfSequenceInList([token__VA_ARGS__],temp) 
					if findIndex >= 0:
						del temp[findIndex]
					else:
						break
				PRINT("After blanking out all other  __VA_ARGS__, tokenizeLinesOutput for macro expansion text =",temp)
				
				null__VA_ARGS__tokenizeLinesOutput = temp

				null__VA_ARGS__macroExpansionTextAST = parseArithmeticExpression(null__VA_ARGS__tokenizeLinesOutput)
				if null__VA_ARGS__macroExpansionTextAST == False:
					errorMessage = "ERROR in defineMacroOnLine(): ERROR after calling parseArithmeticExpression() for null__VA_ARGS__tokenizeLinesOutput ="+STR(null__VA_ARGS__tokenizeLinesOutput)
					errorRoutine(errorMessage)
					return False
				else:
					PRINT ("============================\nnull__VA_ARGS__macroExpansionTextAST = \n", null__VA_ARGS__macroExpansionTextAST )
					

		# macroDefinitions[] is a list of [macroName, macroArguments, macroExpansionText, macroProperties]

		# The fourth term, macroProperties{} has variable number of entries depending on what kind of macro it is.

		# Updated for all macros
		macroProperties["macroExpansionTextTokenized"] = macroExpansionTextTokenized
		
		# Special cases when the macro takes arguments
		if macroArguments:
			PRINT("\t\tAdding arguments",macroArguments, "for macro",macroName)
			PRINT("\t\targumentList =",argumentList)
			macroProperties["argumentList"] = argumentList
			macroProperties["macroExpansionTextAST"] = macroExpansionTextAST
			macroProperties["variadicMacro"] = variadicMacro
		
			# Special cases when the macro takes variable arguments
			if variadicMacro:
				macroProperties["variadicMacroExplicitArgumentCount"] = variadicMacroExplicitArgumentCount
				macroProperties["variadicMacroArgSpecialName"] = variadicMacroArgSpecialName
				macroProperties["null__VA_ARGS__macroExpansionTextAST"] = null__VA_ARGS__macroExpansionTextAST
		
		# First find out if it already exists on macroDefinitions or not. That is an ordered array of [macroName, macroArguments, macroExpansionText, macroProperties]
		
		if macroName in currentMacroNames:
			macroIndex = currentMacroNames.index(macroName)
			# Sanity check once again
			if len(currentMacroNames) != len(macroDefinitions) or not isinstance(macroDefinitions[macroIndex],list) or macroDefinitions[macroIndex][0] != currentMacroNames[macroIndex]:
				OUTPUT("Coding error - currentMacroNames and macroDefinitions out of sync - exiting")
				OUTPUT("\ncurrentMacroNames =",STR(currentMacroNames),"\n", "macroDefinitions =",STR(macroDefinitions))
				sys.exit()
			PRINT("Re-definition of existing macro", macroName, "at macroIndex =",macroIndex,", of currentMacroNames. Exiting entry =",macroDefinitions[macroIndex])
			PRINT("updating existing entry.")
			macroDefinitions[macroIndex] = [macroName, macroArguments, macroExpansionText, macroProperties]
		else:
			PRINT("New definition of existing macro", macroName, " - adding it at the end of the array.")
			macroDefinitions.append([macroName, macroArguments, macroExpansionText, macroProperties])
			currentMacroNames.append(macroName)
	
	return True

# This function takes the input lines and applied all possible macros on it
def invokeMacrosOnLine(i):
	global lines, srcFileDetails, runtimeStatementLineNumbers	# Keeps a list of which all line numbers are runtime statements. We need this so that we can invoke the interleaving check judiciously.
	
	######################################################################
	##																	##
	##		MODIFY CURRENT LINE UNTIL IT IS NOT MODIFIABLE  			##
	##																	##
	######################################################################
		
	# Here is the logic we follow. There are only two kinds of operations that modify a line - macro invocation and #include.
	# (Recall that things like #if impacts OTHER lines, but NOT the current line)
	#
	# Hence, we keep on going through macro invocations and #include processing until we are certain the current line cannot be modified any more.
	# We, of course, follow the rules. For example, if the line starts with #define, we know that we cannot touch that line for macro invocations,
	# even if that line contains them. We take #define statements as-is.
	
	processCurrentLineAgain = True

	while processCurrentLineAgain:	# We keep on processing the current line until we are guaranteed that it is not modifiable any more
								# i.e., no more macros in it, no #include etc.
		
		# The very first thing we do is to keep a copy of the current line, so that we know whether there was any change made via macro invocations or #include
		currentLineBeforeMacroInvocationsAndIncludeProcessing = lines[i]
		
		######################################################################
		##																	##
		##		M A C R O   I N V O C A T I O N  							##
		##																	##
		######################################################################
			
		# There are some macro invocations that we are not supposed to replace. To make sure we don't hit them again and again, 
		# this index below always moves forward. The reason we use a while loop is because the same macro can be invoked on a single line multiple times.
		
		checkForMacroFromTokenIndex = 0
		while True:
		
			PRINT("\nCurrently checking line #",i,"from token #",checkForMacroFromTokenIndex)
			# Make sure that we are not inadvertantly using variables from previous loop
			try:
				del macroNameFoundAtIndex, macroName, macroIndex, macroArguments, macroExpansionText, macroProperties, macroExpansionTextTokenized, argumentList, macroExpansionTextAST, variadicMacro, variadicMacroExplicitArgumentCount, variadicMacroArgSpecialName, null__VA_ARGS__macroExpansionTextAST
			except NameError:	
				PRINT("NameError occured while we were trying to delete some variables that we thought were used in the previous iteration of the while loop, but in reality it wasn't used. This is absolutely OK and nothing to worry.")
				
			# We tokenize every time, since we do not know how the previous run changed the line. Because we did TEXT replacement, not TOKEN replacement.
			tokenizeLinesOutputResult = tokenizeLines(lines[i])
			if tokenizeLinesOutputResult == False:
				errorMessage = "ERROR in invokeMacrosOnLine() after calling tokenizeLines(lines[i]) for lines[" + STR(i) + "] = " + lines[i]
				errorRoutine(errorMessage)
				return False
			else:
				tokenizeLinesOutput = tokenizeLinesOutputResult[0]
				PRINT("\n\nFor lines[",i,"], tokenizeLinesOutput =",tokenizeLinesOutput)
				
			if len(tokenizeLinesOutput) == 0:
				processCurrentLineAgain = False
				break
			elif tokenizeLinesOutput[0] == preProcessorSymbol and len(tokenizeLinesOutput) >= 2 and tokenizeLinesOutput[1] in ('define', 'undef', 'ifdef', 'ifndef'):
				PRINT("The current line is a 'define', 'undef', 'ifdef', or 'ifndef' preprocessor command - skipping it")
				processCurrentLineAgain = False
				break
			
			PRINT("Advancing the token pointer index checkForMacroFromTokenIndex=",checkForMacroFromTokenIndex,"within the current line to the next occurrence of any macro name")
			# Advance the token pointer within the current line to the next occurrence of any macro name
			while True:
				if checkForMacroFromTokenIndex >= len(tokenizeLinesOutput):
					PRINT("End of line reached for checkForMacroFromTokenIndex =",checkForMacroFromTokenIndex,"(the current tokenizeLinesOutput has",len(tokenizeLinesOutput),"members")
					break
				elif tokenizeLinesOutput[checkForMacroFromTokenIndex] not in currentMacroNames:
					PRINT("tokenizeLinesOutput[",checkForMacroFromTokenIndex,"] =",tokenizeLinesOutput[checkForMacroFromTokenIndex]," is not a macro name - advancing the token pointer")
					checkForMacroFromTokenIndex += 1
				elif tokenizeLinesOutput[checkForMacroFromTokenIndex] in currentMacroNames:
					PRINT("tokenizeLinesOutput[",checkForMacroFromTokenIndex,"] =",tokenizeLinesOutput[checkForMacroFromTokenIndex]," is indeed a macro name - time to replace")
					break
					
			
			# This is not redundant - do the same check again so that we can get out of the outer while loop
			if checkForMacroFromTokenIndex >= len(tokenizeLinesOutput):
				processCurrentLineAgain = False
				break
			elif tokenizeLinesOutput[checkForMacroFromTokenIndex] not in currentMacroNames:	# Should never happen
				EXIT ("Coding error in invokeMacrosOnLine() while looking for macroName")
			else:
				PRINT("Currently replacing macro invocation in line #",i,"from token #",checkForMacroFromTokenIndex)
				macroNameFoundAtIndex = checkForMacroFromTokenIndex
				macroName = tokenizeLinesOutput[macroNameFoundAtIndex]
				macroIndex = currentMacroNames.index(macroName)
				
				# Sanity check once again
				if len(currentMacroNames) != len(macroDefinitions) or not isinstance(macroDefinitions[macroIndex],list) or macroDefinitions[macroIndex][0] != currentMacroNames[macroIndex]:
					OUTPUT("Coding error - currentMacroNames and macroDefinitions out of sync - exiting")
					OUTPUT("\ncurrentMacroNames =",STR(currentMacroNames),"\n", "macroDefinitions =",STR(macroDefinitions))
					sys.exit()

				# get all the details of the macro
				macroArguments = macroDefinitions[macroIndex][1]
				macroExpansionText = macroDefinitions[macroIndex][2]
				macroProperties = macroDefinitions[macroIndex][3]
				# Updated for all macros
				macroExpansionTextTokenized = macroProperties["macroExpansionTextTokenized"]
				
				# Special cases when the macro takes arguments
				if macroArguments != "":
					argumentList = macroProperties["argumentList"]
					macroExpansionTextAST = macroProperties["macroExpansionTextAST"]
					variadicMacro = macroProperties["variadicMacro"]
				
					# Special cases when the macro takes variable arguments
					if variadicMacro:
						variadicMacroExplicitArgumentCount = macroProperties["variadicMacroExplicitArgumentCount"]
						variadicMacroArgSpecialName = macroProperties["variadicMacroArgSpecialName"]
						null__VA_ARGS__macroExpansionTextAST = macroProperties["null__VA_ARGS__macroExpansionTextAST"]
				
				# Do not replace it if it is a #undef(macroName) / #ifdef(macroName) / #ifndef(macroName), or a defined(macroName) in a #if statement
				if tokenizeLinesOutput[0] == preProcessorSymbol and len(tokenizeLinesOutput) >= 2 and tokenizeLinesOutput[1] in ('define', 'undef', 'ifdef', 'ifndef'):
					checkForMacroFromTokenIndex = macroNameFoundAtIndex+1
					PRINT("Found", macroName,"at token index",macroNameFoundAtIndex)
					if checkForMacroFromTokenIndex != 3:
						errorMessage = "ERROR in invokeMacrosOnLine(): Found "+ macroName +"at token index " + STR(macroNameFoundAtIndex) +" , which is an error."
						errorRoutine(errorMessage)
						return False
					continue
				elif tokenizeLinesOutput[0] == preProcessorSymbol and len(tokenizeLinesOutput) >= 2 and tokenizeLinesOutput[1] == 'if' and macroNameFoundAtIndex>3 and tokenizeLinesOutput[macroNameFoundAtIndex-2]=='defined' and tokenizeLinesOutput[macroNameFoundAtIndex-1]=='(' and tokenizeLinesOutput[macroNameFoundAtIndex+1]==')' :
					checkForMacroFromTokenIndex = macroNameFoundAtIndex+2
					PRINT("Found", macroName,"at token index",macroNameFoundAtIndex,", as part of",tokenizeLinesOutput[macroNameFoundAtIndex-2:macroNameFoundAtIndex+2])
					continue
				
				PRINT ("BEFORE invoking macro", macroName, "line #",i," = <",lines[i],">" )
				
				# Now, we want to find the exact character locations of THIS very invocation of macroName (recall that a single line may contain 
				macroInvocationLocation = findTokenListInLines(lines[i],macroName, macroNameFoundAtIndex)
				if macroInvocationLocation == False:
					errorMessage = "ERROR in invokeMacrosOnLine() after calling findTokenListInLines(lines[i],macroName) for lines[" + STR(i) + "] = " + lines[i] +" and macroName =" + macroName 
					errorRoutine(errorMessage)
					return False
				# The output from findTokenListInLines() is [tokenStartIndex,startLineNumber,startLineCharNumber,endLineNumber,endLineCharNumber]
				elif macroInvocationLocation[1] != 0 or macroInvocationLocation[3] != 0 or lines[i][macroInvocationLocation[2]:macroInvocationLocation[4]+1] != macroName:
					errorMessage = "ERROR in invokeMacrosOnLine() - the match must happen within current line, while its occurrence location is "+ STR(macroInvocationLocation) + "and the lines[" + STR(i) + "][" + STR(macroInvocationLocation[2])+":"+ STR(macroInvocationLocation[4]+1)+"] = <"+lines[i][macroInvocationLocation[2]:macroInvocationLocation[4]+1]+">, while macroName = <"+macroName+">" 
					errorRoutine(errorMessage)
					return False
					sys.exit()

				# Replace object-like macros
				
				if macroArguments == "":
				
					PRINT ("The macro", macroName,"appears in line #",i+macroInvocationLocation[1],"char #",macroInvocationLocation[2] )
					lines[i] = lines[i][:macroInvocationLocation[2]]+macroExpansionText+lines[i][macroInvocationLocation[4]+1:]
					PRINT ("AFTER invoking macro", macroName, "line #",i," = <",lines[i],">" )
		
				# There is one major difference in the handling method when a macro takes argument (compared to one that doesn't).
				# For one with no arguments, we only care about the current line, since we are talking about matching a single token (the macroName).
				# However, when you tackle a macro with arguments, it is very much possible that the macroName is in one line and the arguments in subsequent lines.
				# So, you need to potentially handle ALL the lines starting from the current one for finding the proper scope of macro invocation.
				
				elif macroArguments != "":

					# So, after all these, we use the following method.
					# - If the macro is variadic and __VA_ARGS__ is null, use null__VA_ARGS__macroExpansionTextAST.
					# - For all other cases, use macroExpansionTextAST.
			
					# We do this because the parseArithmeticExpression routine expects the function name
					# If we just give the (A, B, C) kind of text instead of the expected func(A, B, C), it might error out
					
					stringBeforeMacroName = "" if macroInvocationLocation[2] == 0 else lines[i][:macroInvocationLocation[2]]
					stringAfterMacroName = lines[i][macroInvocationLocation[4]+1:]
					PRINT ("The stringBeforeMacroName <", macroName, "> = <",stringBeforeMacroName,">, i=",i )
					PRINT ("The stringAfterMacroName <", macroName, "> = <",stringAfterMacroName,">, i=",i )
			
					# The macro argument list could be distributed over many lines
					restLines = []
					PRINT ("Currently, lines[%d]=<%s>"%(i,lines[i]) )
					if macroInvocationLocation[4] < len(lines[i])-1:
#									PRINT ("Appending <%s> to restLines, curretly i=%d"%(lines[i][macroInvocationLocation[4]+1:],i) )
						restLines.append(lines[i][macroInvocationLocation[4]+1:])
					lineIndex = i+1
					while lineIndex < len(lines):
#									PRINT ("Appending <%s> to restLines"%lines[lineIndex] )
						restLines.append(lines[lineIndex])
						lineIndex = lineIndex + 1
					
					PRINT ("Now going to tonize restLines = ",restLines )
					invocationTokensResult = tokenizeLines(restLines)	# This contains the parenthesized arguments, plus whatever comes after
					if invocationTokensResult == False:
						errorMessage = "ERROR in invokeMacrosOnLine() while tokenizeLines(restLines) where restLines = " + STR(restLines)
						errorRoutine(errorMessage)
						return False
					else:
						invocationTokens = invocationTokensResult[0]
					
					if invocationTokens[0] != '(':
						errorMessage = "ERROR in invokeMacrosOnLine() after tokenizeLines(restLines) - the first token is not a '('"
						errorRoutine(errorMessage)
						return False
					
					endMatchingBraceDistance = matchingBraceDistance(invocationTokens)	# This tells exactly where the end-brace for the parenthesized arguments occur
					if endMatchingBraceDistance < 1:
						errorMessage = "ERROR in invokeMacrosOnLine(): Did not find argument list for macro " + macroName + "in line # " + STR(i) + STR( invocationTokens )
						errorRoutine(errorMessage)
						return False
					else:
						invocationTokensArgsOnly = invocationTokens[:endMatchingBraceDistance+1]	# Starts and ends with braces
						PRINT("invocationTokensArgsOnly = <",invocationTokensArgsOnly,">, which we will parse for splitting the arguments")
						argListInvoked = parseArgumentList(invocationTokensArgsOnly)
						if argListInvoked == False:
							errorMessage = "ERROR in invokeMacrosOnLine(): ERROR during parsing invocationTokensArgsOnly = <"+ STR(invocationTokensArgsOnly) + "> for arguments"
							errorRoutine(errorMessage)
							return False
						PRINT ("After parsing, the argument list for macro",macroName,"invocation in line #",i,"=", argListInvoked )
						
						# Verify that it matches the macro's argument count
						
						# For variadic Macro, the variable part of argument list might be empty. But any explicit argument must be provided
						if variadicMacro and variadicMacroExplicitArgumentCount > len(argListInvoked):
							errorMessage = "ERROR in invokeMacrosOnLine() - len(argListInvoked) =" + STR(len(argListInvoked)) + "< variadicMacroExplicitArgumentCount =" + STR(variadicMacroExplicitArgumentCount)
							erroRoutine(errorMessage)
							return False
						# For non-variadic Macro, the argument list count must match
						elif not variadicMacro and len(argListInvoked) != len(argumentList):
							errorMessage = "ERROR  in invokeMacrosOnLine() - len(argListInvoked) =" + STR(len(argListInvoked)) + "!= len(argumentList) =" + STR(len(argumentList) )
							erroRoutine(errorMessage)
							return False
						else:
							macroIsVariadicWithNull__VA_ARGS__ = False
							# If variadic macro, just create a single comma-separated string with all the excess arguments. This will be input 
							if variadicMacro: 
								PRINT("Original",len(argListInvoked),"-member argListInvoked =",STR(argListInvoked))
								
								# Handle a special case - if the code mentions the last argument as NULL like this below, then convert it to a blank string
								#
								#  #define eprintf(format, ...) fprintf (stderr, format, __VA_ARGS__)
								#  eprintf("success!\n", );		// Observe that the coder didn't code it as <eprintf("success!\n");> - there is a comma at the end
								if argListInvoked[-1]==[]:
									argListInvoked[-1] = ''
									PRINT("Which is then changed to",len(argListInvoked),"-member argListInvoked =",STR(argListInvoked))
									
								if variadicMacroExplicitArgumentCount + 1 == len(argListInvoked):
									PRINT("Exactly one argument supplied against __VA_ARGS__ , hence no special processing required")
								elif variadicMacroExplicitArgumentCount == len(argListInvoked):	# The __VA_ARGS__ part is null
									PRINT("Adding a dummy NULL string to be used as a replacement for the __VA_ARGS__")
									argListInvoked.append("")	
									macroIsVariadicWithNull__VA_ARGS__ = True
								else:
									commaSeparated__VA_ARGS__ = ",".join(argListInvoked[variadicMacroExplicitArgumentCount:])
									del argListInvoked[variadicMacroExplicitArgumentCount:]
									argListInvoked.append(commaSeparated__VA_ARGS__)
								PRINT("Transformed",len(argListInvoked),"-member argListInvoked =",STR(argListInvoked))
								if len(argListInvoked) != len(argumentList):
									EXIT("ERROR in invokeMacrosOnLine() during processing variadic macros - should never happen")
									
							PRINT ("The argument count (",len(argumentList),") is acceptable" )
							
							# Now replace the macro expansion AST
							
							PRINT ("\n\n\n=============================================================\nCreating the replacement dictionary")
							argumentInvocationDictionary = OrderedDict()
							for argIndex in range(len(argumentList)):
								# TO-DO: Here is a question - do we replace it with the literal, or the AST version of it?
								# Problem - there is no guarantee that a parameter passed to a macro will be a properly formed AST
								argInvokedAST = parseArithmeticExpression(argListInvoked[argIndex])
								if argInvokedAST == False:
									errorMessage = "ERROR in invokeMacrosOnLine() after calling parseArithmeticExpression(argListInvoked[argIndex]) for argListInvoked["+STR(argIndex)+"] ="+STR(argListInvoked[argIndex]) 
									erroRoutine(errorMessage)
									return False
								else:
									PRINT ("Replacing",argumentList[argIndex],"with",argInvokedAST )
									argumentInvocationDictionary[argumentList[argIndex]]=argInvokedAST
							PRINT ("argumentInvocationDictionary =",argumentInvocationDictionary )
							PRINT ("=============================================================\n\n\n")
							
							# Recall the following.
							# - If the macro is variadic and __VA_ARGS__ is null, use null__VA_ARGS__macroExpansionTextAST.
							# - For all other cases, use macroExpansionTextAST.
							if macroIsVariadicWithNull__VA_ARGS__:
								PRINT ("null__VA_ARGS__macroExpansionTextAST =",null__VA_ARGS__macroExpansionTextAST )
								# This is the precise place where we are actually doing the macro expansion
								functionCallResult = replaceArguments (null__VA_ARGS__macroExpansionTextAST, argumentInvocationDictionary)
							else:
								PRINT ("macroExpansionTextAST =",macroExpansionTextAST )
								# This is the precise place where we are actually doing the macro expansion
								functionCallResult = replaceArguments (macroExpansionTextAST, argumentInvocationDictionary)
								
							if functionCallResult[0] == False:
								PRINT ("Exiting - ERROR while invoking function replaceArguments for macroExpansionTextAST=", macroExpansionTextAST," and argumentInvocationDictionary =",argumentInvocationDictionary )
								return False
							argListInvokedReplacedAST = functionCallResult[1]
							if '##' in macroExpansionText:
								argListInvokedReplacedASTDoubleHash = applyDoubleHashOperator(argListInvokedReplacedAST)
							else:
								argListInvokedReplacedASTDoubleHash = argListInvokedReplacedAST
							PRINT ("\n\n\n#### BEGIN ####=============================================================\n\n\n\n")
							PRINT ("macroExpansionText = ",macroExpansionText )
							PRINT ("argumentList = ",argumentList )
							PRINT ("argListInvoked = ",argListInvoked )
							PRINT ("macroExpansionTextAST = ",macroExpansionTextAST )
							PRINT ("argListInvokedReplacedAST = ", argListInvokedReplacedAST )
							PRINT ("argListInvokedReplacedASTDoubleHash = ",argListInvokedReplacedASTDoubleHash )
							
							# Now it's time to convert the AST back to the text
							argListInvokedReplacedText = outputTextArithmeticExpressionFromAST(argListInvokedReplacedASTDoubleHash)
							if argListInvokedReplacedText == False:
								errorMessage = "ERROR in invokeMacrosOnLine() after calling outputTextArithmeticExpressionFromAST(argListInvokedReplacedASTDoubleHash) for argListInvokedReplacedASTDoubleHash = "+STR(argListInvokedReplacedASTDoubleHash)
								errorRoutine(errorMessage)
								return False
							PRINT ("argListInvokedReplacedText =",argListInvokedReplacedText )
							PRINT ("\n\n\n\n#### END ####=============================================================\n\n\n")
							
							# Now replace the text within the restLines. Once we do that, we will plug it back to the actual lines
							macroInvocationSuffix = ""	# On the line where the macroName(argumentList) finally ends, the rest of the characters
							macroExpansionPosition = findTokenListInLines(restLines,invocationTokensArgsOnly)
							if macroExpansionPosition == False:
								errorMessage = "ERROR after calling findTokenListInLines(restLines,invocationTokensArgsOnly) for restLines = <"+restLines+"> and invocationTokensArgsOnly = "+STR(invocationTokensArgsOnly)
								errorRoutine(errorMessage)
								return False
							elif macroExpansionPosition[0]<0 or macroExpansionPosition[1]<0 or macroExpansionPosition[2]<0 or macroExpansionPosition[3]<0 or macroExpansionPosition[4]<0:
								PRINT ("macroExpansionPosition = ",macroExpansionPosition )
								errorMessage= "ERROR in invokeMacrosOnLine() : Was looking for "+STR(invocationTokensArgsOnly)+" inside <"+restLines+">"
								errorRoutine(errorMessage)
								return False
							else:
								if macroExpansionPosition[4] < len(restLines[macroExpansionPosition[3]])-1:
									macroInvocationSuffix = restLines[macroExpansionPosition[3]][macroExpansionPosition[4]+1:]
									
							# TO-DO: Currently we are putting a space before joining the below 3 fragments so that we accidentally do not concatenate variable names.
							# TO-DO: Try to see if we can do it in a better way (it is currently pretty much a hack).
							newLineAfterMacroInvocation = stringBeforeMacroName + " " + argListInvokedReplacedText + " " + macroInvocationSuffix
							impactedLines = lines[i:i+macroExpansionPosition[3]+1]
							PRINT ("impactedLines = <%s>"%impactedLines )
							PRINT ("newLineAfterMacroInvocation = <%s>"%newLineAfterMacroInvocation )
							PRINT ("\n\n\n\n\nPrinting the existing Lines before macro <",macroName, "> invocation replacement" )
							PRINT ("===============================================" )
							returnStatus = printLines(lines)
							if returnStatus == False:
								return False
							PRINT ("===============================================" )
							lines[i] = newLineAfterMacroInvocation
							delLineIndex = 1
							while delLineIndex <= macroExpansionPosition[3]:
								PRINT ("Removing ALL tokens from lines[",i+delLineIndex,"] =",lines[i+delLineIndex],", essentially making it blank line" )
								lines[i+delLineIndex] = '\n'
								delLineIndex = delLineIndex + 1
							PRINT ("===============================================" )
							PRINT ("\n\n\n\n\nPrinting the existing Lines after macro <",macroName, "> invocation replacement" )
							PRINT ("===============================================" )
							returnStatus = printLines(lines)
							if returnStatus == False:
								return False
							PRINT ("===============================================" )
		

		# I am shifting two identations to the left
		PRINT("After handling macro invocations, lines[",i,"] = ",lines[i])

		# All macro invocations have been done. Now let's re-tokenize
		tokenizeLinesResult = tokenizeLines(lines[i])
		PRINT("tokenized lines[",i,"] =",tokenizeLinesResult)
		
		if tokenizeLinesResult == False:
			errorMessage = "ERROR in invokeMacrosOnLine() before doing macro expansion after calling tokenizeLines(currLine) for currLine =" + lines[i]
			errorRoutine(errorMessage)
			return False
		else:
			macroTokenList = tokenizeLinesResult[0]

		PRINT ("searching for preprocessing commands in line # ",i, lines[i] )
		currLine = lines[i]
		PRINT("lines[",i,"] = <"+lines[i]+">, macroTokenList =",macroTokenList)

		#preprocessingDirectives = ('#include', '#if', '#ifdef', '#ifndef', '#else', '#elif', '#endif', '#define', '#undef', '#line', '#error', '#pragma')

		if macroTokenList and macroTokenList[0] in preprocessingDirectives:
			PRINT("macroTokenList[0] =",macroTokenList[0],"is a preprocessingDirectives")
		
		##########################################################
		##														##
		##				I N C L U D E							##
		##														##
		##########################################################
		
		# Handle the include statements
		# Recall that when there is user-level included files, they are enclosed in double-quotes. So the parser would include the whole thing as a solitary
		# double-quoted string.
		# On the other hand, if the include statement is like #include <a.txt>, then the parser would break up <a.txt> as '<','a','.','txt','>'. 
		# So, you would want to join all the tokens in between the <...>
		if macroTokenList and macroTokenList[0] == preProcessorSymbol and len(macroTokenList)>= 2 and macroTokenList[1]=='include':
			PRINT("Processing included files in lines[",i,"] =",lines[i])
			if "<" not in macroTokenList and len(macroTokenList) != 3:
				errorMessage = "ERROR in invokeMacrosOnLine() after calling tokenizeLines() for line # %d = <%s> - #include must have exactly one arguement" %(i,lines[i] )
				errorRoutine(errorMessage)
				return False
			elif "<" in macroTokenList and ">" in macroTokenList and len(macroTokenList) < 5:
				errorMessage = "ERROR in invokeMacrosOnLine() after calling tokenizeLines() for line # %d = <%s> - #include must have exactly one arguement" %(i,lines[i] )
				errorRoutine(errorMessage)
				return False
			elif len(macroTokenList) >= 5 and not (macroTokenList[2] == '<' and macroTokenList[-1] == '>'):
					errorMessage = "ERROR in invokeMacrosOnLine() after calling tokenizeLines() for line # %d = <%s> - must be like #include <filename>" %(i,lines[i] )
					errorRoutine(errorMessage)
					return False
			elif len(macroTokenList) == 3 and (macroTokenList[2][0] != '"' or macroTokenList[2][-1] != '"' or len(macroTokenList[2])<=2):
					errorMessage = "ERROR in invokeMacrosOnLine() after calling tokenizeLines() for line # %d = <%s> - must be like #include \"filename\"" %(i,lines[i] )
					errorRoutine(errorMessage)
					return False
			else: 
				includedFileName = macroTokenList[2][1:-1].strip() if len(macroTokenList) == 3 else ''.join(macroTokenList[3:-1])
				if not includedFileName:
					errorMessage = "ERROR in invokeMacrosOnLine() - included filename cannot be blank"
					errorRoutine(errorMessage)
					return False
					
				MUST_PRINT("includedFileName =",includedFileName)
				slash = "\\" if "\\" in os.getcwd() else "/" if "/" in os.getcwd() else ""
				if slash not in ["\\","/"]:
					errorMessage = "ERROR in invokeMacrosOnLine() - cannot figure out if Windows or Unix - exiting"
					errorRoutine(errorMessage)
					return False
				
				# It is possible that we have statements like #include "machine/ansi.h" where the slash is already supplied
				if "\\" in includedFileName or "/" in includedFileName:
					PRINT ("We have the case where the included file",includedFileName, "already contains a folder")
					if "\\" in includedFileName and slash != "\\":
						includedFileNameModified = includedFileName.replace("\\",slash)
						PRINT("includedFileName =<"+includedFileName+"> now replaced with <"+includedFileNameModified+">")
						includedFileName = includedFileNameModified
					elif "/" in includedFileName and slash != "/":
						includedFileNameModified = includedFileName.replace("/",slash)
						PRINT("includedFileName =<"+includedFileName+"> now replaced with <"+includedFileNameModified+">")
						includedFileName = includedFileNameModified
					else:
						errorMessage = "ERROR in invokeMacrosOnLine() - bad coding for include file handling - exiting"
						errorRoutine(errorMessage)
						return False
					
				includeFilePaths = returnFilePathList(INCLUDE_FILE_PATHS)
				fileFound = False
				# First look into the current directory
				if os.path.exists(includedFileName):
					path = os.getcwd()
					path = path if path[-1] == slash else path+slash
					fileFound = True
					PRINT("The file",includedFileName,"is present in the current working directory",path)
				# Next look into the included paths
				elif includeFilePaths != False and includeFilePaths != []:
					for item in includeFilePaths:
						if not checkIfString(item) or item[-1]!=slash:
							errorMessage = "ERROR in invokeMacrosOnLine() - included file path <%s> is illegal"%(STR(item))
							errorRoutine(errorMessage)
							return False
						if os.path.isfile(item+includedFileName):
							path = item
							fileFound = True
							PRINT("The file",includedFileName,"is present in the include file path",path)
							break
				# Next look into the subdirectories of the included paths
				if not fileFound:
					PRINT("Looking into all subdirectories of included paths")
					for item in includeFilePaths:
						for folder, subfolder, files in os.walk(item):
							if folder != item:
								if slash in includedFileName:
									if os.path.isfile(os.path.join(folder,includedFileName)):
										path = folder
										if path[-1]!=slash:
											path += slash
										fileFound = True
										PRINT("The file",includedFileName,"is present in the include file path",path)
										break
								else:
									for f in files:
										if includedFileName == f:
											PRINT ("File exists, path is ", os.path.join(folder, f))
											fileFound = True
											path = folder
											if path[-1]!=slash:
												path += slash
											PRINT("The file",includedFileName,"is present in the following subdirectory in the include file path",path)
											break
							if fileFound:
								break
						if fileFound:
							break
								
				if fileFound:
					with open(path+includedFileName, "r") as includedFile:
						try:
							includedLines = includedFile.readlines()
							if not checkIfStringOrListOfStrings(includedLines):
								errorMessage = "ERROR in invokeMacrosOnLine(): Bad coding: input code file content is NOT string - type(includedLines) = "+STR(type(includedLines))
								errorRoutine(errorMessage)
								return False
							
						except ValueError: # Empty file
							includedLines = [""]
				else:
					errorMessage = "ERROR in invokeMacrosOnLine() - cannot open included code file <"+includedFileName+">"
					errorRoutine(errorMessage)
					return False
					
				PRINT ("Included code file has",len(includedLines),"lines, which contains:", includedLines )
				PRINT ("Before inserting, len(lines) =",len(lines))

				# Sanity check before inserting the included file
				totalLineCount = 0
				maxLineNumber = -1
				for row in srcFileDetails:
					for segmentNum in range(1,len(row)):
						totalLineCount += row[segmentNum][1]-row[segmentNum][0]+1
						if row[segmentNum][1] > maxLineNumber:
							maxLineNumber = row[segmentNum][1]
				if totalLineCount != len(lines) or totalLineCount != maxLineNumber+1:
					OUTPUT("Error: totalLineCount (",totalLineCount,")  != len(lines) (",len(lines),") or maxLineNumber(",maxLineNumber,")+1\nsrcFileDetails=\n")
					for row in srcFileDetails:
						OUTPUT(row)
					EXIT("Bad coding")
					
				PRINT("\nBefore inserting includedFileName =",includedFileName,"at line #",i,"srcFileDetails =")
				PRINT("srcFileDetails =\n")
				for row in srcFileDetails:
					PRINT(row)
				PRINT("\n\n")
				
				oldNumberOfLines = len(lines)
				# Insert the newly included lines in lines
				tempLines = lines[:i]
				tempLines.extend(includedLines)
				if i<len(lines)-1:
					tempLines.extend(lines[i+1:])

#				MUST_PRINT("\nBefore inserting includedFileName =",includedFileName,"at line #",i,"srcFileDetails =")
#				for row in srcFileDetails:
#					MUST_PRINT(row)
				
				# Important: When we add numAddedLines, the total number of lines goes up by (numAddedLines-1), not numAddedLines. Because we are also consuming one line.
				numAddedLines = len(includedLines)

				# Overwrite the lines
				lines = tempLines
				PRINT ("After inserting, len(lines) =",len(lines))
				newNumberOfLines = len(lines)

				insertionRow = -10000000000000
				insertionSegment = -100000000000000000
				

				# update the srcFileDetails
				if srcFileDetails:
					insertionPointFound = False
					insertionPointFoundRowNum = None
					for rowNum in range(len(srcFileDetails)):
						row = srcFileDetails[rowNum]
						if insertionPointFound:
							break
						PRINT("Now dealing with", row)
						for segmentNum in range(1,len(row)):
							start = row[segmentNum][0]
							end = row[segmentNum][1]
							if start > end:
								OUTPUT("Bad coding - start > end in row =", row)
								sys.exit()
							if start <= i <= end:
								insertionPointFound = True
								insertionPointFoundRowNum = rowNum
								# Split the existing entry by updating the end of existing entry and adding one after that
								row[segmentNum][1] = i-1
								#Insert new
#								MUST_PRINT("Before inserting the new entry, row =",row)
								# It is a pretty bad idea to insert into a row you are looping on. But since we are breaking immediately, it is OK to do it here
								row.insert(segmentNum+1,[i+numAddedLines,end+numAddedLines-1])
								# Update the entries in row # insertionPointFoundRowNum, because we will NOT touch this row later
								for entryIndex in range(segmentNum+2,len(row)):
									row[entryIndex][0] += numAddedLines-1
									row[entryIndex][1] += numAddedLines-1
#								MUST_PRINT("After inserting the new entry, row =",row)
								break
					if not insertionPointFound:
						OUTPUT("Bad coding - by now should have found the insertion point i=",i)
						OUTPUT("srcFileDetails =\n")
						for row in srcFileDetails:
							OUTPUT(row)
						sys.exit()
					srcFileDetails.append([[includedFileName,path],[i,i+numAddedLines-1]])
					
					# Shift all the subsequent by (numAddedLines-1)
					for rowNum in range(len(srcFileDetails)):
						row = srcFileDetails[rowNum]
						if rowNum == insertionPointFoundRowNum:
							continue
						for segmentNum in range(1,len(row)):
							start = row[segmentNum][0]
							end = row[segmentNum][1]
							if start > i:
								row[segmentNum][0] += numAddedLines-1
								row[segmentNum][1] += numAddedLines-1
						
				# Delete the impossible entries (start < end)
				if srcFileDetails:
					newSrcFileDetails = []	# It is very hard to propertly DELETE items from a list
					for row in srcFileDetails:
						newRow = []
						PRINT("Now dealing with", row)
						for segmentNum in range(1,len(row)):
							start = row[segmentNum][0]
							end = row[segmentNum][1]
							if start <= end:
								newRow.append(row[segmentNum])
#							else:
#								MUST_PRINT("Not copying row[segmentNum=",segmentNum,"] = ",row[segmentNum])
						if len(newRow)>0:
							newRow.insert(0,row[0])
							newSrcFileDetails.append(newRow[:])
							
				# Overwrite the original file			
				srcFileDetails = newSrcFileDetails[:]
				
				# Sanity check again
				totalLineCount = 0
				maxLineNumber = -1
				for row in srcFileDetails:
					for segmentNum in range(1,len(row)):
						totalLineCount += row[segmentNum][1]-row[segmentNum][0]+1
						if row[segmentNum][1] > maxLineNumber:
							maxLineNumber = row[segmentNum][1]
				if totalLineCount != len(lines) or totalLineCount != maxLineNumber+1:
					OUTPUT("Error: totalLineCount (",totalLineCount,")  != len(lines) (",len(lines),") or maxLineNumber(",maxLineNumber,")+1\nsrcFileDetails=\n")
					for row in srcFileDetails:
						OUTPUT(row)
					EXIT("Bad coding")
				else:
					PRINT("After adding content of file",includedFileName, ", totalLineCount (",totalLineCount,")  == len(lines) (",len(lines),")\nsrcFileDetails=\nlines=")
					PRINT(lines)
				
				PRINT("\nAfter inserting includedFileName =",includedFileName,"at line #",i,"srcFileDetails =")
				PRINT("srcFileDetails =\n")
				for row in srcFileDetails:
					PRINT(row)
				PRINT("\n\n")
				
				if runtimeStatementLineNumbers and newNumberOfLines > oldNumberOfLines:
					PRINT("Thanks to the #include statement on line #",i,", a total of",(newNumberOfLines - oldNumberOfLines),"new lines were added.")
					PRINT("Therefore, we need to change the runtime statement line numbers that previously occurred after line #",i)
					PRINT("Before changing the line numbers past",i,", runtimeStatementLineNumbers =",runtimeStatementLineNumbers)
					for r in range(len(runtimeStatementLineNumbers)):
						if runtimeStatementLineNumbers[r]>i:
							runtimeStatementLineNumbers[r] += newNumberOfLines - oldNumberOfLines
					PRINT("After  changing the line numbers past",i,", runtimeStatementLineNumbers =",runtimeStatementLineNumbers)

		# Remove Multi-line comments. We really should not have to do this again and again since the macros are not supposed to create new comments.
		# Still, suppose one included file contained the beginning of a comment like /* ....., and another included file contained the end of comment like ..... */
		removeComments()
		
		# Condense each Multi-line Macro into a single-line macro 
		status = condenseMultilineMacroIntoOneLine()
		if status == False:
			errorMessage = "ERROR in invokeMacrosOnLine() after calling condenseMultilineMacroIntoOneLine()"
			errorRoutine(errorMessage)
			return False
			
		if currentLineBeforeMacroInvocationsAndIncludeProcessing != lines[i]:
			processCurrentLineAgain = True
		else:
			processCurrentLineAgain = False
			
	return True

############################################################################
#  1. PROCESS COMMENTS                                                     #
#  2. CONVERT MULTI-LINE MACROS INTO SINGLE-LINE MACROS                    #
#  3. HANDLE include "filename" STATEMENTS                                 #
#                                                                          #
#  THIS function HAPPENS BEFORE (AND WITHOUT) TOKENIZING THE lines.        #
#  HOWEVER, WITHIN THIS FUNCTION, WE DO TOKENIZE EVERY LINE.               #
#                                                                          #
#  One note of caution. Do not use something like currLine in this routine,#
#  since the currLine is always getting updated. Use lines[i] always.      #
############################################################################
def preProcess():
#	PRINT=OUTPUT
	global lines, srcFileDetails, currentMacroNames, macroDefinitions, PRINT_DEBUG_MSG, runtimeStatementLocationsInGlobalScope, runtimeStatementLineNumbers
	
#	PRINT_DEBUG_MSG = True
	
	if not lines:
		PRINT ("ERROR in preProcess - the code lines cannot be empty - exiting" )
		return False
		sys.exit()
	else:
	
#	InputCodeFile = r"InputStructure.txt"
#	with open(InputCodeFile, 'r') as f:
#		lines = f.readlines()
		PRINT (lines )
		PRINT ("len(lines) = ", len(lines) )
		
				
		PRINT ("======================\nGoing to handle preprocessor directives\n======================" )
		PRINT ("lines =",lines)
		
		macroDefinitions = []
		currentMacroNames = []		# A cache of just the macro names
		runtimeStatementLocationsInGlobalScope = []
		runtimeStatementLineNumbers = []
		srcFileDetails = []
		
		srcFileDetails.append([["#ORIGINAL#","#ORIGINAL#"],[0, len(lines)-1]])		# The string "#ORIGINAL#" indicates the code that is pasted in the code window originally

		# Process all the builtin macro definitions
		if EMULATE_GCC_COMPILATION_ENVIRONMENT:
			for line in builtinMacroDefinitions:
				defineMacroOnLineStatus = defineMacroOnLine(line)
				if defineMacroOnLineStatus != True:
					errorMessage = "ERROR in preProcess(), after calling defineMacroOnLine() for current line = " + line
					errorRoutine(errorMessage)
					return False

		# The line pointer
		i=0
		# Every time the line pointer i advances, we need to specifically reset it to True.
		processCurrentLineAgain = True
		
		# !!!!! DO NOT REMOVE THIS COMMENTED OUT LINE BELOW. IT SHOWS A HARD-TO-CATCH BUG !!!!!
		
		#while i < len(lines):	#Left for showing bug. since the lines will potentially expand after processing <include "filename"> statement, len(lines) is not constant
		while True:
			
			# This line index i will be advanced only when we are 100% sure there is no preprocessing to be done to that line any more.
			#
			# Cases where the pointer will be advanced:
			#  1. #define statements
			#  2. #undef statements
			#  3. #if or #ifdef etc. statements
			#
			# Cases where the pointer will NOT be advanced:
			#  1. Macro invocations
			#  2. #include statements
			
			if i >= len(lines):
				break
		
		
			##########################################################
			##														##
			##				REMOVE COMMENTS							##
			##														##
			##		CONVERT MULTILINE MACROS INTO SINGLE-LINE		##
			##														##
			##########################################################
			
			# Remove Multi-line comments. We really should not have to do this again and again since the macros are not supposed to create new comments.
			# Still, suppose one included file contained the beginning of a comment like /* ....., and another included file contained the end of comment like ..... */
			removeComments()
			
			# Condense each Multi-line Macro into a single-line macro 
			status = condenseMultilineMacroIntoOneLine()
			if status == False:
				errorMessage = "ERROR in preProcess() after calling condenseMultilineMacroIntoOneLine()"
				errorRoutine(errorMessage)
				return False

			# First keep a handy list of the currently existing macronames. We do this so that we can simply compare it with every token in this line.
			currentMacroNames = []	# This list will change every line since macros get defined, re-defined and un-defined every line. It is not a static list
			for macroIndex in range(len(macroDefinitions)):
				if not isinstance(macroDefinitions[macroIndex],list):
					errorMessage = "ERROR in preprocess() - macroDefinitions[macroIndex=%d] = <%s> is not a list -- exiting!"%(macroIndex,STR(macroDefinitions[macroIndex]))
					errorRoutine(errorMessage)
					return False
				else:
					currentMacroNames.append(macroDefinitions[macroIndex][0])
			PRINT("\nBefore processing line #",i," = <",lines[i],">, currentMacroNames =", STR(currentMacroNames))
			
			# Deal with blank lines right away
			if lines[i].strip() == "":
				i += 1
				continue
				
				
			##########################################################
			##														##
			##			M A C R O    I N V O C A T I O N			##
			##														##
			##########################################################
			
			invokeMacrosOnLineStatus = invokeMacrosOnLine(i)
			if invokeMacrosOnLineStatus != True:
				errorMessage = "ERROR in preProcess(), after all macro invocations and #include statement processing has been done, right after calling tokenizeLines(currLine) for currLine = " + lines[i]
				errorRoutine(errorMessage)
				return False

			# Again, deal with blank lines right away
			if lines[i].strip() == "":
				i += 1
				continue

				
			##########################################################
			##														##
			##			M A C R O    D E F I N I T I O N			##
			##														##
			##########################################################

			# Now that all possible modification has been done to the current line, let's re-tokenize
			macroTokenListResult = tokenizeLines(lines[i])
			if macroTokenListResult == False:
				errorMessage = "ERROR in preProcess(), after all macro invocations and #include statement processing has been done, right after calling tokenizeLines(currLine) for currLine = " + lines[i]
				errorRoutine(errorMessage)
				return False
			else:
				macroTokenList = macroTokenListResult[0]
			
			if macroTokenList and macroTokenList[0] == preProcessorSymbol and len(macroTokenList)>=2 and macroTokenList[1] == "define":
				defineMacroOnLineStatus = defineMacroOnLine(lines[i])
				if defineMacroOnLineStatus != True:
					findLineInOriginalSourceResult = findLineInOriginalSource(i)
					if findLineInOriginalSourceResult != False:
						errorMessage = "ERROR in preProcess(), after calling defineMacroOnLine(lines["+STR(i)+"]) for current line = " + lines[i]
						errorRoutine(errorMessage)
						return False
				
				# Finally, remove the #define statement from lines. Once added to the macro database, its job is done.
				# Preprocessing is not part of actual C anyway.
				lines[i] = ""
			
			##########################################################
			##														##
			##					# U N D E F							##
			##														##
			##########################################################

			elif macroTokenList and macroTokenList[0] == preProcessorSymbol and len(macroTokenList)>=2 and macroTokenList[1] == "undef":	# Not a #define statement
				if len(macroTokenList)<3:
					errorMessage = "ERROR in preProcess() - "+preProcessorSymbol+"undef must have some valid macroname"
					errorRoutine(errorMessage)
					return False
				elif macroTokenList[2] not in currentMacroNames:
					if PRINT_UNDEF_WARNING:
						warningMessage = "ERROR in preProcess() - "+preProcessorSymbol+"undef must have some valid macroname to undefine it - (<"+macroTokenList[2]+"> has not been defined yet)"
						warningRoutine(warningMessage)
				else:
					macroName = macroTokenList[2]
					macroIndex = currentMacroNames.index(macroName)
					# Sanity check once again
					if len(currentMacroNames) != len(macroDefinitions) or not isinstance(macroDefinitions[macroIndex],list) or macroDefinitions[macroIndex][0] != currentMacroNames[macroIndex]:
						OUTPUT("Coding error - currentMacroNames and macroDefinitions out of sync - exiting")
						OUTPUT("\ncurrentMacroNames =",STR(currentMacroNames),"\n", "macroDefinitions =",STR(macroDefinitions))
						sys.exit()
					PRINT("Removing definition of existing macro", macroName, "at macroIndex =",macroIndex,", of currentMacroNames. Exiting entry =",macroDefinitions[macroIndex])
					del currentMacroNames[macroIndex]
					del macroDefinitions[macroIndex]
					
					if len(currentMacroNames) != len(macroDefinitions) or macroTokenList[2] in currentMacroNames:
						errorMessage = "ERROR in preProcess() - "+preProcessorSymbol+"undef "+ macroTokenList[2] + " did not work"
						errorRoutine(errorMessage)
						return False
						
				# Finally, remove the #undef statement from lines. Once removed the macro database, its job is done.
				# Preprocessing is not part of actual C anyway.
				lines[i] = ""
						
			elif macroTokenList and macroTokenList[0] == preProcessorSymbol and len(macroTokenList)>=2 and macroTokenList[1] == 'error':
				if PRINT_UNDEF_WARNING:	# Currently, we are using this global variable for ALL these kind of warnings
					warningMessage = "This tool currently ignores all "+preProcessorSymbol+"error statements: <"+lines[i]+">"
					warningRoutine(warningMessage)
			elif macroTokenList and macroTokenList[0] == preProcessorSymbol and len(macroTokenList)>=2 and macroTokenList[1] == 'line':
				warningMessage = "This tool currently ignores all "+preProcessorSymbol+"line statements: <"+lines[i]+">"
				warningRoutine(warningMessage)

			##################################################################
			##																##
			##		PRECESSOR  #IF - #IFDEF - #IFNDEF - #ELIF				##
			##																##
			##################################################################
			
			elif macroTokenList and macroTokenList[0] == preProcessorSymbol and len(macroTokenList)>=2 and macroTokenList[1] in ('elif','else','endif') and i in runtimeStatementLineNumbers:
				PRINT("These are #elif/#else/#endif statements that are part of a valid #if/#elif/#else/#endif construct - no need to invoke checkPreprocessingDirectivesInterleaving()")

#			runtimeDirectives = ('if','elif','else','endif','loop','endloop')

#			elif macroTokenList[0] == preProcessorSymbol and len(macroTokenList)>=2 and macroTokenList[1] in ('if','ifdef','ifndef','elif'):
#			elif macroTokenList[0] == preProcessorSymbol and len(macroTokenList)>=2 and macroTokenList[1] in runtimeDirectives:					# <=== BUG		# MANNA_MANNA
			elif macroTokenList and macroTokenList[0] == preProcessorSymbol and len(macroTokenList)>=2 and macroTokenList[1] in ('if','ifdef','ifndef','elif','elif','else','loop','endloop'):

				# First figure out the which all source code statements are impacted by this if statement.
				# There might be multiple code blocks between the if-elif-elif-else-endif statements, but only one of them would succeed.
				PRINT("From preProcess(), calling checkPreprocessingDirectivesInterleaving() from line #"+STR(i)+"("+list2plaintext(lines[i])+")")
				checkPreprocessingDirectivesInterleavingResult = checkPreprocessingDirectivesInterleaving(lines[i:], True)
				if checkPreprocessingDirectivesInterleavingResult == False:
					errorMessage = "ERROR in preProcess() after calling checkPreprocessingDirectivesInterleaving() from line #"+STR(i)+"("+list2plaintext(lines[i])+")"
					errorRoutine(errorMessage)
					return False
				else:
					scope = checkPreprocessingDirectivesInterleavingResult

				PRINT("For line #",i," the scope for the if-elif-else-endif is",scope)

				# Recall that the the line numbers returned from checkPreprocessingDirectivesInterleaving() are relative, i.e. they start from 0.
				# So, you need to add the current line number to get any absolute line number
				k = 0

				# Out of the many if-elif-elif-else-endif code blocks, only one will succeed. And once that succeeds, the rest must be deleted irrespecive of
				# whether corresponding #elif condition evaluates to True or not
				ifConditionTruthValueAlreadyFound = False
				runtimeStatement = False
				ordinaryPreprocessingOrRuntimeStatementLineNumbers = []

				while k<len(scope):
					targetLineNumber = scope[k][0]+i
					ordinaryPreprocessingOrRuntimeStatementLineNumbers.append(targetLineNumber)
					
					invokeMacrosOnLineStatus = invokeMacrosOnLine(targetLineNumber)	# We are invoking macro ONLY on this line, nothing else.
					if invokeMacrosOnLineStatus != True:
						errorMessage = "ERROR in preProcess(), during processing preprocessing statements for targetLineNumber = " + lines[targetLineNumber]
						errorRoutine(errorMessage)
						return False
					
					PRINT("Tokenizing line #",targetLineNumber)

					deleteCodeBlock = False
					
					# If we already had one of the if-elif-elif-else-endif condition
					if ifConditionTruthValueAlreadyFound and not runtimeStatement:
						deleteCodeBlock = True
					else:
						PRINT("Going to tokenizeLines(\"",lines[targetLineNumber],"\")")
						tokenizeLinesResult = tokenizeLines(lines[targetLineNumber])
						if tokenizeLinesResult == False:
							errorMessage = "ERROR in preProcess() after calling tokenizeLines() for line # %d = <%s>" %(targetLineNumber,lines[targetLineNumber] )
							errorRoutine(errorMessage)
							return False
						else:
							PRINT("tokenizeLinesResult =",tokenizeLinesResult)
							targetLineTokenList = tokenizeLinesResult[0]
				
						if targetLineTokenList[0] == preProcessorSymbol and len(targetLineTokenList)>=2 and targetLineTokenList[1] in ('if','ifdef','ifndef', 'elif') and len(targetLineTokenList)<3:
							errorMessage = "ERROR in line #"+targetLineNumber+": an "+ STR(targetLineTokenList[0:2]) +" statement must not be empty"
							errorRoutine(errorMessage)
							return False
						elif targetLineTokenList[0] == preProcessorSymbol and len(targetLineTokenList)>=2 and targetLineTokenList[1] in ('ifdef','ifndef') and len(targetLineTokenList)!=3:
							errorMessage = "ERROR in line #"+targetLineNumber+": an "+ STR(targetLineTokenList[0:2]) +" statement must not supply more than one argument"
							errorRoutine(errorMessage)
							return False
						elif targetLineTokenList[0] == preProcessorSymbol and len(targetLineTokenList)>=2 and targetLineTokenList[1] in ('else','endif') and len(targetLineTokenList)>2:
							errorMessage = "ERROR in line #"+targetLineNumber+": an "+ STR(targetLineTokenList[0:2]) +" statement must not supply more than one argument"
							errorRoutine(errorMessage)
							return False
						
						# Calculate the if condition result (True or False). By here we know that all ifdef etc. things have proper arguments
						ifConditionEvaluationResult = False	# The default value
						
						PRINT("Now going to evaluate the condition", targetLineTokenList)
						if targetLineTokenList[0] == preProcessorSymbol and len(targetLineTokenList)>=2 and targetLineTokenList[1] == 'else': 	# If you are falling on an #else, it is by defintion true
							ifConditionEvaluationResult = True
							PRINT("The '"+preProcessorSymbol+"else' succeeded")
						elif targetLineTokenList[0] == preProcessorSymbol and len(targetLineTokenList)>=2 and targetLineTokenList[1] == 'ifdef':
							if len(targetLineTokenList)<3: 
								errorMessage = "ERROR in line #"+targetLineNumber+": an "+ STR(targetLineTokenList[0:2]) +": "+preProcessorSymbol+"ifdef must supply at least one argument"
								errorRoutine(errorMessage)
								return False
							elif targetLineTokenList[2] in currentMacroNames:
								ifConditionEvaluationResult = True
								PRINT("The '",STR(targetLineTokenList[0:3]),"' succeeded")
							else:
								PRINT("The '",STR(targetLineTokenList[0:3]),"' failed")
						elif targetLineTokenList[0] == preProcessorSymbol and len(targetLineTokenList)>=2 and targetLineTokenList[1] == 'ifndef': 
							if targetLineTokenList[2] not in currentMacroNames:
								ifConditionEvaluationResult = True
								PRINT("The '",STR(targetLineTokenList[0:3]),"' succeeded")
							else:
								PRINT("The '",STR(targetLineTokenList[0:3]),"' failed")
						elif targetLineTokenList[0] == preProcessorSymbol and len(targetLineTokenList)>=2 and targetLineTokenList[1] in ('if','elif'):
						
							PRINT("Found an if/elif condition - ",targetLineTokenList)
							# Handle one special case - before calling parseArithmeticExpression(), we must resolve the case of defined().
							# This is because parseArithmeticExpression() is agnostic of exactly where in the source file the code is,
							# but the result of a defined(symbol) depends precisely on that. So parseArithmeticExpression() cannot
							# figure that out. So, we handle it locally first. We relace the defined(symbol) with 1 or 0.
							
							if 'defined' in targetLineTokenList:
								PRINT("Before handling checking for defined, targetLineTokenList =",targetLineTokenList)
								currLineTokenListTransformed = targetLineTokenList
								while True:
									if 'defined' in currLineTokenListTransformed:
										definedIndex = currLineTokenListTransformed.index('defined')
										# The symbol we are checking may or may not be parenthesized, and one may use multiple parenthizations instead of just one
#										if definedIndex +3 < len(currLineTokenListTransformed) and currLineTokenListTransformed[definedIndex+1] == '(' and currLineTokenListTransformed[definedIndex+3] == ')':
										if definedIndex +3 < len(currLineTokenListTransformed) and currLineTokenListTransformed[definedIndex+1] == '(' and ')' in currLineTokenListTransformed[definedIndex+2:]:
											numberOfOpeningBraces = 1
											while True:
												if currLineTokenListTransformed[definedIndex+1+numberOfOpeningBraces] == '(':
													numberOfOpeningBraces += 1
												else:
													break
											PRINT("We seem to be have numberOfOpeningBraces =",numberOfOpeningBraces)
											
											symbolToCheckIfDefined = currLineTokenListTransformed[definedIndex+numberOfOpeningBraces+1]

											numberOfClosingBraces = 0
											while True:
												if definedIndex+numberOfOpeningBraces+2+numberOfClosingBraces < len(currLineTokenListTransformed) and currLineTokenListTransformed[definedIndex+numberOfOpeningBraces+2+numberOfClosingBraces] == ')':
													numberOfClosingBraces += 1
												else:
													break
											PRINT("We seem to be have numberOfClosingBraces =",numberOfClosingBraces)
											# It is OK to have more numberOfClosingBraces, because there might be other nested conditions
											if numberOfOpeningBraces > numberOfClosingBraces:
												errorMessage = "ERROR in preProcess(): mismatching number of braces around "+currLineTokenListTransformed[definedIndex+numberOfOpeningBraces+1]+" in line "+list2plaintext(currLineTokenListTransformed)
												errorRoutine(errorMessage)
												return False
											
											#replace the 'defined' token with 1 or 0, and delete the three subsequent tokens signifying (symbol)
											PRINT("Looking for Symbol", symbolToCheckIfDefined,"in currentMacroNames =",STR(symbolToCheckIfDefined))
											if symbolToCheckIfDefined in currentMacroNames:
												currLineTokenListTransformed[definedIndex] = '1'
												PRINT("Found it - replacing defined(",symbolToCheckIfDefined,") with 1")
											else:
												currLineTokenListTransformed[definedIndex] = '0'
												PRINT("Did not find it - replacing defined(",symbolToCheckIfDefined,") with 0")
											#del currLineTokenListTransformed[definedIndex+1:definedIndex+4]
											# Observe that we are not using numberOfClosingBraces in the following statement, that is deliberate
											currLineTokenListTransformed = currLineTokenListTransformed[:definedIndex+1]+currLineTokenListTransformed[definedIndex + numberOfOpeningBraces + 1 + numberOfOpeningBraces + 1:]
										else:	# No parenthesization
											symbolToCheckIfDefined = currLineTokenListTransformed[definedIndex+1]
											#replace the 'defined' token with 1 or 0, and delete the three subsequent tokens signifying (symbol)
											PRINT("Looking for Symbol", symbolToCheckIfDefined,"in currentMacroNames =",STR(symbolToCheckIfDefined))
											if symbolToCheckIfDefined in currentMacroNames:
												currLineTokenListTransformed[definedIndex] = '1'
												PRINT("Found it - replacing defined(",symbolToCheckIfDefined,") with 1")
											else:
												currLineTokenListTransformed[definedIndex] = '0'
												PRINT("Did not find it - replacing defined(",symbolToCheckIfDefined,") with 0")
											#del currLineTokenListTransformed[definedIndex+1:definedIndex+1]
											currLineTokenListTransformed = currLineTokenListTransformed[:definedIndex+1]+currLineTokenListTransformed[definedIndex+2:]
										
									else:	# No more #defined, all have been resolved
										break
								targetLineTokenList = currLineTokenListTransformed
								PRINT("After handling checking for defined, targetLineTokenList =",targetLineTokenList)
								
						
							parseArithmeticExpressionResult = parseArithmeticExpression(targetLineTokenList[2:])
							if parseArithmeticExpressionResult == False:
								OUTPUT("Encountered error while evaluating parseArithmeticExpression(targetLineTokenList[2:]), where targetLineTokenList[2:] =", list2plaintext(targetLineTokenList[2:]))
								errorMessage = "ERROR in preProcess() parsing <%s>"%tokenizeLinesResult
								errorRoutine(errorMessage)
								return False
								
							evaluateArithmeticExpressionResult = evaluateArithmeticExpression(parseArithmeticExpressionResult)
							PRINT("evaluateArithmeticExpression(",STR(parseArithmeticExpressionResult),") evaluates to", evaluateArithmeticExpressionResult)
							if evaluateArithmeticExpressionResult[0] == False:
								errorMessage = "ERROR in preProcess() evaluating <%s>"%evaluateArithmeticExpressionResult
								errorRoutine(errorMessage)
								return False
							elif evaluateArithmeticExpressionResult[1] == 1:	# Truth value in C is 1, not True of Python
								ifConditionEvaluationResult = True
							elif evaluateArithmeticExpressionResult[1] == 0:	# False value in C is 0, not False of Python
								ifConditionEvaluationResult = False
							elif evaluateArithmeticExpressionResult[1] == LOGICAL_TEST_RESULT_INDETERMINATE:	# Cannot determine at this time
								ifConditionEvaluationResult = LOGICAL_TEST_RESULT_INDETERMINATE
								if runtimeStatement == False:
									runtimeStatement = True
									if targetLineTokenList[1]=='elif':
										PRINT("Going to convert the #elif statement on line #",targetLineNumber,"to an #if statement")
										lines[targetLineNumber] = lines[targetLineNumber].replace('elif','if',1)
										PRINT("lines[",targetLineNumber,"] =",lines[targetLineNumber])
								PRINT("The current #if-elif-else is #RUNTIME statement")
							else:
								errorMessage = "ERROR in preProcess() evaluating <%s> - it is not 1 or 0"%evaluateArithmeticExpressionResult
								errorRoutine(errorMessage)
								return False
								
							if ifConditionEvaluationResult == True:
								PRINT("The if condition in line#",targetLineNumber," = <",lines[targetLineNumber],"> succeeded")
							elif ifConditionEvaluationResult == False:
								PRINT("The if condition in line#",targetLineNumber," = <",lines[targetLineNumber],"> failed")
							elif ifConditionEvaluationResult == LOGICAL_TEST_RESULT_INDETERMINATE:
								PRINT("The if condition in line#",targetLineNumber," = <",lines[targetLineNumber],"> can only be determined at runtime")

						PRINT("Condition evaluated. ifConditionEvaluationResult =",ifConditionEvaluationResult,", ifConditionTruthValueAlreadyFound =",ifConditionTruthValueAlreadyFound)
						if ifConditionEvaluationResult == True:
							ifConditionTruthValueAlreadyFound = True
							PRINT("The overall if condition in line#",targetLineNumber," = <",lines[targetLineNumber],"> succeeded")
						elif ifConditionEvaluationResult == False:
							PRINT("The overall if condition in line#",targetLineNumber," = <",lines[targetLineNumber],"> failed")
							deleteCodeBlock = True
						'''
						elif ifConditionEvaluationResult == LOGICAL_TEST_RESULT_INDETERMINATE:
							# If the current statement is an #elif, convert that to an #if statement
							if targetLineTokenList[1]=='elif' and not ifConditionTruthValueAlreadyFound and not firstElifAlreadyConverted:
								PRINT("Going to convert the #elif statement on line #",targetLineNumber,"to an #if statement")
								lines[targetLineNumber] = lines[targetLineNumber].replace('elif','if',1)
								PRINT("lines[",targetLineNumber,"] =",lines[targetLineNumber])
						'''
						
						
					# Now that we have calculated the if condition result (True or False), delete the if statements and corresponding non-executing code blocks
					if runtimeStatement:
						numLinesToDelete = 0
					elif not deleteCodeBlock or k == len(scope)-1:
						numLinesToDelete = 1
					else:
						numLinesToDelete = scope[k+1][0] - scope[k][0]
						
					PRINT ("Going to delete line",scope[k][0]+i,"through line",scope[k][0]+i+numLinesToDelete-1," - a total of",numLinesToDelete,"lines" )
					d = 0
					while d < numLinesToDelete:
						lines[scope[k][0]+i+d] = ""
						d += 1
					k += 1
				PRINT("\n\nAfter handling",macroTokenList[0:2],", lines =\n",lines)
					
				# There is a problem with runtime statements. Unlike preprocessing statements, they do not go away from the code after preprocessing.
				# Look at the contrasting examples of "before preprocessing" and "after preprocessing" for ordinary preprocessing statements vs. runtime statements:
				#
				#	  Preprocessing statements										Runtime statements
				# ==========================================				==========================================
				#
				#     Before					After				     		Before					After
				#
				#    #define x  2											int x;
				#    #if x==2												#if x==2					#if x==2
				#       int a;					int a;							int a;						int a;
				#    #else													#else						#else
				#       float f;												float f;				   float f;
				#    #endif													#endif						#endif
				#
				# Why is this a problem? Well, we preprocess line by line. So, in case of the ordinary preprocessing statements, after the proprocessor evaluates
				# the statement #if x==2, it will go to the next line and repeat. It will never encounter the #else and #endif.
				# On the other hand, for runtime statements, the preprocessor will now go to the next statement (int a;), but after that it will find the #else
				# statement. It has no idea if this #else is a standalone renegade #else (which is illegal), or a valid continuation of previous #if-#elif-#else-#endif.
				# So, we keep a global list of which all linenumbers contain a runtime statement.
				
				if runtimeStatement:
					for targetLineNumber in ordinaryPreprocessingOrRuntimeStatementLineNumbers:
						if targetLineNumber in runtimeStatementLineNumbers:
							OUTPUT("lines[targetLineNumber=",targetLineNumber,"] =",lines[targetLineNumber])
							OUTPUT("Bad coding in preProcess(): line #"+STR(targetLineNumber)+" already exists in runtimeStatementLineNumbers = "+STR(runtimeStatementLineNumbers))
							OUTPUT("srcFileDetails =\n")
							for row in srcFileDetails:
								OUTPUT(row)
							findLineInOriginalSource(targetLineNumber)
							sys.exit()
						else:
							runtimeStatementLineNumbers.append(targetLineNumber)
				runtimeStatementLineNumbers.sort()
				
					
			i = i+1
				
		# After all the lines have been processed, we need to run the comment and macro processing again just in case there are such statements inside the included file
		
		# Remove Multi-line comments
		removeComments()
		
		# Condense each Multi-line Macro into a single-line macro 
		status = condenseMultilineMacroIntoOneLine()
		if status == False:
			errorMessage = "ERROR in preProcess() after calling condenseMultilineMacroIntoOneLine()"
			errorRoutine(errorMessage)
			return False
			

		# At this point, all the #if-#elif-#else-#endif statements in ordinary preprocessing statements have vanished, but runtime statements remain.
		PRINT("These are the valid #runtime statements")
		for lineNum in runtimeStatementLineNumbers:
			PRINT("Line #",lineNum,"= ",lines[lineNum])
			
		PRINT("\nIn preProcess(), after all macros have been done, check if the runtime statement interleavings are legal or not. len(lines) =",len(lines),"\n")
		i=0
		while i<len(lines):
			# We have a corner-case bug where the lines[i:] start with a blank line. This will cause checkPreprocessingDirectivesInterleaving() to return a blank scope,
			# because it expects the very first line supplied to it to be a #RUNTIME statement. 
			if lines[i].strip() == "":
				i = i+1
				continue
			PRINT("We are going to tokenize all the lines starting from line#",i, ", where lines[",i,"] =<"+lines[i]+">")
			runtimeTokenListResult = tokenizeLines(lines[i:])
			if runtimeTokenListResult == False:
				errorMessage = "ERROR in preProcess() after calling tokenizeLines(currLine) for checking the runtime directive"
				errorRoutine(errorMessage)
				return False
			else:
				runtimeTokenList = runtimeTokenListResult[0]
				PRINT("After tokenizing from line#",i,", runtimeTokenList =",runtimeTokenList)
				if runtimeTokenList and runtimeTokenList[0] == preProcessorSymbol and len(runtimeTokenList)>=2 and runtimeTokenList[1] in runtimeDirectives:
					if runtimeTokenList[1] in ("elif","else","endif") and i in runtimeStatementLineNumbers:
						PRINT("NOT invoking checkPreprocessingDirectivesInterleaving() from line #",i,"since line #",i," = <",lines[i],"> is already known to be a #runtime statement")
					else:
						PRINT("\n\nFrom preProcess() calling checkPreprocessingDirectivesInterleaving(lines[i:], True) where i=",i,"and lines[i:] =",lines[i:])
						checkPreprocessingDirectivesInterleavingResult = checkPreprocessingDirectivesInterleaving(lines[i:], True)
						if checkPreprocessingDirectivesInterleavingResult == False:
							errorMessage = "ERROR in preProcess() after calling checkPreprocessingDirectivesInterleaving() from line# %d"%i
							errorRoutine(errorMessage)
							return False
						else:
							scope = checkPreprocessingDirectivesInterleavingResult
							PRINT("scope, which is result of calling checkPreprocessingDirectivesInterleaving(lines[",i,":], True), is",scope)
							lastLineNumberWithRuntimeDirective = i + scope[-1][0]	# Recall that the line numbers in scope are relative to 0, so we need to add i to it
							PRINT("lastLineNumberWithRuntimeDirective =",lastLineNumberWithRuntimeDirective)
							i = lastLineNumberWithRuntimeDirective
			i += 1
		
#		PRINT ("======================\nAFTER handling multi-line macros\n======================" )
#		PRINT ("len(lines) = ", len(lines) )
		i=0
		while i < len(lines):
			PRINT ((" line # %d = <%s>" % (i,lines[i])) )
			i = i+1


	return True


######################################################################################################################
# This function is supplied with a list of tokens and a list of lines, supposedly matching the tokenlist.
# The coutput is for each token in tokenList, the [<startLineNum,startCharNum>,<endLineNum,endCharNum>]
# TO-DO: What if the same tokenList exists multiple times? It is entirely possible that two macros share some code.
######################################################################################################################
def tokenLocations(lines, tokenList):
	PRINT ("Inside tokenLocations, tokenList =",tokenList )
	tokenizeLinesOutputResult = tokenizeLines(lines)
	if tokenizeLinesOutputResult == False:
		OUTPUT ("Error inside tokenLocations after calling tokenizeLines(lines) for lines =", lines )
		return False
	else:
		tokenizeLinesOutput = tokenizeLinesOutputResult[0]
		
	if tokenList != tokenizeLinesOutput:
		OUTPUT ("ERROR - inside function tokenLocations(), the input tokenList does not correspond to the supplied lines - exiting" )
		OUTPUT ("tokenList = ",tokenList, "lines =", lines )
		return False
		sys.exit()
	else:
		tokenLocationLinesChars = []
		
	
		i = 0
		linePointer = 0
		charPointer = 0
		#TO-DO: Tokens that spread over multiple lines (most likely a quoted literal)
		while i < len(tokenList):
			currentToken = tokenList[i]
			if currentToken != currentToken.strip():
				OUTPUT ("ERROR in tokenLocations() - Illegal currentToken = tokenList[",i,"] =", tokenList[i],"has whitespace at begining or end - exiting" )
				return False
				sys.exit()
			while True:
				if lines[linePointer][charPointer] == currentToken[0]:
					# Check that the string is indeed the token
					if (len(currentToken) <= len(lines[linePointer][charPointer:])) and (currentToken == lines[linePointer][charPointer:charPointer+len(currentToken)]):
						startLineChar = [linePointer,charPointer]
						endLineChar = [linePointer,charPointer+len(currentToken)-1]
						PRINT ("currentToken = tokenList[",i,"] =", tokenList[i],"has location",startLineChar,endLineChar )
						tokenLocationLinesChars.append([startLineChar,endLineChar])
						charPointer = charPointer+len(currentToken)
						if charPointer >= len(lines[linePointer]):
							charPointer = 0
							linePointer = linePointer + 1
						i = i + 1
						break
					else:
						OUTPUT ("ERROR in tokenLocations() - somehow the tokenstream does not correspond to the lines - exiting" )
						OUTPUT ("currentToken = tokenList[",i,"] =", tokenList[i]," linePointer =", linePointer, "charPointer =",charPointer, "lines[linePointer][charPointer]=",lines[linePointer][charPointer] )
						return False
						
				elif lines[linePointer][charPointer].isspace():	# TO-DO: what if this catches the newline
					charPointer = charPointer + 1
					if charPointer >= len(lines[linePointer]):
						charPointer = 0
						linePointer = linePointer + 1
				elif lines[linePointer][charPointer]=='\n':	# TO-DO: what if this catches the newline
					PRINT ("ALERT: Newline" )
					charPointer = charPointer + 1
					if charPointer >= len(lines[linePointer]):
						charPointer = 0
						linePointer = linePointer + 1
					else:
						OUTPUT ("ERROR in tokenLocations() - should never come here - exiting!" )
						return False

				else:
					OUTPUT ("ERROR in tokenLocations() - Illegal character - exiting" )
					OUTPUT ("currentToken = tokenList[",i,"] =", tokenList[i]," linePointer =", linePointer, "charPointer =",charPointer, "lines[linePointer][charPointer]=",lines[linePointer][charPointer] )
					return False
					
		return tokenLocationLinesChars


################################################################################################################################
# This function takes in a tokenList where a enum definition or declaration is happening from token # i 
################################################################################################################################
def parseEnum(tokenList, i):
#	PRINT=OUTPUT
	global typedefs, enums, lines, structuresAndUnions, suDict, primitiveDatatypeLength, variableDeclarations, totalVariableCount, variableIdsInGlobalScope
	
	if not isinstance(tokenList,list):
		errorMessage = "ERROR in parseEnum(): tokenList <"+STR(tokenList)+"> is not a list"
		errorRoutine(errorMessage)
		return False
	elif not tokenList:
		errorMessage = "ERROR in parseEnum(): Empty passed tokenList"
		errorRoutine(errorMessage)
		return False
	elif (not checkIfIntegral(i)) or i <0 or i>=len(tokenList):
		errorMessage = "ERROR in parseEnum(): Illegal value of i ="+STR(i)
		errorRoutine(errorMessage)
		return False
	else:
		
		# Sanity check: Ensure that enums and enumFieldValues are in sync
		if (not enums) and (not enumFieldValues):
			PRINT ("enums and enumFieldValues are both empty, hence in sync" )
		elif (enums and not enumFieldValues) or (not enums and enumFieldValues):
			PRINT ("ERROR in parseEnum(): enums and enumFieldValues are out of sync - one of them is empty while the other is not" )
			PRINT ("enums =", enums )
			PRINT ("enumFieldValues =",enumFieldValues )
			return False
		elif enums and enumFieldValues:
			tempEnumFieldValues = {}
			for key in enums.keys():
				for field in enums[key]:
					if field in getDictKeyList(tempEnumFieldValues):
						PRINT ("ERROR: Duplicate enum field", field )
						return False
					elif field not in getDictKeyList(enumFieldValues):
						PRINT ("ERROR: enum field", field, "NOT found in enumFieldValues" )
						return False
					else:
						tempEnumFieldValues[field]=enums[key][field]
			if len(tempEnumFieldValues) != len(enumFieldValues):
				PRINT ("len(tempEnumFieldValues) = ",len(tempEnumFieldValues), "!=", "len(enumFieldValues) =", len(enumFieldValues) )
				PRINT ("Which possibly means that enumFieldValues has more entries" )
				PRINT ("enums =",enums, "tempEnumFieldValues = ",tempEnumFieldValues, "enumFieldValues =", enumFieldValues )
				
		else:
			PRINT ("ERROR: The control should have never come here (ensuring that enums and enumFieldValues are in sync)" )
			sys.exit()
			return False
	
		nextSemicolonIndex = i+1 + tokenList[i+1:].index(";")
		enumStatementStartIndex = i
		if nextSemicolonIndex <= i + 2:
			errorMessage = "ERROR in parseEnum() - Illegal statement formation (semicolon without adequate enum variable type and name) - exiting"
			errorRoutine(errorMessage)
			PRINT ("ERROR in parseEnum() processing ENUM - nextSemicolonIndex =",nextSemicolonIndex,"tokenList[i:] = tokenList[",i,":]=",tokenList[i:] )
			return False
		else:
		
			# There are four cases possible.
			
			# 1. enum Declaration YES, Definition NO	- enum WEEKDAY day1,day2;
			# 2. enum Declaration NO , (named) Definition NO   - enum {Mon, Tue};			- Anonymous
			# 3. enum Declaration YES, Definition YES   - enum WEEKDAY {Mon, Tue} day1,day2;
			# 4. enum Declaration NO , Definition YES	- enum {Mon, Tue} day1, day2;		- Anonymous
		
		
			# Step 1. we handle the enumDataType. There are three cases possible: 1) Previously-defined, 2) Anonymous, and 3) Now-defined
		
		
			# 1. Declaration of previously-defined enums, NO defintion. So, need to check if the enum really exists or not.
			if tokenList[i+1] != "{" and tokenList[i+2] != "{" :
				enumDataType = tokenList[i+1]
				if enumDataType not in getDictKeyList(enums):
					errorMessage = "ERROR - enum name <%s> does NOT exist - exiting"%enumDataType
					errorRoutine(errorMessage)
					PRINT ("ERROR in parseEnum() processing ENUM declaration - nextSemicolonIndex =",nextSemicolonIndex,"tokenList[i:nextSemicolonIndex] = tokenList[",i,":",nextSemicolonIndex,"]=",tokenList[i:nextSemicolonIndex] )
					return False
			
			# 2. Anonymous enum datatype definition
			elif tokenList[i+1] == "{":
				PRINT ("WARNING: Anonymous enum declaration!!" )
				curlyBraceStartIndex = i + 1
				totalNumberOfAnonymousEnumsTillNow = 0
				anonymousEnumPrefix = "AnonymousEnum+"		# We cannot have the plus sign as part of any enum datatype  name
				if enums:
					for key in enums.keys():
						if key.startswith(anonymousEnumPrefix):
							num = int(key[len(anonymousEnumPrefix):])
							if num > totalNumberOfAnonymousEnumsTillNow:
								totalNumberOfAnonymousEnumsTillNow = num
				enumDataType = anonymousEnumPrefix+str(totalNumberOfAnonymousEnumsTillNow+1)

			# 3. New enum datatype definition
			elif tokenList[i+2] == "{":
				enumDataType = tokenList[i+1]
				# Check if the enum already exists or not - do this ONLY if we are defining the enum here. 
				# Without the definition, there can be many declarations beginning with the same enum type.
				if enumDataType in getDictKeyList(enums):
					errorMessage = "ERROR - enum name <%s> already exists - exiting"%enumDataType
					errorRoutine(errorMessage)
					PRINT ("ERROR in parseEnum() processing ENUM - nextSemicolonIndex =",nextSemicolonIndex,"tokenList[i:nextSemicolonIndex] = tokenList[",i,":",nextSemicolonIndex,"]=",tokenList[i:nextSemicolonIndex] )
					return False
				else:
					PRINT ("New enum datatype",enumDataType, "will be added" )

			#########################################################################################
			# Step 2. We handle the enum definition. Basically if the { ... } exists, we deal with it.
			# Previously, we have covered the three cases where the enumDataType is 1) previously defined, 2) Anonymous, and 3) Newly defined.
			# The reason we are doing this is because we want to carve out the Enum definition part (anonymous or not) into a single block.
			
			if (tokenList[i+1]=='{' or tokenList[i+2] == '{'): # Definition, not declaration
				curlyBraceStartIndex = i+1+tokenList[i+1:nextSemicolonIndex].index('{')
				
				# The assumption here is a that there cannot be any curly braces inside the enum expression
				if '}' not in tokenList[i+2:nextSemicolonIndex]:
					errorMessage = "ERROR - in parseEnum() processing ENUM - NO cruly brace end before semicolon!"
					errorRoutine(errorMessage)
					PRINT ("ERROR in parseEnum() processing ENUM - nextSemicolonIndex =",nextSemicolonIndex,"tokenList[i:nextSemicolonIndex] = tokenList[",i,":",nextSemicolonIndex,"]=",tokenList[i:nextSemicolonIndex] )
					return False
					# Enum definition
					
				else:		
					curlyBraceEndIndex = i+1+tokenList[i+1:nextSemicolonIndex].index('}')
					PRINT ("Going to create new enum variable named",enumDataType )
					enumExpression = tokenList[curlyBraceStartIndex:curlyBraceEndIndex+1]	# Both the braces need to be included in the expression
					parseArgumentListResult = parseArgumentList(enumExpression)
					
					if parseArgumentListResult == False:
						errorMessage = "ERROR - in parseEnum() processing ENUM - the enumExpression =<%s> cannot be parsed properly"%enumExpression
						errorRoutine(errorMessage)
						PRINT ("ERROR in parseEnum() processing ENUM - nextSemicolonIndex =",nextSemicolonIndex,"tokenList[i:nextSemicolonIndex] = tokenList[",i,":",nextSemicolonIndex,"]=",tokenList[i:nextSemicolonIndex] )
						return False
					else:
						PRINT ("After parsing the enumExpression =",enumExpression,"parseArgumentListResult =",parseArgumentListResult )
						# This variable indicates the last ENUM-ed value. We put it deliberately at -1 so that we do not need to have some special logic for the first element.
						lastEnumValue = -1
						enumFields = {} # This is a dictionary that will hold the various ENUMed values
						for enumElement in parseArgumentListResult:
							PRINT ("\nHandling ENUM element", enumElement, "of length",len(enumElement) )
							# When there is explicit assignment to a enum element, we know for sure that the enumElement is returned as a list.
							# However, when it is just the element itself without any explicit assignment, we do not know if enumElement is a single-element list, or a string.
							# If enumElement is returned as a string, len(enumElement) will NOT show as 1, but rather the number of characters in the string (1 or more).
							# Hence, we do explicit assignment of the element name (called "item" here) and the length of the enumElement
							if checkIfString(enumElement):
								item = enumElement
								enumElementLength = 1
								PRINT("enumElement =",enumElement,"is a string, hence enumElementLength =",enumElementLength)
							elif isinstance(enumElement,list):
								# GCC allows even formations like this: enum {A, B,}. In that case, the parseArgumentListResult will return 3 elements - A, B, and a blank list
								if not enumElement:
									continue
								item = enumElement[0]
								enumElementLength = len(enumElement)
								PRINT("enumElement =",enumElement,"is a list, hence enumElementLength =",enumElementLength)
							else:
								item = enumElement
								enumElementLength = 1
								PRINT("\n\nHow did I come here?\n\n")
							PRINT("For enumElement =",enumElement,", enumElementLength =",enumElementLength,", item =", item)
							PRINT ("Going to check if the enum element",item,"already appears as some other enum constant anywhere else" )
							# This is the list of ALL possible ENUMed field names
							allEnumedValues = []
							allEnumedValuesStr = ""
							for definedEnumtype in enums.keys():
								allEnumedValuesStr += "\n<"+definedEnumtype+"> "
								for definedEnumtypeValues in enums[definedEnumtype].keys():
									allEnumedValues.append(definedEnumtypeValues)
									allEnumedValuesStr += definedEnumtypeValues + " "
							PRINT ("allEnumedValues =",allEnumedValues )
							PRINT ("The above list should be the same as the one below with the <enum type> extra" )
							PRINT (allEnumedValuesStr )
							
							if item in cDataTypes or item in cKeywords or item in getDictKeyList(typedefs) or item in getDictKeyList(suDict) or item in getDictKeyList(enums) or item in allEnumedValues:
								errorMessage = "ERROR parseEnum() processing ENUM - illegal enum element <%s>"%item
								errorRoutine(errorMessage)
								return False
							elif enumElementLength == 1:	# Be careful not to use enumElement[0], since we do not know if the enumElement is a single-element list, or a string
								enumFields[item]= lastEnumValue+1
								lastEnumValue = enumFields[item]
								PRINT ("No explicit assignment for",item )
							elif enumElement[1] != "=":
								errorMessage = "ERROR parseEnum() - illegal enum element <%s> - should have been =  .... Exiting"%enumElement[1]
								errorRoutine(errorMessage)
								return False
							elif enumElementLength == 3:
								PRINT ("Simple assignment for",enumElement," - no expression to evaluate for enum field", item )
								if checkIfIntegral(enumElement[2]):	# Will it work? "1" is not an integer, 1 is
									enumFields[enumElement[0]]= enumElement[2]
									lastEnumValue = enumElement[2]
								elif checkIfString(enumElement[2]):	# Will it work? "1" is not an integer, 1 is
									evaluateArithmeticExpressionResult = evaluateArithmeticExpression(enumElement[2])
									if evaluateArithmeticExpressionResult[0]!=True:
										errorMessage = "ERROR parseEnum() after calling parseArithmeticExpression("+STR(enumElement[2])+")"
										errorRoutine(errorMessage)
										return False
									else:
										output= evaluateArithmeticExpressionResult[1]
										if checkIfIntegral(output):
											enumFields[enumElement[0]] = output
											lastEnumValue = output
											PRINT ("output =",output,"is indeed an assignable integer." )
										else:
											errorMessage = "ERROR parseEnum() after calling evaluateArithmeticExpression() - the output ("+str(output)+") is not an integer"
											errorRoutine(errorMessage)
											return False
#										enumFields[enumElement[0]]= output
#										lastEnumValue += 1
								else:
									errorMessage = "ERROR parseEnum() - illegal enum element assignment <%s> = <%s> (not an integer) - should have been =  .... Exiting"%(enumElement[0],enumElement[2])
									errorRoutine(errorMessage)
									return False
							else:
								PRINT ("Complex assignment - need to evaluate the expression for enum field", item )
								arithmeticExpression = enumElement[2:]
								PRINT ("Going to evaluate the expression",enumElement[0],"=",arithmeticExpression )
								parseArithmeticExpressionOutput = parseArithmeticExpression(arithmeticExpression)
								if parseArithmeticExpressionOutput == False:
									errorMessage = "ERROR parseEnum() after calling parseArithmeticExpression()"
									errorRoutine(errorMessage)
									return False
								else:
									evaluateArithmeticExpressionOutput = evaluateArithmeticExpression(parseArithmeticExpressionOutput)
									if evaluateArithmeticExpressionOutput[0] != True:
										errorMessage = "ERROR parseEnum() after calling evaluateArithmeticExpression()"
										errorRoutine(errorMessage)
										return False
									else:
										output = evaluateArithmeticExpressionOutput[1]
										if checkIfIntegral(output):
											enumFields[enumElement[0]] = output
											lastEnumValue = output
											PRINT ("output =",output,"is indeed an assignable integer." )
										else:
											errorMessage = "ERROR parseEnum() after calling evaluateArithmeticExpression() - the output ("+str(output)+") is not an integer"
											errorRoutine(errorMessage)
											return False
											
						PRINT ("Current content of the enums dictionary:" )
						PRINT (enums )
						PRINT ("Current content of the ALL possible enums values:" )
						PRINT (enumFieldValues )
						PRINT ("Going to add the following dictionary for enumDataType =", enumDataType, " :" )
						PRINT (enumFields )
						
						enums[enumDataType]=enumFields
						for field in enumFields.keys():
							if field in getDictKeyList(enumFieldValues):
								errorMessage = "ERROR: enum field "+STR(field)+" already defined" 
								errorRoutine(errorMessage)
								return False
							else:
								enumFieldValues[field] = enumFields[field]
			
			###################################################################################################
			# Step 3. Now we handle the declarations
			
			if '}' in tokenList[enumStatementStartIndex:nextSemicolonIndex]: 	# The definition precedes the declarations, if any
				if curlyBraceEndIndex + 1 == nextSemicolonIndex:
					PRINT ("No enum variables to instantiate for",enumDataType, "we are done here" )
					i = nextSemicolonIndex+1
					return i
				else:
					declarationStartIndex = curlyBraceEndIndex + 1
					# When we have both enum defintion and declaration in the same statement, break it up. 
					# Create a fake entry, as if the enum definition was done first
					if enumStatementStartIndex>0 and tokenList[enumStatementStartIndex-1] == "typedef":
						memberDeclarationStatement = ["typedef","enum", enumDataType]
						numFakeEntries = 3
					else:
						memberDeclarationStatement = ["enum", enumDataType]
						numFakeEntries = 2
					memberDeclarationStatement.extend(tokenList[curlyBraceEndIndex+1:nextSemicolonIndex+1])
			else:	# No defintion, just declarations
				memberDeclarationStatement = tokenList[enumStatementStartIndex:nextSemicolonIndex+1]
				declarationStartIndex = enumStatementStartIndex + 2
				numFakeEntries = 0
				
				
			PRINT ("Going to parse memberDeclarationStatement =",memberDeclarationStatement )
			parsed5tupleList = parseVariableDeclaration(memberDeclarationStatement)
			if parsed5tupleList == False:
				errorMessage = "ERROR in parseEnum() enum declaration after calling parseVariableDeclaration(memberDeclarationStatement) for memberDeclarationStatement = "+STR(memberDeclarationStatement)
				errorRoutine(errorMessage)
				return False
			else:
				PRINT ("enum variables declaration",parsed5tupleList, "parsed" )
				for item in parsed5tupleList:
					PRINT ("enum ",enumDataType,"has the following declarations after it" )
					PRINT ("Main enum variable name is ",item[0],"of size",item[1],"and it is located at relative index of ",item[3],"inside the variable declaration statement",item[2] )
					# Each member of the list follows exactly the same format as the parsed5tupleList, with one key addition - the 6th item.
					# This 6th member now represents the absolute index (within the tokenList) of the variable name.
					if tokenList[declarationStartIndex+item[3]-numFakeEntries]!=item[0]:
						PRINT ("ERROR in parseEnum() enum - for declarationStartIndex =",declarationStartIndex,"tokenList[declarationStartIndex+item[3]-numFakeEntries] = tokenList[",declarationStartIndex,"+",item[3],"-",numFakeEntries,"]",tokenList[declarationStartIndex+item[3]-numFakeEntries],"!=item[0]=",item[0] )
						errorMessage = "ERROR in parseEnum() enum - for declarationStartIndex ="+STR(declarationStartIndex)+" tokenList[declarationStartIndex+item[3]-numFakeEntries] = tokenList["+STR(declarationStartIndex)+"+"+STR(item[3])+"-"+STR(numFakeEntries)+"]"+STR(tokenList[declarationStartIndex+item[3]-numFakeEntries])+"!=item[0]="+STR(item[0]) 
						errorRoutine(errorMessage)
						return False
					else:
						PRINT ("Properly parsed the variable declaration")
						globalTokenListIndex = declarationStartIndex+item[3]-numFakeEntries
						
						variableDescriptionExtended = item[4]
						variableDescriptionExtended["globalTokenListIndex"]=globalTokenListIndex
						variableDescriptionExtended["parentVariableType"]=["enum",enumDataType]
#						variableDescriptionExtended["parentVariableName"]=enumDataType
						variableId = totalVariableCount
						variableDescriptionExtended["variableId"] = variableId
						totalVariableCount += 1
						variableDeclarations.append([item[0],item[1],item[2],item[3],variableDescriptionExtended]) 
						
						variableIdsInGlobalScope.append([variableId, variableId, variableId])		
			
			i = nextSemicolonIndex + 1
		
		return i					

def declarationHasBitfields(tokenList):
	if checkIfString(tokenList):
		return False
	elif not isinstance(tokenList,list):
		errorMessage = "ERROR in declarationHasBitfields: tokenList <"+STR(tokenList)+"> is not a list"
		errorRoutine(errorMessage)
		return False
		
	countQuestionMarks = 0
	countColons = 0
	
	for item in tokenList:
		if item == ';':
			break
		elif item == '?':
			countQuestionMarks += 1
		elif item == ':':
			countColons += 1
		else:
			pass
	
	if countQuestionMarks == countColons:
		return False
	elif countQuestionMarks == countColons - 1:
		return True
	else:
		errorMessage = "ERROR in declarationHasBitfields: tokenList <"+STR(tokenList)+"> has "+countQuestionMarks+" number of ? but "+countColons+" number of : before hitting the ;"
		errorRoutine(errorMessage)
		return False
		


#######################################################################################################################
# This function takes in a tokenList and an index pointing to the start of the derived type declaration and parses it	
# What it essentially does is that if there is any Derived type (basically typedef) in the declaration statement, 
# it converts that statement into one that will only contain the primitive types (int, float, char etc.).
#######################################################################################################################
def convertDerivedTypeDeclarationIntoBaseTypeDeclaration(tokenList, i):

	nextSemicolonIndex = i+1 + tokenList[i+1:].index(";")
	
	PRINT ("\n\n","=="*50,"\n","Inside convertDerivedTypeDeclarationIntoBaseTypeDeclaration(), going to evaluate", tokenList[i:nextSemicolonIndex+1])
	
	# The way we resolve the case when a base storage is a derived kind. We find out what was the original typedef's declaration statement, and 
	# then we plug in the current variable declaration in that statement.
	#
	# For example, if we have the following:
	#
	#  		typedef int INT[2]; 
	#  		INT * i[3];
	#
	# We plug in the second statement into the first after parenthesizing it. Basically, in the first declaration, replace INT with (* i[3]) and remove the typedef.
	#
	#		int (* i[3])[2];
	#
	# The problem happens when we have multiple declarations, both for typedefs declarations, and variable declarations. Like below:
	#
	#  		typedef int *ptrINT, INT[2]; 		==> we have to break it down to individual "isolated" declarations, like <int *ptrINT> and <int INT[2]>
	#  		ptrINT * i[3], (*func[2])(int);		==> we have to break it down to individual "isolated" declarations, like <* i[3]> and <(*func[2])(int)>
	#
	# Only after we break it down to individual pieces, we can do the plugging in. We do this splitting by calling parseArgumentList().
	# This function was originally written for parsing function arguments, so it expects the input list to be parenthesized. Hence we parenthesize it artificially.
	#
	# The only problem is that when I parenthesize things, it does not work for bitfields. For example, if we have this code originally:
	#
	#  		typedef unsigned long long uint64_t;
	#  		uint64_t    var :3;
	#
	# When we transform (or plug in back) the second expression in the first one, we get this:
	#
	# 		unsigned long long (var :3);
	#
	# The compiler like GCC will not accept this. So, we are taking a risk here. We are going to take the following strategy:
	# If it involves bitfield, we are going to straight plug it back in WITHOUT the parenthesis. This should not give us a lot of problems, because
	# usually bitfields do not support arrays, and you cannot have standalone bitfield variable declarations - bitfields are only allowed witin structs.
	# It is possible to have regular non-bitfield variable declaration and bitfield declaration in the same statement, like this:
	#
	#  		uint64_t a, b:3, c;
	#
	# But we are still hoping that it will simple typedefs, in which case we will be fine. If it has complex typedefs, there might be a problem.

	# Basically we are trying to figure out what all tokens occur before the derived type
	statementStartIndex = i
	while statementStartIndex > 0 and tokenList[statementStartIndex-1] in ('auto','register','static','extern', 'const','volatile', 'typedef'):
		statementStartIndex -= 1

	derivedTypeIndex = i
	while tokenList[derivedTypeIndex] in ('auto','register','static','extern', 'const','volatile'):
		derivedTypeIndex += 1

	fragmentBeforeDerivedType = tokenList[statementStartIndex:derivedTypeIndex]
	PRINT("fragmentBeforeDerivedType =",fragmentBeforeDerivedType)
	
	if tokenList[derivedTypeIndex] not in getDictKeyList(typedefs):
		errorMessage = "Supplied tokenList[derivedTypeIndex=",derivedTypeIndex,"] =",tokenList[derivedTypeIndex],"is not a declared type"
		errorRoutine(errorMessage)
		return False
		
	PRINT ("Found a previously defined type",tokenList[derivedTypeIndex],", whose details are",typedefs[tokenList[derivedTypeIndex]] )
	previouslyCreatedType = tokenList[derivedTypeIndex]
	originalTypedefCreationStatement = typedefs[previouslyCreatedType][2]
	typedefVariableIndex = typedefs[previouslyCreatedType][3]
	originalTypedefCreationStatementTypeSpecifierEndIndex = typedefs[previouslyCreatedType][4]["typeSpecifierEndIndex"]
	
	originalTypedefDeclarationSegmentStartIndex = typedefs[previouslyCreatedType][4]["currentDeclarationSegmentStartIndex"]
	originalTypedefDeclarationSegmentEndIndexInclusive = typedefs[previouslyCreatedType][4]["currentDeclarationSegmentEndIndexInclusive"]
	originalTypedefCreationStatementDeclarationSegmentIsolated = originalTypedefCreationStatement[originalTypedefDeclarationSegmentStartIndex:originalTypedefDeclarationSegmentEndIndexInclusive]
	
	
	PRINT ("For created type <",previouslyCreatedType,">, the originalTypedefCreationStatement =",originalTypedefCreationStatement )
	if "typedef" not in originalTypedefCreationStatement[:originalTypedefCreationStatementTypeSpecifierEndIndex]:
		errorMessage = "ERROR in convertDerivedTypeDeclarationIntoBaseTypeDeclaration() - the variable declaration statement for"+STR(previouslyCreatedType)+" doesn't have the string \"typedef\""
		errorRoutine(errorMessage)
		return False
	elif typedefs[previouslyCreatedType][0] != previouslyCreatedType:
		errorMessage = "ERROR in convertDerivedTypeDeclarationIntoBaseTypeDeclaration() - the variable declaration statement for "+STR(previouslyCreatedType)+" declare some other variable "+STR(typedefs[previouslyCreatedType][0])
		errorRoutine(errorMessage)
		return False
	
	# The original typedef statement might contain multiple different types created within a single typedef statement.
	# So, we need to break it up and find out which one has it
	temp = ["("]+originalTypedefCreationStatement[originalTypedefCreationStatementTypeSpecifierEndIndex+1:-1]+[")"]
	PRINT ("Going to parse the possibly multiple typedef creations in a single typedef statement = <%s>"%temp )
#	parseArgumentListResult = parseArgumentList(temp, omitColons=False)	# This is causing the statement to fail when we had both bitfield and typedef in the same declaration.
	parseArgumentListResult = parseArgumentList(temp, omitColons=True)
	if parseArgumentListResult == False:
		errorMessage = "ERROR in convertDerivedTypeDeclarationIntoBaseTypeDeclaration() while breaking up the original typedef creation statement by calling parseArgumentList(%s)"%(STR(temp))
		errorRoutine(errorMessage)
		return False
	
	PRINT ("For splitting the original typedef creation statement <%s>, parseArgumentListResult ="%(STR(originalTypedefCreationStatement)) )
	for item in parseArgumentListResult:
		PRINT (item )
	# We want to find out which typedef creation fragment contains our sought type 
	indexConsumedTillNow = originalTypedefCreationStatementTypeSpecifierEndIndex
	foundTheCorrectFragment = False
	for itemIndex in range(len(parseArgumentListResult)):
		currentItem = parseArgumentListResult[itemIndex]
		if checkIfString(currentItem):
			currentItem = [currentItem]
		elif not isinstance(currentItem,list):
			errorMessage = "ERROR: In convertDerivedTypeDeclarationIntoBaseTypeDeclaration(), Somehow the currentItem = <"+STR(currentItem)+"> is neither list nor string"
			errorRoutine(errorMessage)
			return False
		
		PRINT ("Created type # ",itemIndex, " = ", currentItem, "(the fragment)" )
		if indexConsumedTillNow+1 <= typedefVariableIndex <= indexConsumedTillNow+len(currentItem):
			PRINT ("Found the index",typedefVariableIndex )
			
			# We will later just use this, currently just using it to verify that both results are the same
#						if originalTypedefCreationStatementDeclarationSegmentIsolated != parseArgumentListResult[itemIndex]:
#							errorMessage = "ERROR: originalTypedefCreationStatementDeclarationSegmentIsolated = <"+STR(originalTypedefCreationStatementDeclarationSegmentIsolated)+"> does not match with parseArgumentListResult[itemIndex="+STR(itemIndex)+"] = <"+STR(parseArgumentListResult[itemIndex])+">"
#							errorRoutine(errorMessage)
#							return False
			
			originalTypedefCreationStatementIsolated = originalTypedefCreationStatement[:originalTypedefCreationStatementTypeSpecifierEndIndex+1]+currentItem+[";"]
			# Since we are artificially creating a new construct containing a single type creation, we also need to adjust at what index we will find the new type
			typedefVariableIndexIsolated = originalTypedefCreationStatementTypeSpecifierEndIndex + typedefVariableIndex - indexConsumedTillNow
			if originalTypedefCreationStatementIsolated[typedefVariableIndexIsolated] != previouslyCreatedType:
				errorMessage = "ERROR in convertDerivedTypeDeclarationIntoBaseTypeDeclaration(): the isolated typedef creation statement (%s) does not have %s at its index # %d"%(STR(originalTypedefCreationStatementIsolated,previouslyCreatedType,typedefVariableIndexIsolated))
				errorRoutine(errorMessage)
				return False
			else:
				PRINT ("For originalTypedefCreationStatementIsolated=<%s> and typedefVariableIndexIsolated=%d, originalTypedefCreationStatementIsolated[typedefVariableIndexIsolated]=%s"%(originalTypedefCreationStatementIsolated,typedefVariableIndexIsolated,originalTypedefCreationStatementIsolated[typedefVariableIndexIsolated]) )
				foundTheCorrectFragment = True
				break
		else:
			PRINT ("Did not find index #",typedefVariableIndex,"within index range <",indexConsumedTillNow+1,",",indexConsumedTillNow+len(currentItem)+1,"> (both indices inclusive)" )
			indexConsumedTillNow += len(currentItem) + 1 # The extra 1 at the end is for the comma (remember, multiple typedef declarations)
			PRINT ("Upping the indexConsumedTillNow to",indexConsumedTillNow )
			
	if foundTheCorrectFragment == False:
		errorMessage = "ERROR in convertDerivedTypeDeclarationIntoBaseTypeDeclaration(): Somehow did not find the %s within the typedef creation statement (%s)"%(previouslyCreatedType,STR(originalTypedefCreationStatement))
		errorRoutine(errorMessage)
		return False
		

	# We have located which part of the original typedef creation statement we need to plug in our new variable declaration into. 
	# However, remember that even the existing declarations can also have multiple variable declarations. So, we need to split it first.
	# For that, we deliberately parenthesize it because the parseArgumentList() expects the input to be structured that way.
	
	possiblyMultipleVariableDeclarations = ["("] + tokenList[i+1:nextSemicolonIndex]+ [")"]
	# We can have multiple variables declared under this same variable declared statement (separated by comma). So, we separate them.
#	parseArgumentListResult = parseArgumentList(possiblyMultipleVariableDeclarations)	# This was creating problems with bitfields
	parseArgumentListResult = parseArgumentList(possiblyMultipleVariableDeclarations, omitColons = True)
	if parseArgumentListResult == False:
		errorMessage = "ERROR in convertDerivedTypeDeclarationIntoBaseTypeDeclaration() while breaking up the variable declaration statement <%s> by calling parseArgumentList() where the base storage is a created type"%(STR(possiblyMultipleVariableDeclarations))
		errorRoutine(errorMessage)
		return False
	else:
		PRINT ("For splitting the created type variable declaration statement, parseArgumentListResult =" )
		for item in parseArgumentListResult:
			PRINT (item )
		
		# We just want to scoop up the portion of the original typedef statement that we can re-use again and again for each of the current var declarations.
		# This means we are omiting the semicolon at the end
		
		convertedMultipleDeclarations = []
		# If the current statement, which uses a created type as base storage, is yet another typedef, then we need to put an extra typedef at the beginning.
#		if i>0 and tokenList[i-1]=="typedef":
#			convertedMultipleDeclarations.append("typedef")
		convertedMultipleDeclarations = fragmentBeforeDerivedType
		
		# Remember that the original typedef creation statement, the string "typedef" may or may NOT be the first item. C allows it to be anywhere.
		# So, we remove the "typedef" from the original string.
		originalBaseStorageSpecifierStatementAfterTypedefRemoval = originalTypedefCreationStatementIsolated[:originalTypedefCreationStatementTypeSpecifierEndIndex+1]
		originalBaseStorageSpecifierStatementAfterTypedefRemoval.remove("typedef")
		PRINT ("Removed the string \"typedef\" from originalTypedefCreationStatementIsolated[:originalTypedefCreationStatementTypeSpecifierEndIndex+1] = <",originalTypedefCreationStatementIsolated[:originalTypedefCreationStatementTypeSpecifierEndIndex+1],">" )
		PRINT ("And added the \"typedef\"-removed string <",originalBaseStorageSpecifierStatementAfterTypedefRemoval,"> to the convertedMultipleDeclarations" )
		convertedMultipleDeclarations.extend(originalBaseStorageSpecifierStatementAfterTypedefRemoval)
		PRINT ("So that now the base storage specifier for convertedMultipleDeclarations = ",convertedMultipleDeclarations )
		
		for listIndex in range(len(parseArgumentListResult)):
			item = parseArgumentListResult[listIndex]	# TO-DO: Looks like when it returns a single-item, it returns it as string (as opposed to a list with a single string item)
		
			replacedTypedefCreationStatement = originalTypedefCreationStatementIsolated[originalTypedefCreationStatementTypeSpecifierEndIndex+1:typedefVariableIndexIsolated]
			
			typedefReplacement = []
			
			# We deliberately put the braces around the item, or else it will not work. It's a MUST
			
			# If it is a bitfield, do not put the additional parenthesis markers at the beginning or the end.
			doNotParenthesize = declarationHasBitfields(item)
			
			if not doNotParenthesize:
				typedefReplacement.append("(")
			if isinstance(item,list):
				typedefReplacement.extend(item)
			elif checkIfString(item):
				typedefReplacement.append(item)
			else:
				errorMessage = "ERROR in convertDerivedTypeDeclarationIntoBaseTypeDeclaration() - the output <%s> from parseArgumentList() is neither list nor string"%(STR(item))
				errorRoutine(errorMessage)
				return False
			if not doNotParenthesize:
				typedefReplacement.append(")")
			
			PRINT ("We are going to replace the <",previouslyCreatedType,"> in the original typedef creation statement with <",typedefReplacement,">" )
			replacedTypedefCreationStatement.extend(typedefReplacement)
			
			replacedTypedefCreationStatement.extend(originalTypedefCreationStatementIsolated[typedefVariableIndexIsolated+1:-1])
			
			if replacedTypedefCreationStatement[-1] == ";":
				errorMessage = "CODING ERROR: Somehow picked up the semicolon at the end - exiting"
				errorRoutine(errorMessage)
				sys.exit()

			if listIndex == len(parseArgumentListResult)-1:
				replacedTypedefCreationStatement.append(";")
			else:
				replacedTypedefCreationStatement.append(",")
				
			convertedMultipleDeclarations.extend(replacedTypedefCreationStatement)
			
			PRINT ("So individual originalTypedefCreationStatementIsolated = <",originalTypedefCreationStatementIsolated,"> now became <",convertedMultipleDeclarations,">" )
			
		list2parse = convertedMultipleDeclarations
		PRINT ("Returning the following from convertDerivedTypeDeclarationIntoBaseTypeDeclaration()\n\n", list2parse,"\n\n","=="*50,"\n")
		
		return list2parse



# This converts an absolute bit number to byte.bit format. For example, bit 9 would yield 1.2
def bit2ByteAndBit(bits):
	if (not checkIfIntegral(bits)) or bits < 0:
		errorMessage = "ERROR in bit2ByteAndBit(): Illegal value of bits ="+STR(bits)
		errorRoutine(errorMessage)
		return False
	
	bytes = bit2Byte(bits)
	bitNum = bits % BITS_IN_BYTE
	
	return STR(bytes)+"."+STR(bitNum)

# This function returns the bit number that is aligned to a certain bit boundary.
# If the bit is already aligned, it will send the previous aligned bit (which could be negative also). For example, for bit=0, alignment=8 it will return -8.
def alignedStrictlyBefore(bit, alignment):
	if (not checkIfIntegral(bit)) or (not checkIfIntegral(alignment)) or alignment < 1:
		errorMessage = "ERROR in alignedStrictlyBefore(): Illegal value of bit ="+STR(bit)+", alignment = "+STR(alignment)
		errorRoutine(errorMessage)
		return False
	else:
		if bit% alignment == 0:
			return (bit-alignment)
		else:
			return (bit - (bit% alignment))

# This function returns the bit number that is aligned to a certain bit boundary.
# If the bit is already aligned, it will send the next aligned bit. For example, for bit=0, alignment=8 it will return 8.
def alignedStrictlyAfter(bit, alignment):
	if (not checkIfIntegral(bit)) or (not checkIfIntegral(alignment)) or alignment < 1:
		errorMessage = "ERROR in alignedStrictlyBefore(): Illegal value of bit ="+STR(bit)+", alignment = "+STR(alignment)
		errorRoutine(errorMessage)
		return False
	else:
		if bit% alignment == 0:
			return (bit+alignment)
		else:
			return (bit - (bit% alignment) + alignment)

# This function returns the bit number that is aligned to a certain bit boundary.
# If the bit is already aligned, it will send the that bit. For example, for bit=0, alignment=8 it will return 0.
def alignedOnOrBefore(bit, alignment):
	if (not checkIfIntegral(bit)) or (not checkIfIntegral(alignment)) or alignment < 1:
		errorMessage = "ERROR in alignedOnOrBefore(): Illegal value of bit ="+STR(bit)+", alignment = "+STR(alignment)
		errorRoutine(errorMessage)
		return False
	else:
		if bit% alignment == 0:
			return bit
		else:
			return (bit - (bit% alignment))
		
# This function returns the bit number that is aligned to a certain bit boundary.
# If the bit is already aligned, it will send the that bit. For example, for bit=0, alignment=8 it will return 0.
def alignedOnOrAfter(bit, alignment):
	if (not checkIfIntegral(bit)) or (not checkIfIntegral(alignment)) or alignment < 1:
		errorMessage = "ERROR in alignedOnOrAfter(): Illegal value of bit ="+STR(bit)+", alignment = "+STR(alignment)
		errorRoutine(errorMessage)
		return False
	else:
		if bit% alignment == 0:
			return bit
		else:
			return (bit - (bit% alignment) + alignment)

# This routine calculates how at least how means bits the data container must be wide to accommodate the enum literal values.
def enumMinBitSize(enumDataType):
	if enumDataType not in getDictKeyList(enums):
		errorMessage = "ERROR in enumMinBitSize(): Illegal enumDataType ="+STR(enumDataType)
		errorRoutine(errorMessage)
		return False
	
	enumFields = enums[enumDataType]
	
	# Figure out how many bits is minimum required to represent the enum properly
	maxPositiveValue = -1
	maxNegativeVaue = 0
	for enumLiteral in getDictKeyList(enumFields):
		enumValue = enumFields[enumLiteral]
		if enumValue > maxPositiveValue:
			maxPositiveValue = enumValue
		if enumValue < maxNegativeVaue:
			maxNegativeVaue = enumValue
	largestAbsoluteValueToHandle = max(2*maxPositiveValue,(-1)*maxNegativeVaue)
	temp = 1
	minBitSize = 1
	while True:
		if temp>=largestAbsoluteValueToHandle:
			break
		else:
			minBitSize += 1
			temp = temp * 2
	MUST_PRINT("For enum type",enumDataType,", enumFields =",enumFields)
	MUST_PRINT("\nmaxPositiveValue =",maxPositiveValue,", maxNegativeVaue =",maxNegativeVaue,", largestAbsoluteValueToHandle =",largestAbsoluteValueToHandle,", minBitSize =",minBitSize)
	
	return minBitSize

##############################################################################################################################################
##########################################################################################################################################################
##																																						##
## 		This function takes in a tokenListInformation where a structure definition (starting with '{', ending with '}') is happening from token # i 	##
##		The return value is the name of the structure, which is global. This is particularly useful for Anynymous structure.							##
##		The third parameter is parentStruct. It is mostly used for Nested structure. For top-level structs, this value is "--Global--" 					##
##      The reason we choose "--Global--" is because it is NOT a valid identifier name. So it cannot clash.												##
##		The fourth parameter is the level. It tells at what scope level this structure is.																##
##																																						##
##		This is the function that adds the entry to the structuresAndUnions[] and suDict{}. It does not do anything to the typedefs{}      				##
##																																						##
##########################################################################################################################################################
##########################################################################################################################################################

def parseStructureDefinition(tokenListInformation, i, parentStructName, level):
	PRINT ("="*30,"\nInside parseStructureDefinition()\n","="*30,"\n" )
	global typedefs, enums, lines, structuresAndUnions, suDict, primitiveDatatypeLength, variableDeclarations, dummyVariableCount, totalVariableCount

	if not isinstance(tokenListInformation,list):
		errorMessage = "ERROR in parseStructureDefinition(): tokenListInformation <"+STR(tokenListInformation)+"> is not a list"
		errorRoutine(errorMessage)
		return False
	elif not tokenListInformation:
		errorMessage = "ERROR in parseStructureDefinition(): Empty passed tokenListInformation"
		errorRoutine(errorMessage)
		return False
	elif len(tokenListInformation)!=3:
		errorMessage = "ERROR in parseStructureDefinition(): passed tokenListInformation is invalid (should be a triad)"
		errorRoutine(errorMessage)
		return False
		
	tokenList = tokenListInformation[0]

	curlyBraceStartIndex = i

	######################################################
	# Check for all possible immediately-catchable errors
	if not isinstance(tokenList,list):
		errorMessage = "ERROR in parseStructureDefinition(): tokenList <"+STR(tokenList)+"> is not a list"
		errorRoutine(errorMessage)
		return False
	elif not tokenList:
		errorMessage = "ERROR in parseStructureDefinition(): Empty passed tokenList"
		errorRoutine(errorMessage)
		return False
	elif (not checkIfIntegral(i)) or i <0 or i>=len(tokenList):
		errorMessage = "ERROR in parseStructureDefinition(): Illegal value of i ="+STR(i)
		errorRoutine(errorMessage)
		return False
	elif tokenList[i] != '{' :
		errorMessage = "ERROR in parseStructureDefinition(): tokenList[i] =  tokenList[" + STR(i) + "] = <" + STR(tokenList[i]) + "> is not a struct or union"
		errorRoutine(errorMessage)
		return False

	# Find out from where the struct definition statement actually starts
	structDefinitionStartIndex = i
	structOrUnionTypeIndex = LARGE_NEGATIVE_NUMBER	# By default error value
	while True:
		if tokenList[structDefinitionStartIndex] in ("struct","union"):
			structOrUnionTypeIndex = structDefinitionStartIndex
		if structDefinitionStartIndex == 0:
			break
		# TO-DO: Bug - we assume that there is going to be a semicolon before the struct definition. It may not, if the previous statement is a #define statement.
		elif tokenList[structDefinitionStartIndex-1] in (';','{'):	# we could very well have cascaded struct definition, hence checking for the '{' is important
			break
		structDefinitionStartIndex -= 1
	
	# Now, the problem is that there might be #RUNTIME statements before the struct definition. Remember that #RUNTIME statements do NOT end with a semicolon.
	# We do not have the same problem with #define statements, since there is will NOT be any #define statements here at all, since the preprocessor
	# will take care of that (when this routine gets called, there are no #define statements left). However, #RUNTIME statements might still be there.
	
	while True:
		# Exclude the runtime statements
		if preProcessorSymbol not in tokenList[structDefinitionStartIndex:i]:
			break
		# If there is a runtime statement, it must begin right from the beginning (structDefinitionStartIndex)
		elif not (preProcessorSymbol in tokenList[structDefinitionStartIndex:i] and tokenList[structDefinitionStartIndex+tokenList[structDefinitionStartIndex:i].index(preProcessorSymbol)+1] in runtimeDirectives):
			PRINT("There are NO runtime statements within tokenList[structDefinitionStartIndex (",structDefinitionStartIndex,"):i(",i,")]=",tokenList[structDefinitionStartIndex:i])
			break
		else:
			PRINT("There ARE runtime statements within tokenList[structDefinitionStartIndex (",structDefinitionStartIndex,"):i(",i,")]=",tokenList[structDefinitionStartIndex:i])
			#Find out the all the to
			if tokenList[structDefinitionStartIndex] != preProcessorSymbol or tokenList[structDefinitionStartIndex+1] not in runtimeDirectives:
				errorMessage = "ERROR in parseStructureDefinition(): Illegal #RUNTIME statement found: \n\n"+list2plaintext(tokenList[structDefinitionStartIndex:i])
				errorRoutine(errorMessage)
				return False
			else:
				resultPair = firstAndLastTokenIndicesOnSameLineForTokenNumber(structDefinitionStartIndex, tokenListInformation)
				if resultPair == False:
					errorMessage = "ERROR in parseStructureDefinition() after trying to find the first and last tokens for tokenList["+STR(structDefinitionStartIndex)+"] = "+tokenList[structDefinitionStartIndex]
					errorRoutine(errorMessage)
					return False
				elif tokenList[resultPair[0]] != preProcessorSymbol:	# Sanity check - the first token in that line must be the preprocessor symbol #
					errorMessage = "ERROR in parseStructureDefinition() - the first token on that line is not '"+preProcessorSymbol+"' but rather <"+tokenList[resultPair[0]]+">"
					errorRoutine(errorMessage)
					return False
				else:
					runtimeTokenStream = tokenList[resultPair[0]:resultPair[1]+1]
					PRINT("Found following part of the tokenstream BEFORE the struct declaration that is a # RUNTIME directive:\n",runtimeTokenStream)
					structDefinitionStartIndex = resultPair[1] + 1	# Move the pointer
					continue
	
	if structOrUnionTypeIndex < 0:
		errorMessage = "ERROR in parseStructureDefinition(): No struct or union definition statement found"
		errorRoutine(errorMessage)
		return False
	else:
		PRINT("tokenList[structOrUnionTypeIndex =",structOrUnionTypeIndex,"] =",tokenList[structOrUnionTypeIndex])
		structOrUnionType = "struct" if tokenList[structOrUnionTypeIndex] == "struct" else  "union" if tokenList[structOrUnionTypeIndex] == "union" else "ERROR"
		if structOrUnionType not in ("struct","union"): 
			OUTPUT("Coding bug in parseStructureDefinition() - tokenList[structOrUnionTypeIndex=",structOrUnionTypeIndex,"] = ",tokenList[structOrUnionTypeIndex]," - exiting")
			sys.exit()

	PRINT("The", tokenList[structOrUnionTypeIndex] ,"definition starts from token[",structDefinitionStartIndex,"] = ",tokenList[structDefinitionStartIndex])

	if ("struct" in tokenList[structDefinitionStartIndex:i]) and ("union" in tokenList[structDefinitionStartIndex:i]):
		errorMessage = "ERROR in parseStructureDefinition(): Cannot say that it is both struct and union. tokenList[structDefinitionStartIndex(%d):i(%d)] = %s"%(structDefinitionStartIndex,i,STR(tokenList[structDefinitionStartIndex:i]))
		errorRoutine(errorMessage)
		return False
	elif "}" not in tokenList[curlyBraceStartIndex:]:
		PRINT ("ERROR in parseStructureDefinition() - no matching { for struct declaration global token index", i, " - exiting" )
		errorMessage = "ERROR in parseStructureDefinition() - no matching { for struct declaration - exiting"
		errorRoutine(errorMessage)
		return False
	elif matchingBraceDistance(tokenList[curlyBraceStartIndex:]) < 1:
		PRINT ("ERROR in parseStructureDefinition() - cannot find matching brace in",tokenList[curlyBraceStartIndex:], " - exiting!" )
		errorMessage = "ERROR in parsing - cannot find matching brace in tokenlist starting from token %s "% (tokenList[curlyBraceStartIndex])
		errorRoutine(errorMessage)
		return False
	elif not checkIfString(parentStructName):
		PRINT ("parentStructName =",parentStructName)
		errorMessage = "ERROR in parseStructureDefinition(): parentStructName = <"+STR(parentStructName)+"> is not a a valid string"
		errorRoutine(errorMessage)
		return False
	elif parentStructName != "--Global--" and parentStructName not in getDictKeyList(suDict):
		errorMessage = "ERROR in parseStructureDefinition() - parentStructName = <"+parentStructName+"> is not a valid parent struct/union - exiting!" 
		errorRoutine(errorMessage)
		return False

	#####################################################################################
	# Find the structure name, and add a blank entry in the overall structure dictionary
	curlyBraceEndIndex = curlyBraceStartIndex + matchingBraceDistance(tokenList[curlyBraceStartIndex:])
	
	if ";" not in tokenList[curlyBraceEndIndex+1:]:
		errorMessage = "ERROR in parseStructureDefinition() - for parentStructName = <"+parentStructName+">, no semicolon after ending curly brace - exiting!" 
		errorRoutine(errorMessage)
		return False
	else:
		nextSemicolonAfterCurlyBraceEndIndex = curlyBraceEndIndex+1 + tokenList[curlyBraceEndIndex+1:].index(";")

		# When we have the __attribute__ statement right after the closing "}", it is considered. Otherwise, it is ignored
		#  Allowed: struct  S { char c; short s, int i;} __attribute__((packed))Sa;
		#  Ignored: struct  S { char c; short s, int i;}                        Sa __attribute__((packed));
		# So, we need to find out exactly where the "valid" __attribute__ statements end (there might be multiple such statements)
		
		lastValidAttributeEndIndex = curlyBraceEndIndex
		while tokenList[lastValidAttributeEndIndex+1] == ATTRIBUTE_STRING :
			lastValidAttributeEndIndex = lastValidAttributeEndIndex+2+matchingBraceDistance(tokenList[lastValidAttributeEndIndex+2:nextSemicolonAfterCurlyBraceEndIndex])

		# Now, these are the indices of the various key items:
		
		# structDefinitionStartIndex 			- where the struct definition statement actually starts
		# structOrUnionTypeIndex 				- index of the field that contains the struct/union keyword
		# curlyBraceStartIndex					- self-explanatory
		# curlyBraceEndIndex					- self-explanatory
		# lastValidAttributeEndIndex			- this is the index of the token where (if any) valid post-"}" __attribute__ statements end 
		# nextSemicolonAfterCurlyBraceEndIndex	- self-explanatory

		if not (structDefinitionStartIndex <= structOrUnionTypeIndex < curlyBraceStartIndex < curlyBraceEndIndex < nextSemicolonAfterCurlyBraceEndIndex):
			errorMessage = "Error in parseStructure - we don't have structDefinitionStartIndex(%d) <= structOrUnionTypeIndex(%d) < curlyBraceStartIndex(%d) < curlyBraceEndIndex(%d) < nextSemicolonAfterCurlyBraceEndIndex (%d)"%(structDefinitionStartIndex, structOrUnionTypeIndex, curlyBraceStartIndex, curlyBraceEndIndex, nextSemicolonAfterCurlyBraceEndIndex)
			errorRoutine(errorMessage)
			return False

		
		# These are the "slots" (defined by a [start index, end index] where the __attribute__ statements might reside)
		# Observe that we deliberately put structDefinitionStartIndex-1 instead of just structDefinitionStartIndex, because in all other cases we cannot have the
		# __attribute__statement right on any of the start or end indices, but for structDefinitionStartIndex it might be the case
		attributeSlots = [[structDefinitionStartIndex-1, structOrUnionTypeIndex],[structOrUnionTypeIndex, curlyBraceStartIndex],[curlyBraceEndIndex,lastValidAttributeEndIndex]]
			
		
		# Handle all the attributes in all possible slots
		
		attributes = {}	# This is the structure-level dectionary that will store all the attributes from the various __attribute__ statements
		attributeIndicesStartEnd = {}	# We want to cache the <start index, end index (inclusive) > of each of the __attribute__ statements
		
		for startEndPair in attributeSlots:
			startIndex = startEndPair[0]
			endIndex = startEndPair[1]
			
			k = startIndex + 1
			while (k < endIndex):
				if tokenList[k] != ATTRIBUTE_STRING:
					k += 1
				else:
					PRINT("Currently processing tokenList = < %s >"%STR(tokenList[k:endIndex+1]))
					parseAttributeResult = parseAttribute(tokenList[k:endIndex+1])
					if parseAttributeResult[0] != True:
						errorMessage = "ERROR in parseStructureDefinition() after calling parseAttribute() for tokenList[k(%d):endIndex(%d) = <%s>]"%(k,endIndex,STR(tokenList[k:endIndex]))
						errorRoutine(errorMessage)
						return False
					else:
						d = parseAttributeResult[1]["distance"]
						attributeIndicesStartEnd[k]=k+1+d
						PRINT("parseAttributeResult[1] = ",parseAttributeResult[1])
						for (key, value) in parseAttributeResult[1].items():
							if key == ALIGNED_STRING and ALIGNED_STRING in getDictKeyList(attributes):
								attributes[key] = max(value,attributes[key])
							else:
								attributes[key] = value
						k = attributeIndicesStartEnd[k] + 1

		# Sanity check
		rightMostIndexForAttributeStatementEndTokenBeforeCurlyBraceStart = LARGE_NEGATIVE_NUMBER
		totalTokensConsumedByAttributeStatements = 0
		for (key, value) in attributeIndicesStartEnd.items():
			if tokenList[key:key+3] != [ATTRIBUTE_STRING,"(","("] or tokenList[value-1:value+1] != [")",")"]:
				errorMessage = "ERROR in parseStructureDefinition() while doing sanity check after calling parseAttribute(); tokenList[k(%d):value+1(%d) = <%s>]"%(key, value+1, STR(tokenList[key:value+1]))
				errorRoutine(errorMessage)
				return False
			# We also check which is the right-most __attribute__ statement within [structOrUnionTypeIndex, curlyBraceStartIndex]
			# The reason we do this is that if there is struct name, it must be the one right before the "{".
			# Remember that this construction below is not allowed:
			#
			#  struct S __attribute__((packed)){ char c; short s, int i;} Sa;
			if structOrUnionTypeIndex < key < curlyBraceStartIndex:
				totalTokensConsumedByAttributeStatements += attributeIndicesStartEnd[key] - key + 1
				if attributeIndicesStartEnd[key] > rightMostIndexForAttributeStatementEndTokenBeforeCurlyBraceStart:
					rightMostIndexForAttributeStatementEndTokenBeforeCurlyBraceStart = attributeIndicesStartEnd[key]

		structName = ""
		if totalTokensConsumedByAttributeStatements == 0:	# No __attribute__ statement between the struct and {
			PRINT ("No __attribute__ statement between the struct and {")
			if curlyBraceStartIndex == structOrUnionTypeIndex + 1:
				PRINT ("Anonymous struct/union")
			elif curlyBraceStartIndex == structOrUnionTypeIndex + 2:
				structName = tokenList[structOrUnionTypeIndex+1]
			else:
				errorMessage = "ERROR in parseStructureDefinition() for tokenList[structOrUnionTypeIndex(%d):curlyBraceStartIndex(%d)+1 = <%s>] - extra tokens other than the struct/union name between the struct/union and the \"{\""%(structOrUnionTypeIndex,curlyBraceStartIndex,STR(tokenList[structOrUnionTypeIndex:curlyBraceStartIndex+1]))
				errorRoutine(errorMessage)
				return False
		else:		# There are __attribute__ statement between the "struct" and "{"
			PRINT ("There are __attribute__ statement(s) between the struct and { that consume a total of ",totalTokensConsumedByAttributeStatements,"tokens")
			if totalTokensConsumedByAttributeStatements == curlyBraceStartIndex - structOrUnionTypeIndex - 1:	# Nothing other than __attribute__ statements, if any
				PRINT ("Anonymous struct/union")
			elif totalTokensConsumedByAttributeStatements < curlyBraceStartIndex - structOrUnionTypeIndex - 1:
				# So there is at least one non-attribute token between the "struct" and "{"
				if rightMostIndexForAttributeStatementEndTokenBeforeCurlyBraceStart == curlyBraceStartIndex - 1:
					errorMessage = "ERROR in parseStructureDefinition() for tokenList[structOrUnionTypeIndex(%d):curlyBraceStartIndex(%d)+1 = <%s>] - the struct name must be just before the \"{\""%(structOrUnionTypeIndex,curlyBraceStartIndex,STR(tokenList[structOrUnionTypeIndex:curlyBraceStartIndex+1]))
					errorRoutine(errorMessage)
					return False
				elif totalTokensConsumedByAttributeStatements + 1 < curlyBraceStartIndex - structOrUnionTypeIndex - 1:
					errorMessage = "ERROR in parseStructureDefinition() for tokenList[structOrUnionTypeIndex(%d):curlyBraceStartIndex(%d)+1 = <%s>] - extra token just before the \"{\""%(structOrUnionTypeIndex,curlyBraceStartIndex,STR(tokenList[structOrUnionTypeIndex:curlyBraceStartIndex+1]))
					errorRoutine(errorMessage)
					return False
				elif totalTokensConsumedByAttributeStatements + 1 == curlyBraceStartIndex - structOrUnionTypeIndex - 1:
					if rightMostIndexForAttributeStatementEndTokenBeforeCurlyBraceStart == curlyBraceStartIndex - 2:
						structName = tokenList[curlyBraceStartIndex-1]
					else:
						errorMessage = "ERROR in parseStructureDefinition() for tokenList[structOrUnionTypeIndex(%d):curlyBraceStartIndex(%d)+1 = <%s>] - No idea why I am here"%(structOrUnionTypeIndex,curlyBraceStartIndex,STR(tokenList[structOrUnionTypeIndex:curlyBraceStartIndex+1]))
						errorRoutine(errorMessage)
						return False
				
		PRINT ("After parsing all the struct-level __atribute__ statements for structName = <",structName,">, the attribute is ", attributes)
		
		# Find out if it is named structure or not. The way we find it is that we assume there might be __attribute__ statements betwen the structOrUnionTypeIndex
		# and the curlyBraceStartIndex. However, if it is a named struct/union, the name must be the very token right before 
		
		structNameAlreadyDeclared = False
		
		
		if structName != "":	# Named struct declaration
			if suDict and structName in getDictKeyList(suDict):
				if "components" in getDictKeyList(structuresAndUnions[suDict[structName][-1]]) and structuresAndUnions[suDict[structName][-1]]["components"] != []:
					structNameAlreadyDeclared = True
					PRINT ("Warning in parseStructureDefinition()" )
					warningMessage = "Warning in parseStructureDefinition(): structName %s already exists as another %s!"%(structName,structuresAndUnions[suDict[structName][-1]]["type"])
					warningRoutine(warningMessage)
#					return False
				else:
					# Handle the case of empty declarations. This is to handle the case of circular struct definition in C
					# For example, this is legal is C:
					# 										struct A { struct B * b;};
					# 										struct B { struct A * a;};
					#
					PRINT ("struct ", structName, "already declared, but NOT its components" )
				
			elif typedefs and (structName in getDictKeyList(typedefs)):
				PRINT ("ERROR in parseStructureDefinition()" )
				errorMessage = "structName %s already exists as another already-declared typedef %s!"%(structName,STR(typedefs[structName]))
				errorRoutine(errorMessage)
				return False
		elif structName == "":	# Anonymous struct definition
			PRINT ("WARNING: Anonymous structure/union declaration!!" )
			if suDict:
				totalNumberOfEmptyStructsTillNow = 0
				for key in getDictKeyList(suDict):
					if (len(key) > len(anonymousStructPrefix)) and (key[:len(anonymousStructPrefix)] == anonymousStructPrefix):
						num = int(key[len(anonymousStructPrefix):])
						if num > totalNumberOfEmptyStructsTillNow:
							totalNumberOfEmptyStructsTillNow = num
				structName = anonymousStructPrefix + STR(totalNumberOfEmptyStructsTillNow+1)
			else:
				structName = anonymousStructPrefix + "1"
		else:
			PRINT ("ERROR - should have never come here in parseStructureDefinition()" )
			PRINT ("tokenList[i] = tokenList[",i,"] = ",tokenList[i]," tokenList =",tokenList)
			errorMessage = "ERROR in parseStructureDefinition() figuring out if the struct/union is named or anonymous - should have never come here "
			errorRoutine(errorMessage)
			sys.exit()

		structDefinitionStartLineNum = tokenListInformation[1][structDefinitionStartIndex][2][0][0]
		PRINT("The struct",structName,"is defined on line #",structDefinitionStartLineNum,", from global token index",structDefinitionStartIndex)

			
		# Each row of this structuresAndUnions is a dictionary itself. The value dictionary is of this format: 
		# "name": structName, "type" : "struct/union", "size":size, "components":[[variable1 name, variable size, variable declaration statement, variable description],...]}
		
		#The reason we create a blank entry right away is that there might be a pointer to a struct itself inside its member list
		PRINT("Adding", structName," to structuresAndUnions in parseStructureDefinition()")
		structuresAndUnions.append( {"name":structName} )
		structId = len(structuresAndUnions)-1
		if not structNameAlreadyDeclared:
			suDict[structName] = [structId]
		elif structNameAlreadyDeclared: 
			suDict[structName].append(structId)

		# Verify that the total struct count matches between suDict and structuresAndUnions
		suDictCount = 0
		for key in getDictKeyList(suDict):
			if not isinstance(suDict[key], list) or len(suDict[key])==0:	# Sanity check
				errorMessage = "ERROR in parseStructureDefinition(): For structName "+key+" , entry ("+STR(suDict[key])+") exists in suDict but it is illegal (not a proper list)"
				errorRoutine(errorMessage)
				sys.exit()
			else:
				suDictCount += len(suDict[key])
		if len(structuresAndUnions) != suDictCount:
			errorMessage = "ERROR in parseStructureDefinition(): len(structuresAndUnions) = "+STR(len(structuresAndUnions))+" while total length of all lists in suDict = "+STR(suDictCount)+ " !!!"
			errorRoutine(errorMessage)
			sys.exit()
		structuresAndUnions[suDict[structName][-1]] = {"type":structOrUnionType}
		structuresAndUnions[suDict[structName][-1]]["name"] = structName
		structuresAndUnions[suDict[structName][-1]]["structId"] = suDict[structName][-1]
		structuresAndUnions[suDict[structName][-1]]["parentStructName"] = parentStructName
		structuresAndUnions[suDict[structName][-1]]["components"] = []
		structuresAndUnions[suDict[structName][-1]]["structDefinitionStartLineNum"] = structDefinitionStartLineNum
		structuresAndUnions[suDict[structName][-1]]["structDefinitionStartIndex"] = structDefinitionStartIndex		# The global token index
		structuresAndUnions[suDict[structName][-1]]["attributes"] = attributes		# Could be blank
		
		# Earlier we would only add attributes if it were non-blank. Now we even add a blank attribute.
		
#		if attributes:
#			structuresAndUnions[suDict[structName][-1]]["attributes"] = attributes
		
		i = curlyBraceStartIndex + 1
		
		structSizeBytes = 0

		usingDummyVariable = False
		isDynamic = False
		structuresAndUnions[suDict[structName][-1]]["isDynamic"] = False
		runtimeStatementsRelativeToComponentIndex = [] # a list of runtime statements within the struct, and with their relative position
		structMemberCount = -1	# We need this to figure out exactly where the #runtime statements within a struct definition are. Every #Runtime statement tells it comes after memberId
		
		############################################################################
		# Parse all the individual members of this struct/union
		while i < curlyBraceEndIndex:

			# Find runtime directives
			if tokenList[i] == preProcessorSymbol and i+1<len(tokenList) and tokenList[i+1] in runtimeDirectives:
				PRINT("\n\nFound # RUNTIME directive within structure definition\n\n")
				isDynamic = True
				structuresAndUnions[suDict[structName][-1]]["isDynamic"] = True
				resultPair = firstAndLastTokenIndicesOnSameLineForTokenNumber(i, tokenListInformation)
				if resultPair == False:
					errorMessage = "ERROR in parseStructureDefinition() after trying to find the first and last tokens for tokenList["+STR(i)+"] = "+tokenList[i]
					errorRoutine(errorMessage)
					return False
				elif tokenList[resultPair[0]] != preProcessorSymbol:	# Sanity check - the first token in that line must be the preprocessor symbol #
					errorMessage = "ERROR in parseStructureDefinition() - the first token on that line is not '"+preProcessorSymbol+"' but rather <"+tokenList[resultPair[0]]+">"
					errorRoutine(errorMessage)
					return False
				else:
					runtimeTokenStream = tokenList[resultPair[0]:resultPair[1]+1]
					PRINT("Found following part of the tokenstream within the struct declaration that is a # RUNTIME directive:\n",runtimeTokenStream)
					runtimeStatementsRelativeToComponentIndex.append(runtimeTokenStream)
					PRINT("After adding, runtimeStatementsRelativeToComponentIndex =",runtimeStatementsRelativeToComponentIndex)
					i = resultPair[1] + 1	# Move the pointer
					continue

			if ";" not in tokenList[i:curlyBraceEndIndex]: #and not (i<=curlyBraceEndIndex-2 and tokenList[i]==preProcessorSymbol and tokenList[i+1] == runtimeDirective):
				PRINT ("No semicolon in tokenList[i:curlyBraceEndIndex] = tokenList[",i,":",curlyBraceEndIndex,"] = ",tokenList[i:curlyBraceEndIndex] )
				errorMessage = "ERROR in parseStructureDefinition() while parsing - every %s member declaration must end with a semicolon - exiting"%structOrUnionType
				errorRoutine(errorMessage)
				return False
			else:
				#TO-DO: Empty declaration statement (semicolon only) for struct?
				nextSemicolonIndex = i+1 + tokenList[i+1:curlyBraceEndIndex].index(";")
			
			structDefinedHere = False	# Default value for nested structure definition
			
			# Nested structure declaration. Remember that there might be __attribute__ statements all round
			if ('{' in tokenList[i+1:nextSemicolonIndex]) and (('struct' in tokenList[i:nextSemicolonIndex]) or ('union' in tokenList[i:nextSemicolonIndex])):	
				nestedStructureCurlyBraceStartIndex = i+1 + tokenList[i+1:].index("{")
				nestedStructOrUnionType = "struct" if "struct" in tokenList[i:nestedStructureCurlyBraceStartIndex] else "union"
				matchingBraceDistanceNested = matchingBraceDistance(tokenList[nestedStructureCurlyBraceStartIndex:])
				if matchingBraceDistanceNested <1:
					errorMessage = "Error in parseStructureDefinition() for structName <"+structName+"> - missing \"}\" for nested "+nestedStructOrUnionType+" declaration"
					errorRoutine(errorMessage)
					return False
				else:
					nestedStructureCurlyBraceEndIndex = nestedStructureCurlyBraceStartIndex + matchingBraceDistanceNested

				PRINT("Going to invoke parseStructureDefinition() recursively for nested structure")
				
				# The result is the structName, which is particularly useful when it is an Anonymous structure
				parseStructureDefinitionResult = parseStructureDefinition(tokenListInformation, nestedStructureCurlyBraceStartIndex, structName, level+1)
				
				if parseStructureDefinitionResult == None:
					errorMessage = "Error coding parseStructureDefinition() for structName <"+structName+"> - return value is None"
					errorRoutine(errorMessage)
					return False
				elif parseStructureDefinitionResult == False:
					errorMessage = "Error calling parseStructureDefinition() for nested struct - return value is None"
					errorRoutine(errorMessage)
					return False
				
				# Calling calculateStructureLength() to update the struct-level alignment in the global structuresAndUnions.
				PRINT("Invoking parseStructureDefinition() recursively for nested structure succeeded")
				PRINT("Now going to invoke calculateStructureLength() from parseStructureDefinition() for nested structure", parseStructureDefinitionResult)
				calculateStructureLengthResult = calculateStructureLength(parseStructureDefinitionResult)
				if calculateStructureLengthResult == False:
					errorMessage = "Error calling calculateStructureLength() from  parseStructureDefinition() for nested structure - return Value is False"
					errorRoutine(errorMessage)
					return False
				else:
					PRINT("Invoking calculateStructureLength() from parseStructureDefinition() for nested structure succeeded")
					nestedStructName = parseStructureDefinitionResult
#					PRINT("\nAfter invoking calculateStructureLength() from parseStructureDefinition() for nested structure",nestedStructName,", suDict =",suDict,", structuresAndUnions[",suDict[nestedStructName][-1],"] =\n",structuresAndUnions[suDict[nestedStructName][-1]])
					PRINT ("Parsed upto tokenList[",i,"] = ",tokenList[i],"after parsing nested",nestedStructOrUnionType )
					if ';' not in tokenList[nestedStructureCurlyBraceEndIndex+1:curlyBraceEndIndex]:
						errorMessage = "Error in parseStructureDefinition(): No semicolon following nested %s declaration"%nestedStructOrUnionType
						errorRoutine(errorMessage)
						return False
					structDefinedHere = True
					nextSemicolonIndex = nestedStructureCurlyBraceEndIndex+1 + tokenList[nestedStructureCurlyBraceEndIndex+1:curlyBraceEndIndex].index(";")
					memberDeclarationStatement = tokenList[i:nestedStructureCurlyBraceStartIndex]
					if nestedStructName.startswith(anonymousStructPrefix):	# Anonymous nested structure
						memberDeclarationStatement.append(nestedStructName)	# This is actually the Anonymous struct/union name
						
					# nestedLastValidAttributeEndIndex	- there might be __attribute__ statements after the closing "}" for a nested struct/union
					# We need to know exactly where that ends is because the struct variables declaration (not the member variables) start right after that.
					nestedLastValidAttributeEndIndex = nestedStructureCurlyBraceEndIndex
					while tokenList[nestedLastValidAttributeEndIndex+1] == ATTRIBUTE_STRING :
						nestedLastValidAttributeEndIndex = nestedLastValidAttributeEndIndex+2+matchingBraceDistance(tokenList[nestedLastValidAttributeEndIndex+2:nextSemicolonIndex])

					# For the consistency, add the __attribute__ statements after the "}"
					memberDeclarationStatement.extend(tokenList[nestedStructureCurlyBraceEndIndex+1:nestedLastValidAttributeEndIndex+1])

					# Now, since this is a synthetic statement, we know that all the __attribute__ statements have already been processed.
					# There is no need to include them in the synthetic declaration statement further. Hence, remove them.
					
					while True:
						if ATTRIBUTE_STRING not in memberDeclarationStatement:
							break
						else:
							PRINT ("Before removing __attribute__ statements, memberDeclarationStatement = <",flattenList(memberDeclarationStatement),">")
							begin = memberDeclarationStatement.index(ATTRIBUTE_STRING)
							end = begin+1+matchingBraceDistance(memberDeclarationStatement[begin+1:])
							del memberDeclarationStatement[begin:end+1]
							PRINT ("After removing __attribute__ statements, memberDeclarationStatement = <",flattenList(memberDeclarationStatement),">")
					
					numFakeEntries = len(memberDeclarationStatement) # We have to capture it right here, because i will point to the first token after nestedLastValidAttributeEndIndex
					
					# Remember, there might be __attribute__ statements after the nestedLastValidAttributeEndIndex too. But they will NOT apply to the nested struct.
					# They might apply to the individual variables.
					memberDeclarationStatement.extend(tokenList[nestedLastValidAttributeEndIndex+1:nextSemicolonIndex+1])
					
					
#					numFakeEntries = 2	# Why 2? Possible bug
#					i = nestedStructureCurlyBraceEndIndex + 1
					i = nestedLastValidAttributeEndIndex + 1
					# This is special case where we do not have the struct member declaration.
					if tokenList[i] == ';':	# Only structure definition, no declaration
						usingDummyVariable = True
						del memberDeclarationStatement[-1]	# remove the semicolon 
						dummyVariableCount += 1
						dummyVariableName = dummyVariableNamePrefix + STR(dummyVariableCount)
						memberDeclarationStatement.append(dummyVariableName)
						memberDeclarationStatement.append(';')	# Put back the semicolon
					else:
						usingDummyVariable = False
			else:
				memberDeclarationStatement = tokenList[i:nextSemicolonIndex+1]
				numFakeEntries = 0
			# End nested structure handling
			
			# Find the data type. It might be primitive, or derived
			dataTypeIndex = 0
			while memberDeclarationStatement[dataTypeIndex] in ('auto','register','static','extern', 'const','volatile'):	# What about typedef? Possible bug
				dataTypeIndex += 1
			PRINT ("For dataTypeIndex = ",dataTypeIndex," and i =",i,"memberDeclarationStatement[dataTypeIndex] = ",memberDeclarationStatement[dataTypeIndex])

			# BEGIN The user used some builtin typedef, handle that case
			if (memberDeclarationStatement[dataTypeIndex] not in getDictKeyList(typedefs)) and (memberDeclarationStatement[dataTypeIndex] in getDictKeyList(typedefsBuiltin)):
				list2Parse = typedefsBuiltin[memberDeclarationStatement[dataTypeIndex]] # This will happen only the first time, after that it will become part of typedefs
				parsed5tupleList = parseVariableDeclaration(list2Parse)

				if parsed5tupleList == False:
					errorMessage = "ERROR in parseStructureDefinition() after calling parseVariableDeclaration(list2parse) for list2parse = "+ STR(list2parse)
					errorRoutine(errorMessage)
					return False
				
				PRINT ("Builtin typedef declaration <",list2Parse, "> parsed" )
				for item in parsed5tupleList:
					typeSpecifierEndIndex = item[4]["typeSpecifierEndIndex"]
					variableDeclarationStatement = item[2]
					PRINT ("Main variable name is ",item[0],"of size",item[1],"and it is located at relative index of ",item[3],"inside the variable declaration statement",item[2],", where the base type specifier ends at index =", typeSpecifierEndIndex)
					if usingDummyVariable:
						pass
					elif list2Parse[item[3]]!=item[0]:
						errorMessage = "ERROR in parseStructureDefinition() after parsing user's usage of builtin type"+memberDeclarationStatement[dataTypeIndex] +"- list2Parse[item[3]] = " + STR(list2Parse[item[3]]) + " !=item[0]=" + STR(item[0])
						errorRoutine(errorMessage)
						return False
					else:
						variableNameIndex = item[3]
					
					globalTokenListIndex = LARGE_NEGATIVE_NUMBER
					variableDescriptionExtended = item[4]
					variableDescriptionExtended["globalTokenListIndex"]=globalTokenListIndex 
					variableDescriptionExtended["level"]=level+1 
					variableDescriptionExtended["variableId"] = totalVariableCount
					variableDescriptionExtended["structId"] = structId
					totalVariableCount += 1
					variableDeclarations.append([item[0],item[1],item[2],variableNameIndex,variableDescriptionExtended])
			# END The user used some builtin typedef, handle that case
				

			# If a structure member uses a derived type, we need to replace the memberDeclarationStatement with an expanded one
			memberDeclarationStatementAltered = False	# Starting with a default value
			originalMemberDeclarationStatement = memberDeclarationStatement
			
			if memberDeclarationStatement[dataTypeIndex] in getDictKeyList(typedefs):
				memberDeclarationStatement = convertDerivedTypeDeclarationIntoBaseTypeDeclaration(memberDeclarationStatement,dataTypeIndex)
				memberDeclarationStatementAltered = True
			
			PRINT("originalMemberDeclarationStatement =",originalMemberDeclarationStatement)
			PRINT("memberDeclarationStatement =",memberDeclarationStatement)
				
			PRINT("Going to parse from tokenList[",i,"through",nextSemicolonIndex,"] (both indices included) = ",memberDeclarationStatement )
			if memberDeclarationStatementAltered:
				PRINT("The token count in the above statement would not match, since the original memberDeclarationStatement has been altered")
			
			# Parse the individual member declaration statement
			parsed5tupleList = parseVariableDeclaration(memberDeclarationStatement)
			
			if parsed5tupleList == False:
				PRINT ("ERROR in parseStructureDefinition() for struct after calling parseVariableDeclaration(memberDeclarationStatement) for memberDeclarationStatement =",memberDeclarationStatement )
				return False
			PRINT ("struct/union/regular declaration ",memberDeclarationStatement, "parsed, \nparsed5tupleList =",parsed5tupleList)
			
			existingStructComponentNames = []	# We want to ensure that you cannot re-declare the same variable twice within the same structure
			if structuresAndUnions[suDict[structName][-1]]["components"]:
				for structItem in structuresAndUnions[suDict[structName][-1]]["components"]:
					existingStructComponentNames.append(structItem[0])
				PRINT ("existingStructComponentNames =",existingStructComponentNames)
			
			# The flag variableFoundWithDataOverlapWithStructMembers deals with a special case. Suppose we have the following situation:
			#
			# 	struct A {
			#				int i;
			#				float f;
			#			} var1, var2;
			#
			# In the above code, the struct member variables (i and f) will share the same data space with var1, but not with var2. So, if we do not recognize this,
			# we might allocate THREE data spaces for 1) i and f, 2) var1 and 2) var2, which would be wrong. We should only allocate TWO data spaces, the first of which 
			# would be shared by var1 with i and f, and the second data space would be occupied by var2 solely.
			
			variableFoundWithDataOverlapWithStructMembers = False
				
			for item in parsed5tupleList:
				PRINT (structOrUnionType,structName,"has the following declarations after it" )
				PRINT ("Main variable name is ",item[0],"of size",item[1],"and it is located at relative index of ",item[3],"inside the variable declaration statement",item[2] )
				if item[0] in existingStructComponentNames and not isDynamic:
					PRINT (item[0],"already appears in existingStructComponentNames =",existingStructComponentNames)
					errorMessage = "ERROR in parseStructureDefinition(): component "+item[0]+" has already been declared (cannot be re-declared within the same structure/union)"
					errorRoutine(errorMessage)
					return False
				# Each member of the list follows exactly the same format as the parsed5tupleList, with one key addition - the 6th item.
				# This 6th member now represents the absolute index (within the tokenList) of the variable name.
				
				if memberDeclarationStatementAltered == False:
					if not usingDummyVariable and (not item[0].startswith(dummyUnnamedBitfieldNamePrefix)) and tokenList[i+item[3]-numFakeEntries]!=item[0]:
						errorMessage = "ERROR in parseStructureDefinition() - for i= "+STR(i)+" tokenList[i+item[3]-numFakeEntries] = tokenList["+STR(i)+"+"+item[3]+"-"+STR(numFakeEntries)+"] ="+tokenList[i+item[3]-numFakeEntries]+"!=item[0]="+item[0]
						errorRoutine(errorMessage)
						return False
					else:
						PRINT ("In parseStructureDefinition(), - for i=",i,"tokenList[i+item[3]-numFakeEntries] = tokenList[",i,"+",item[3],"-",numFakeEntries,"] =",tokenList[i+item[3]-numFakeEntries],"matches item[0]=",item[0] )
						globalTokenListIndex = i+item[3]-numFakeEntries
						variableNameIndex = item[3]
						
				elif memberDeclarationStatementAltered == True: 	# Derived type
					PRINT ("i =",i,"dataTypeIndex =",dataTypeIndex,"tokenList[dataTypeIndex] =",tokenList[dataTypeIndex])
					variableDeclarationStartIndex = i	# Since we do not allow typedef within struct member definition, the very first term should be the derived type
#					variableDeclarationStartIndex = dataTypeIndex	# Since we do not allow typedef within struct member definition, the very first term should be the derived type
					typeSpecifierEndIndex = item[4]["typeSpecifierEndIndex"]
					variableDeclarationStatement = item[2]
					PRINT ("Main variable name is ",item[0],"of size",item[1],"and it is located at relative index of ",item[3],"inside the variable declaration statement",item[2],", where the base type specifier ends at index =", )
#					if tokenList[i] in getDictKeyList(typedefs):			# MannaManna
					if tokenList[i+dataTypeIndex] in getDictKeyList(typedefs):
						PRINT ("We modified the declaration statement, so we know that position index of the declared variable", item[0],"would not match (hence not checking it)" )
						if item[0].startswith(dummyUnnamedBitfieldNamePrefix):
							variableNameIndex = originalMemberDeclarationStatement.index(':')
						else:
							variableNameIndex = originalMemberDeclarationStatement.index(item[0])
					elif usingDummyVariable:
						# Since the dummyvariable will be like struct nestedStructName dummyVariable, its position # should be always 2 (remember, typedefs are not allowed)
						# TO-DO - accommodate the case where other cases like volatile / static / extern etc. qualifiers would precede the nested struct definition.
						# Int that case, the variableNameIndex might be more than 2.
						variableNameIndex = 2
					elif (not item[0].startswith(dummyUnnamedBitfieldNamePrefix)) and tokenList[variableDeclarationStartIndex+item[3]]!=item[0]:
						errorMessage = "ERROR in parseStructureDefinition() - for variableDeclarationStartIndex = "+ STR(variableDeclarationStartIndex) + " tokenList[variableDeclarationStartIndex+item[3]] = " + STR(tokenList[variableDeclarationStartIndex+item[3]]) + " !=item[0]=" + STR(item[0])
						errorRoutine(errorMessage)
						return False
					else:
						variableNameIndex = item[3]
					globalTokenListIndex = variableDeclarationStartIndex+variableNameIndex
				
				variableId = totalVariableCount
				
				# Here is the final place where the individual structure memebers gets added to the variableDeclarations and structuresAndUnions
				variableDescriptionExtended = item[4]
				variableDescriptionExtended["globalTokenListIndex"]=globalTokenListIndex
				variableDescriptionExtended["parentVariableType"]=[structOrUnionType,structName]
#				variableDescriptionExtended["parentVariableName"]=structName
				variableDescriptionExtended["level"]=level+1
				variableDescriptionExtended["variableId"] = variableId
				variableDescriptionExtended["structId"] = structId
				
				# If any of the struct members is Dynamic, that automatically makes the overall struct also Dynamic
				if "isDynamic" in getDictKeyList(variableDescriptionExtended) and variableDescriptionExtended["isDynamic"]:
					PRINT("Making struct/union",structName,"dynamic due to its dynamic member",item[0])
					isDynamic = True
					structuresAndUnions[suDict[structName][-1]]["isDynamic"] = True
				else:
					PRINT("Struct/union",structName,"member",item[0]," is NOT dynmaic")
				
				if not variableFoundWithDataOverlapWithStructMembers and structDefinedHere and variableDescriptionExtended["datatype"] == nestedStructName:
					variableDescriptionExtended["DataOverlapWithStructMembers"] = True 
					variableFoundWithDataOverlapWithStructMembers = True	# To indicate that we already found a variable whole data overlaps with the struct members.
				else:
					variableDescriptionExtended["DataOverlapWithStructMembers"] = False
				
				PRINT("Adding struct member",item[0],"structMemberCount =",structMemberCount)
#				variableDeclarations.append([item[0],item[1],item[2],variableNameIndex,variableDescriptionExtended])
				variableDeclarations.append(item)
				
				structuresAndUnions[suDict[structName][-1]]["components"].append(item)
				structMemberCount += 1	# For noting the runtime directives
				runtimeStatementsRelativeToComponentIndex.append(structMemberCount)
				totalVariableCount += 1

			i = nextSemicolonIndex + 1
		# END-WHILE Parse all the individual members of this struct/union
	
	# Sanity check for runtimeStatementsRelativeToComponentIndex
	PRINT("Sanity check for runtimeStatementsRelativeToComponentIndex =",runtimeStatementsRelativeToComponentIndex)
	
	temp1 = []	# Should contain numbers 0 ... len(structuresAndUnions[structName]["components"])-1
	temp2 = []	# Should contain #RUNTIME statements
	temp3 = []	# Should be empty

	for item in runtimeStatementsRelativeToComponentIndex:
		if checkIfIntegral(item):
				temp1.append(item)
		elif isinstance(item, list):
			if len(item) <2 or item[0] != preProcessorSymbol or item[1] not in runtimeDirectives:
				errorMessage = "ERROR in parseStructureDefinition() - definition for structName <"+structName+"> contains illegal runtime declarations"
				errorRoutine(errorMessage)
				return False
			else:
				temp2.append(item)
		else:
			temp3.append(item)
		
	if temp3:
		errorMessage = "ERROR in parseStructureDefinition() - definition for structName <"+structName+"> contains illegal statements that is neither a runtime declarations nor a struct component index"
		errorRoutine(errorMessage)
		return False

	if temp1 != [x for x in range(len(structuresAndUnions[suDict[structName][-1]]["components"]))]:
		errorMessage = "ERROR in parseStructureDefinition() - runtimeStatementsRelativeToComponentIndex for structName <"+structName+"> contains illegal struct component index numbers: "+ STR(temp1)
		errorRoutine(errorMessage)
		return False

	# Namespace check for struct.
	# In non-Dynamic structs, it is easy to verify that all struct member names are different. However, with Dynamic structs, it is not so easy.
	# Here, it only catches the declarations that are GUARANTEED to fail. However, there could be cases where it is impossile to know beforehand if it will fail or not.
	#
	#     Can catch while going first to last												Can catch while going last to first
	#    ________________________________________________									 ________________________________________________
	#	| struct S { char c;							|									| struct S { char c;							|
	#	|			float f;		//unconditional		|									|												|
	#	|			# if c==1	        				|									|			# if c==1							|
	#	|				int f;		//conditional		|									|				int f;		//conditional		|
	#	|			# endif		  						|									|			# endif								|
	#	|												|									|			float f;		//unconditional		|
	#	|__________};___________________________________|									|___________};__________________________________|
	#
	runtimeStatementsRelativeToComponentName = []
	for item in runtimeStatementsRelativeToComponentIndex:
		if checkIfIntegral(item):
			N = item
			structMemberName = structuresAndUnions[suDict[structName][-1]]["components"][N][0]
			runtimeStatementsRelativeToComponentName.append(structMemberName)
		else:	# A Runtime statement
			runtimeStatementsRelativeToComponentName.append(item[1])	# Only keep the 'if'/'else'/'elif'/'endif' part
		PRINT(runtimeStatementsRelativeToComponentName[-1])

	#First check going from first to last
	namespaceStack = []
	for N in range(len(runtimeStatementsRelativeToComponentName)):
		item = runtimeStatementsRelativeToComponentName[N]
		if item in ('elif','else'):	# Go back and delete all the variables up to the if
			while True:
				if namespaceStack[-1] == 'if':
					break
				else:
					del namespaceStack[-1]
		elif item == 'endif':	# Go back and delete all the variables up to the if
			while True:
				if namespaceStack[-1] == 'if':
					del namespaceStack[-1]
					break
				else:
					del namespaceStack[-1]
		if item != 'endif':
			if item not in ('if','elif','else') and item in namespaceStack:
				errorMessage = "Error in parseStructureDefinition(): For dynamic "+structOrUnionType+" "+structName+", component "+item+" has already been declared (cannot be re-declared within the same "+structOrUnionType+")"
				errorRoutine(errorMessage)
				return False
			else:
				namespaceStack.append(item)
		PRINT("After processing item #",N,", namespaceStack =",namespaceStack)

	#Next check going from last to first
	namespaceStack = []
	for N in reversed(range(len(runtimeStatementsRelativeToComponentName))):
		item = runtimeStatementsRelativeToComponentName[N]
		if item in ('else', 'elif'):	# Go back and delete all the variables up to the endif
			while True:
				if namespaceStack[-1] == 'endif':
					break
				else:
					del namespaceStack[-1]
		elif item == 'if':	# Go back and delete all the variables up to the endif
			while True:
				if namespaceStack[-1] == 'endif':
					del namespaceStack[-1]
					break
				else:
					del namespaceStack[-1]
		if item != 'if':
			if item not in ('endif','else','elif') and item in namespaceStack:
				errorMessage = "ERROR in parseStructureDefinition(): For dynamic "+structOrUnionType+" "+structName+", component "+item+" has already been declared (cannot be re-declared within the same "+structOrUnionType+")"
				errorRoutine(errorMessage)
				return False
			else:
				namespaceStack.append(item)
		PRINT("After processing item #",N,", namespaceStack =",namespaceStack)

		# Check if the RUNTIME statement interleaving is correct (needed for Dynamic structs only)
		if isDynamic: 
			# Since this checkPreprocessingDirectivesInterleaving() routine expects an array of simple lines (not lists), we first convert the 
			# existing runtimeStatementsRelativeToComponentIndex to simple lines
			runtimeLines = [list2plaintext(x) if isinstance(x,list) else STR(x) for x in runtimeStatementsRelativeToComponentIndex]
			PRINT("The stringified runtimeStatementsRelativeToComponentIndex list is", runtimeLines)
			PRINT("From parseStructureDefinition(), calling checkPreprocessingDirectivesInterleaving(runtimeLines)")
			checkPreprocessingDirectivesInterleavingResult = checkPreprocessingDirectivesInterleaving(runtimeLines)
			if checkPreprocessingDirectivesInterleavingResult == False:
				errorMessage = "ERROR in parseStructureDefinition() after calling checkPreprocessingDirectivesInterleaving() for the whole thing"
				errorRoutine(errorMessage)
				return False


	structuresAndUnions[suDict[structName][-1]]["runtimeStatementsRelativeToComponentIndex"] = runtimeStatementsRelativeToComponentIndex
	
	PRINT("\n\nstructuresAndUnions[suDict[structName][-1]] =\n",structuresAndUnions[suDict[structName][-1]])
	return structName
'''	
g1 = [{1:2},{3:4},{5:6}]
def test1():
	x = g1[2]
	OUTPUT("x=",x,"g1=",g1)
	x[7]=8
	OUTPUT("x=",x,"g1=",g1)
test1()
g3 = [1,2,3,4]
g4=g3[:]
del g4[0]
g4[2]=5
#del g4[0]
OUTPUT("g3=",g3,"g4=",g4)

sys.exit()


newList=[]
oldList = [1,2,3]
backup = oldList
OUTPUT("oldList = ",oldList, "newList = ",newList, ", backup = ", backup)
#del oldList[1]
oldList = oldList[:1]+oldList[2:]
newList = oldList + [4]
oldList = backup
OUTPUT("oldList = ",oldList, "newList = ",newList, ", backup = ", backup)
newList[2]=5
OUTPUT("oldList = ",oldList, "newList = ",newList, ", backup = ", backup)
oldList = backup
OUTPUT("oldList = ",oldList, "newList = ",newList, ", backup = ", backup)
x=0
List = []
l1 = []
while x<10:
	l1 = [x]
	List.append(l1)
	x+=1
OUTPUT("List =",List)
sys.exit()
'''
################################################################################################################################################
# calculateStructureLength() does the following:
# 1) For every struct (Dynamic or not), during Interpret it updates the Global structuresAndUnions with the attributes (like alignments), and for that it considers ALL members.
# 2) For regular (non-Dynamic) structs, for every struct member it updates the offsetWithinStruct/bitOffsetWithinStruct/bitFieldInfo, and updates struct-level size
# 3) For the Dynamic structs, if the offset is supplied (along with a local copy of unraveledSupplied, of course), it does the following:
#	 - for every struct member it updates the offsetWithinStruct/bitOffsetWithinStruct/bitFieldInfo, and adds a record to the unraveledSupplied (which is finally returned)
#
################################################################################################################################################
# The reason we separate calculateStructureLength() from parseStructureDefinition() is because of #RUNTIME statements.
# Because, now the same structure can have different members, and yield different lengths based on the #RUNTIME statements.
# Heck, even if there are no runtime statements, but we have a struct member variable that is an array with Dynamic dimension, 
# it makes the overall struct Dynamic since all the member offsets (and the overall struct length) will change.
# This routine gets called both during the Interpret stage ONCE (from parseCodeSnippet) and during Map stage MULTIPLE times, depending on the need.
# We figure out which stage it is being called by simply checking the parameter offset, which is defaulted to LARGE_NEGATIVE_NUMBER.
# When it will be called during the Map stage, we expect that it will have some nonnegative offset.
# During the Interpret stage, if it is a Dynamic struct, we wil not be able to evaluate the runtime variable values (obviously).
# Therefore, during the Interpret stage, we must allow Dynamic structs speculatively. Maximum we can do is to check if the runtime variable is 
# indeed a proper qualified name. But doing it properly would require to consider only the variables which have appeared BEFORE that runtime statement
# in the lexical order, which is not easy. Something to be implemented later.
################################################################################################################################################
# For dynamic structures, the overall alignment of the struct must consider ALL the members of the struct, irrespective of the embedded #RUNTIME statements.
# Why? To get out of an "impossible" situation where no solution is possible. See below.
#
# Suppose the struct S starts from a (4n+3)th byte (n is an integer), and that byte's value is zero, and the next byte's value is 1. Suupose the definition of the struct is:
#
#	____________________________
# 	|	struct S {				|		Now, if we start mapping the struct right from (4n+3)th byte, then c will have the value of 0.
#	|				char c;		|		Which means, the int i will also be part of the struct. Which means, the overall alignment of the struct
#	|	# if (c==0)				|		will be 4, which means it cannot start on the (4n+3)rd byte - it must start from the (4n+4)th byte, which is aligned to 4.
#	|				int i;		|
#	|	# endif					|		But when we do that, c is now mapped to the (4n+4)th byte, which contains the value of 1. So, c is 1, which means the
#	|			} ;				|		#RUNTIME statements will not get satisfied, and int i will NOT be part of the struct, which means the overall
#	|___________________________|		struct-level alignment will be 1 byte only, which means it could have started from (4n+3)rd byte only.
#
# It is theoretically impossible to design a scheme that will always guarantee proper overall alignment for a dynamic struct.

# Note that this calculateStructureLength() routine and addVariableToUnraveled() routine call each other, especially for Dynamic structures.
def calculateStructureLength(structName, level=-1, structVariableId=-1, prefix="", offset=LARGE_NEGATIVE_NUMBER, unraveledSupplied=[], ancestry=[], arrayAlreadyUnraveled=False, speculativeArrayDimensions=[[1]]):
#	PRINT=OUTPUT
	global structuresAndUnions	# Needed during Interpret stage
	global executionStateStack	# Needed during Map stage
	initResult = None
	# The prefix already contains the variable name (or type structName), and the ancestry already contains the structVariableId of THAT struct variable
	# These two are the only indication for which variable this routine is being called.
	executionStage = "Interpret" if lastActionWasInterpret else "Map" if lastActionWasMap  else "Undefined Execution Stage"
	PRINT ("\n\n\n","==="*30,"\nInside calculateStructureLength(",structName,") during",executionStage, "\n","==="*30,"\n" )
	if executionStage == "Map":
		PRINT("level=",level, ", structVariableId=",structVariableId,", prefix=",prefix, ", offset=",offset, ", ancestry=",STR(ancestry), ", arrayAlreadyUnraveled=",arrayAlreadyUnraveled,"\nunraveledSupplied =")
		for row in unraveledSupplied:
			PRINT(row)
	if structName not in getDictKeyList(suDict):
		errorMessage = "ERROR in calculateStructureLength() - structName <"+structName+"> not found in structuresAndUnions"
		errorRoutine(errorMessage)
		return False
	
	isDynamic = True if "isDynamic" in getDictKeyList(structuresAndUnions[suDict[structName][-1]]) and structuresAndUnions[suDict[structName][-1]]["isDynamic"] else False
	if not lastActionWasInterpret and not lastActionWasMap:
		errorMessage = "ERROR in calculateStructureLength() for structName <"+structName+"> - somehow neither lastActionWasInterpret nor lastActionWasMap is true"
		errorRoutine(errorMessage)
		return False
	elif executionStage == "Interpret" and offset!=LARGE_NEGATIVE_NUMBER:
		errorMessage = "ERROR in calculateStructureLength() for structName <"+structName+"> - when this gets called during Interpret stage, we expect the supplied offset value ("+STR(offset)+") to be NOT populated"
		errorRoutine(errorMessage)
		return False
	elif executionStage == "Map" and offset==LARGE_NEGATIVE_NUMBER:
		errorMessage = "ERROR in calculateStructureLength() for structName <"+structName+"> - when this gets called during Map stage, we expect the supplied offset value to be populated"
		errorRoutine(errorMessage)
		return False
	# From this point on, if we want to see if this routine is called during the Interpret stage or the Map stage,
	# we can either check if executionStage == "Map" or check if offset>LARGE_NEGATIVE_NUMBER:

	# Currently, this routine is NOT called during the Map stage for regular (non-Dynamic) structs (we might change this later for uniformity).
	# At this moment, when addVariableToUnraveled() encounters a regular (non-Dynamic) struct, it itself goes into the struct components and 
	# adds the individual records to unraveled one by one. However, when it encounters a Dynamic struct, it calls calculateStructureLength()
	# to handle it (updating the unraveled for its struct members).
	if executionStage == "Map" and not isDynamic:
		errorMessage = "ERROR in calculateStructureLength() for structName <"+structName+"> - this function should not get invoked for Regular (non-Dynamic) structs during Map stage"
		errorRoutine(errorMessage)
		return False
		
	if executionStage == "Map":	# Recall that this routine does NOT get called for regular structs during map
		structDetails = deepCopy(structuresAndUnions[suDict[structName][-1]])	# We do not want to update the original entry in structuresAndUnions for dynamic structs
	elif executionStage == "Interpret":
		structDetails = structuresAndUnions[suDict[structName][-1]]	# During Interpret stage, this will get updated with stuff like overall struct size, alignments, offsets etc.
	else:
		EXIT("ERROR in calculateStructureLength() for structName <"+structName+"> - illegal value of executionStage ("+executionStage+")")
		
	# Fetch the struct-level attributes. This will get updated with EVERY member's atrributes, whether they are included during runtime or not
#	if "attributes" in getDictKeyList(structDetails):
#		attributes = structDetails["attributes"]
#	else:
#		attributes = {}
	
	# Each row of runtimeStatementsRelativeToComponentIndex array is either the full #RUNTIME statements, or the component index.
	# (Note that we do NOT include the declaration statement itself, just the component #).
	# So, unless we actually have #RUNTIME statements inside the structure definition, we would not even have a runtimeStatementsRelativeToComponentIndex
	# stored inside the structDetails, since there is pretty much nothing to store.
	#
	# Similarly, runtimeStatementsRelativeToComponentIndexStatus is initially all 'execute', which basically means "execute this statement".
	# Once you run a specific statement, you update its status to either True/False if it is a #RUNTIME statement, or to just "done" for regular declarations.
	# However, depending on the outcome of the #RUNTIME statement, we may update the status to 'do not run' for future statements (for both #RUNTIME and regular statements).
	# So, we only execute a statement if its status says 'execute'. If it says 'do not run', then we omit that statement.
	#
	# So, if the struct declaration is such that
	#
	#											runtimeStatementsRelativeToComponentIndex		runtimeStatementsRelativeToComponentIndexStatus		executedStructMemberIndex
	#     struct S {							_________________________						________________ <==								___________
	#				#  if (a>1)					|  # if (a>1)			|						|	'execute'	|									|  0
	#				int i;						|  0					|						|	'execute'	|
	#				#  else						|  # else				|						|	'execute'	|
	#				float f1, f2;				|  1					|						|	'execute'	|
	#				#  endif					|  2					|						|	'execute'	|
	#				} sA;						|  #  endif				|						|	'execute'	|
	#											|_______________________|						|_______________|
	#
	# The last array (executedStructMemberIndex) is a list of which all struct member indexes actually got run. Suppose a struct has 5 members where the first, third, 
	# and fifth members got actually executed during runtime. In that case, executedMemberIndex = [0,2,4].
	executedStructMemberIndex = []	# Which all struct member indexes actaully got executed
	
	
	if isDynamic: 
		PRINT("Dynamic struct",structName)
		if "runtimeStatementsRelativeToComponentIndex" in getDictKeyList(structDetails):
			PRINT("Fetching the runtimeStatementsRelativeToComponentIndex from the structuresAndUnions")
			runtimeStatementsRelativeToComponentIndex = structDetails["runtimeStatementsRelativeToComponentIndex"]
			PRINT("The runtimeStatementsRelativeToComponentIndex is",runtimeStatementsRelativeToComponentIndex)
	else:
		PRINT(structName,"is NOT a dynamic struct")
		PRINT("Creating the runtimeStatementsRelativeToComponentIndex locally")
		# No #RUNTIME statements - just create it locally.
		runtimeStatementsRelativeToComponentIndex = [x for x in range(len(structDetails["components"]))]
	# Initially, the default value of each statement is 'execute'.
	runtimeStatementsRelativeToComponentIndexStatus = ['execute' for x in range(len(runtimeStatementsRelativeToComponentIndex))]
	
	###############################################################################################################################################################
	#
	#           P A C K E D        and    A L I G N E D     ( via __attribute__ )
	#
	###############################################################################################################################################################
	#
	#
	#  These two directives can be added at the individual member level of a structure, or can be just applied at the struct level (where it will apply to all the members)
	#
	#  Basically, what packed directive tells is that - ignore the natual alignment of the datatype (for example 2 bytes for a short, 4 bytes for an int) and 
	#  just start "packing" the variable exactly after the previous variable ends (do not allow the compiler to add any padding in between).
	#
	#  The aligned(N) directive, where N must be 1/2/4/8/16 (basically a proper power of 2), on the other hand, ensures two things. 
	#  1. The variable must be start from the natural boundary of the mentioned aligned(N).
	#  2. It must take at least N bytes of space (paddings may need to be added). It does not care if the next member starts packing right on top of the padding,
	#     as long it does not reduce the space allocated by the aligned() statement.
	#  3. If the N in aligned(N) is smaller than the native size of the member, the native size overrides N. E.g., if you have short s __attribute__ ((aligned(1)));
	#     then the aligned(1) is ignored. Only way to make the short align to a 1-byte boudary is by using the __attribute__((packed)) or #pragma pack(1)
	#
	#  If there are conflicting directives, e.g. __attribute__((packed, aligned)), then aligned wins. It does not matter if the packed is at the member-level or 
	#  at the struct-level, it will not be able to override aligned. However, #pragma pack can override aligned by reducing it (it cannot increase).
	#
	#  The __attribute_(()) can be mentioned at the beginning of the statement (before even struct), right after the struct but before the struct name (if named),
	#  or right after the ending curly brace.
	#
	# Declaring it at the struct level:
	#
	#  Allowed:   __attribute__((packed)) struct                         S                        { char c; short s, int i;}                        Sa;
	#  Allowed:                           struct __attribute__((packed)) S                        { char c; short s, int i;}                        Sa;
	#  Not allowed:                       struct                         S __attribute__((packed)){ char c; short s, int i;}                        Sa;
	#  Allowed:                           struct                         S                        { char c; short s, int i;} __attribute__((packed))Sa;
	#  Ignored:                           struct                         S                        { char c; short s, int i;}                        Sa __attribute__((packed));
	#
	# Declaring it at the struct member level:
	#
	#  Allowed:   __attribute__((packed)) int                            i1                        ,                        i2;	<== "packed" applies to both i1 and i2
	#  Allowed:                           int   __attribute__((packed))  i1                        ,                        i2;	<== "packed" applies to both i1 and i2
	#  Allowed:                           int                            i1 __attribute__((packed)),                        i2;	<== "packed" applies to only i1 but not i2
	#  Allowed:                           int                            i1                        , __attribute__((packed))i2;	<== "packed" applies to only i2 but not i1
	#
	#  When you have multiple __attibute__ parameters, you can mention them in 3 ways.
	#    1. Comma-separated. Like __attribute__((packed, aligned))
	#    2. Space-separated. Like __attribute__((packed  aligned))
	#    3. Separate entry for each parameter. Like struct __attribute__((packed)) {int a;} __attribute__((aligned)). But each entry can only be in one of the allowed places.
	#
	#   Also, to ensure that it accidentally does not collide with any macro names, instead of "packed", one can also use "__packed__" (and similarly for other attributes).
	
	# An __attribute__((packed)) statment simply brings the alignment to 1.
	# An __attribute__((align(m))) statement causes a member variable to align to a number that LARGER than its current alignment. 
	# Suppose the natural size (and thus natural alignment) of a struct member is s, and we have an aligned(m) statement.
	#
	# if s < m, then irrespective of whether this is any packed statement, the alignment is increased to m. 
	#    Because even when the packed statement brings the alignment down to 1, the aligned(m) then increases it to m.
	#    So, both the size and alignment for this member increases, leading to traling padding (which may be reused by next member), and possibly leading padding.
	# if m < s, then it depends on whether this is any packed statement (at either the member-level or the struct-level, either will do).
	#  - if there is a packed statement, then the alignment is first reduced to 1 from s. Then align(m) increases it to m.
	#    So, overall the size remains the same as s, but the alignment gets reduced to m. This may lead to some leading pads (if m >1), but no trailing pads.
	#  - if there is NO packed statement, then alignment remains at s, and since an align(m) can only "increase-to-m (never reduce)", 
	#    the align(m) is effectively ignored, and the resulting member-level alignment as well as size is s. This may lead to leading pads (if s > 1).
	#
	# #pragma pack(n) is a Microsoft directive that was back-ported into gcc. It simply ensures that maximum alignment of each struct member is n.
	# It does not say anything about packing. So, do NOT take it as an equivalent of putting a __attribute__((packed, aligned(m))) to every struct member.
	# So, #pragma pack(n) only reduces the alignment to n. It never increases it to n.
	#
	# So, the rule of the mix of #pragma pack(n), __attribute__((packed)) and , __attribute__(aligned(m))) is that:
	# First calculate the effective size and alignment just considering the natural size, packed and aligned(m)
	# If the resulting alignment is > n, reduce it to n.
	# If the resulting size is > n, reduce it to n. However, if n < s (the natural size), then effective size is s.
	
	#
	# Here's a summary of the differences:
	#
	#  - #pragma pack applies to every structure definition placed after where it is inserted (or until another #pragma pack overrides it), 
	#    while GCC __attribute__s are defined locally to a type;
	#  - #pragma pack is less fine-grained than attributes: it cannot be applied to only a few members of a struct.  
	#     In practice, however, this is rarely an issue, since you'll rarely need different alignment and packing settings for the members of a same struct.
	#
	# See https://docs.microsoft.com/en-us/cpp/preprocessor/pragma-directives-and-the-pragma-keyword?view=vs-2019 
	# See https://docs.microsoft.com/en-us/cpp/preprocessor/pack?view=vs-2019
	#
	# As per https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.2.0/com.ibm.zos.v2r2.cbclx01/pragma_pack.htm
	# 
	#  The #pragma pack directive modifies the current alignment rule for only the members of structures whose declarations follow the directive. 
	#  It does not affect the alignment of the structure directly, but by affecting the alignment of the members of the structure, 
	#  it may affect the alignment of the overall structure.
	#
	#  The #pragma pack directive cannot increase the alignment of a member, but rather can decrease the alignment. For example, for a member with data type of short, 
	#  a #pragma pack(1) directive would cause that member to be packed in the structure on a 1-byte boundary, while a #pragma pack(4) directive would have no effect.
	#
	# As per https://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Structure_002dPacking-Pragmas.html
	# 
	# For compatibility with Microsoft Windows compilers, GCC supports a set of #pragma directives which change the maximum alignment of members of structures 
	# (other than zero-width bitfields), unions, and classes subsequently defined. The n value below always is required to be a small power of two and 
	# specifies the new alignment in bytes.

	#  #pragma pack(n) 			simply sets the new alignment. Must be 1, 2, 4, or 8
	#  #pragma pack() 			sets the alignment to the one that was in effect when compilation started (see also command line option -fpack-struct[=<n>] see Code Gen Options).
	#							So, here this is equivalent to #pragma pack(ALIGNED_DEFAULT_VALUE), or setting pragmaPackCurrentValue = ALIGNED_DEFAULT_VALUE
	#  #pragma pack(push[,n]) 	pushes the current alignment setting on an internal stack and then optionally sets the new alignment.
	#  #pragma pack(pop) 		restores the alignment setting to the one saved at the top of the internal stack (and removes that stack entry). 
	#
	# Note that #pragma pack([n]) does not influence this internal stack; thus it is possible to have #pragma pack(push) followed by multiple #pragma pack(n) instances and 
	# finalized by a single #pragma pack(pop). 	
	#
	# MOST IMPORTANT: The alignment of a member is on a boundary that's either a multiple of n, or a multiple of the size of the member, whichever is smaller.
	#
	#
	#  Some examples below.
	#   _____________________________________________________________________________________________________________________________________________________
	#  |  struct A {                                     | sizeof(A) = 6, because the compiler will add a 1-byte padding after c1. It will also add a 1-byte
	#  |        char c1;                                 | padding at the end of the struct after c2.
	#  |        short s;                                 |
	#  |        char c2;                                 |
	#  |  };                                             |
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  |  struct __attribute__((packed)) B {             | sizeof(B) = 4, because now the compiler will pack all the members as tightly as possible.
	#  |        char c1;                                 | If c2 were a short, its size would have been 5.
	#  |        short s;                                 |
	#  |        char c2;                                 |
	#  |  };                                             |
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct C {                                     | sizeof(C) = 4, because now the compiler will pack only the member s as tightly as possible.
	#  |        char c1;                                 | And for char variables, the compiler does not need (and therefore ignores) any 
	#  |        short s __attribute__((packed));         | __attribute__((packed)), since a char can start from any byte boundary.
	#  |        char c2;                                 | However, if instead of "char c2;" we had a "char c2[2];", in that case the sizeof(C) would 
	#  |  };                                             | be 6 since the compiler would align it to a 2-byte-boundary.
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct D {                                     | sizeof(D) = 18, because now the compiler will pack only the member i[4] as tightly as possible.
	#  |        char c1;                                 | 
	#  |        int i[4] __attribute__((packed));        | 
	#  |        char c2;                                 |  
	#  |  };                                             | 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct E  {                                    | sizeof(E) = 6, because now the compiler will pad 1 bytes at the end.
	#  |        short s[2];                              | Observe that the compiler is decide to align the final struct boundary at a 2-byte boundary,
	#  |        char c;                                  | because that is the largest alignment among all the struct members. Once again, it is not 
	#  |  };                                             | the size of the WHOLE array, it is the size of the "base" member of the array.
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct F  {                                    | sizeof(F) = 8, because now the compiler will pad 3 bytes at the end. Compare it with the above.
	#  |        int i;                                   | Both "short s[2];" and "int i;" take exactly 4 bytes, yet for the former the compiler is 
	#  |        char c;                                  | adhering to a 2-byte-boudary while for the latter it is adhering to a 4-byte boudary,
	#  |  };                                             | because that is now the largest alignment among all the struct members.
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct __attribute__((packed)) G {             | sizeof(G) = 5, because the packed will now cause the compiler to not add the trailing pads.
	#  |        int i;                                   | 
	#  |        char c;                                  |  
	#  |  };                                             | 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct __attribute__((aligned(2))) H {         | sizeof(H) = 2, because unlike the __attribute__((packed)), when you place the __attribute__((aligned))
	#  |        char c1;                                 | at the struct definition level (NOT at the struct member level), the aligned attribute does NOT apply
	#  |        char c2;                                 | to each individual struct member. Because if it did, we would get sizeof(H) = 4.
	#  |  };                                             | Instead, it will apply to the "overall" structure length.
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct __attribute__((aligned(2))) I {         | sizeof(I) = 4, because unlike the __attribute__((packed)), when you place the __attribute__((aligned))
	#  |        char c1;                                 | at the struct definition level (NOT at the struct member level), the aligned attribute does NOT apply
	#  |        char c2;                                 | to each individual struct member. Because if it did, we would get sizeof(H) = 4.
	#  |        char c3;                                 | Instead, it will apply to the "overall" structure length. So, out of the 4 byets, the last byte is pad.
	#  |  };                                             |
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct  J {                                    | sizeof(J) = 4, because even though the c2 will start (and end) at a 2-byte boundary (2nd byte is now pad), 
	#  |        char c1;    // 1-byte padding after c1   | it does not "prohibit" the next struct member (c3) to occupy/overlay the 1-byte padding after c2.
	#  |        char c2 __attribute__((aligned(2)));     | Remember that aligned(2) only ensures that the variable will start at a boundary that will
	#  |        char c3;  // c3 overlaps c2's padding    | align to a 2-byte boudary, and wil occupy "at least" 2 bytes. So, you can technically put an
	#  |  };                                             | __attribute__((aligned(2))) against an integer, it will not error out.
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct  K {                                    | sizeof(K) = 6, not 5, inspite of the packed attributed being applied to the whole struct (and thus all members).
	#  |        char c1; //1-byte paddings after c1 & c2 | Out of these 6 bytes, the second and the last bytes are the padding (C3 occupies fourth and fifth bytes).
	#  |        char c2 __attribute__((aligned(2)));     | This also illustrates one vital property of aligned - the moment you apply to any of the struct member
	#  |        char c3[2];                              | variables, it also applies to the overall struct itself.
	#  |  }__attribute__((packed));                      | 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct L  {                                    | sizeof(L) = 4, not 8. Because the aligned statement applied on the whole array size, not the individual
	#  |        short s[2] __attribute__((aligned(4)));  | array element. So, two shorts fit in a 4-byte nicely.
	#  |  };                                             | 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct M  {                                    | sizeof(M) = 12. Because the aligned statement works on the whole array size, not the individual
	#  |        char c1; //3 bytes of padding after this | array element. So, there is a 3-byte padding before s[3] since it can only start at a 4-byte alignment, 
	#  |        short s[3] __attribute__((aligned(4)));  | but after the 3 shorts occupy 6 bytes, we still have 2 bytes of trailing padding left which are
	#  |        char c2[2]; //fits into the padding b4   | nicely utilized by the char c2[2];
	#  |  };                                             | 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct A1{                                     | sizeof(A1) = 12, because now the compiler will pack int i2 from its natural alignement (4),
	#  |     int i1;                                     | So there will be a pad of 2 bytes before i2.
	#  |     short s;                                    |
	#  |     int i2;                                     |  
	#  |  };                                             | 
	#  |______________|__________________________________|_____________________________________________________________________________________________________
	#  |   struct A2 {                                   | sizeof(A2) = 12, because the compiler will still pack int i1 from its natural alignement (4),
	#  |         short s1;                               | So there will be a pad of 2 bytes before i1. 
	#  |         int i1 __attribute__((aligned(2)));     |
	#  |         short s2;                               | Observe that by attempting to reduce the alignment of i1 will not work since the intended alignement 
	#  |    };                                           | of 2 bytes is smaller than the natural size of the i1. So, in absense of a packed statement, 
	#  |                                                 | the aligned attribute statement will be ignored. Align only increases, never decreases.
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct  __attribute__((packed)) A3{            | sizeof(A1) = 10, because now the compiler will pack int i2 from the 7th byte,
	#  |     int i1;                                     | So there will be no pads. Once we use the __attribute__((packed)) at the struct-level,
	#  |     short s;                                    | it will apply to each of the member variables, making each memeber's alignment to 1.
	#  |     int i2;                                     | Thus, the overall struct-level alignment = max (1,1,1) = 1. 
	#  |  };                                             | 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct A4 {                                    | sizeof(A1) = 12, because now even though the compiler will pack int i2 from the 7th byte,
	#  |     int i1;                                     | we are using the __attribute__((packed)) at the member-level, not at the struct-level.
	#  |     short s;                                    | Therefore, the the overall struct-level alignment is still the maximum among all the members,
	#  |     int i2 __attribute__((packed));             |  = max(4,2,1) = 4. 
	#  |  };                                             | Thus, the overall struct size must be a multiple of 4, cause 2 bytes padding at end.
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |                                                 | sizeof(B) = 8, because the compiler will calculate the struct-level alignment to be still the 
	#  |  struct B {                                     | maximum of all individual member-level alignments. The __attribute__((aligned(2))) will be ignored,
	#  |        int i __attribute__((aligned(2)));       | because in absense of a member-level or struct-level packed statement, you cannot apply the 
	#  |        short s;                                 | alignment if it were SMALLER than the natural size. In order to pack at a smaller alignment than
	#  |  };                                             | its natural alignment, you absolutely need a packed statement. Remember than align only increases.
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  |                                                 | sizeof(B) = 6, because the compiler will calculate the struct-level alignment to be the 
	#  |  struct B {                                     | maximum of all individual member-level alignments. The __attribute__((aligned(2))) will now work,
	#  |    int i __attribute__((packed, aligned(2)));   | because now we have a member-level packed statement. 
	#  |    short s;                                     | Note that it is immaterial that the int i will pack from byte 0, which is still 4-byte-aligned.
	#  |  };                                             | Struct-level alignment = max(max(min(1,4),2), 2) = 2
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  |                                                 | sizeof(B) = 8, because the compiler will calculate the struct-level alignment to be the 
	#  |  struct B {                                     | maximum of all individual member-level alignments. The __attribute__((aligned(2))) will now work,
	#  |    int i   __attribute__((packed, aligned(2))); | because now we have member-level packed statements. 
	#  |    short s __attribute__((packed, aligned(1))); | So, struct-level alignment = max (2, 1, 1) = 2. Hence there is going to be a 1-byte padding at the end.
	#  |    char c;                                      |
	#  |  };                                             | 
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  |  struct B {                                     | sizeof(B) = 7, because the compiler will calculate the struct-level alignment to be the 
	#  |    int i   __attribute__((packed, aligned(1))); | maximum of all individual member-level alignments. The __attribute__((aligned())) will now work,
	#  |    short s __attribute__((packed, aligned(1))); | because now we have member-level packed statements. 
	#  |    char c;                                      | So, struct-level alignment = max (1, 1, 1) = 1. Hence there is going to be no padding at the end.
	#  |  };                                             | 
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  |  struct B {                                     | sizeof(B) = 8, because the compiler will calculate the struct-level alignment to be the 
	#  |    int i   __attribute__((packed, aligned(1))); | maximum of all individual member-level alignments. The __attribute__((aligned())) will now work,
	#  |    short s __attribute__((packed, aligned(1))); | because now we have member-level packed statements. 
	#  |    char c  __attribute__((packed, aligned(2))); | So, struct-level alignment = max (1, 1, 2) = 2. Hence there is going to be 1-byte padding at the end.
	#  |  };                                             | Pedantic note: the packed attribute will be ignored for the char, since char is by definition packed.
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  |  struct B {                                     | sizeof(B) = 16, because the compiler will calculate the struct-level alignment to be the 
	#  |    long long l __attribute__((packed,           | maximum of all individual member-level alignments. So, struct-level alignment = max (2, 2, 4) = 4. 
	#  |                               aligned(2)));     | This shows that aligned has the highest power. This is how the alignment of a member works.
	#  |    int i   __attribute__((packed, aligned(2))); |  First it is set to its natural alignment (say s).
	#  |    short s __attribute__((packed, aligned(4))); |  Then if there is a packed attribute, it is brought down to 1.
	#  |  };                                             |  Then if there if an aligned(m) attribute, that increases the alignment to m.
	#  |                                                 |  If there is no packed but only aligned, then it is set to max (s,m). Which basically means that
	#  |                                                 |  without a packed, aligned only works when it is bigger than the natural size. So, align only increases,
	#  |                                                 |  never reduces an alignment.
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  |  struct B {                                     | sizeof(B) = 14, because the compiler will calculate the struct-level alignment to be the 
	#  |    long long l __attribute__((packed,           | maximum of all individual member-level alignments. So, struct-level alignment = max (2, 2, 2) = 2. 
	#  |                               aligned(2)));     | 
	#  |    int i   __attribute__((packed, aligned(2))); |  
	#  |    short s __attribute__((packed, aligned(2))); |  
	#  |  };                                             |  
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  |  struct B {                                     | sizeof(B) = 16, because among all the alignment statements for c2, 8 wins.
	#  |      char c1;                                   | So, the only way c2 can be aligned to a 8-byte-boundary is if we add 7 bytes of pad after c1.
	#  |      char c2 __attribute__((aligned(2)))        |
	#  |              __attribute__((aligned(8)));       |
	#  |  };                                             |
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  |  struct B {                                     | sizeof(B) = 8, because among all the alignment statements for c1, 8 wins.
	#  |      char c1 __attribute__((aligned(2)))        | But, align(8) for a char means that after the compiler processes c1, it will allocate 8 bytes for c1.
	#  |              __attribute__((aligned(8)));       | Only the first byte will be actually used by c1, the rest 7 will be padding which will later be
	#  |      char c2;                                   | used by c2. 
	#  |  };                                             |
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  | #pragma pack(4)                                 | sizeof(B) = 8, because among all the alignment statements for c2, 8 wins, but that also gets reduced
	#  |  struct B {                                     | to 4 because of #pragma pack(4).
	#  |      char c1;                                   |
	#  |      char c2 __attribute__((aligned(2)))        |
	#  |              __attribute__((aligned(8)));       |
	#  |  };                                             |
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  | #pragma pack(4)                                 | sizeof(B) = 4, because among all the alignment statements for c1, 8 wins. But we also have the 
	#  |  struct B {                                     | #pragma pack(4) statement, which brings the alignment of c1 back to 4.
	#  |      char c1 __attribute__((aligned(2)))        | But, align(4) for a char means that after the compiler processes c1, it will allocate 1 bytes for c1
	#  |              __attribute__((aligned(8)));       | and 3 bytes of pads after it. This 3-byte-pad will then be utilized by c2.
	#  |      char c2;                                   | We do NOT mentally apply a aligned(4) for c2, since that will increase the alignment for c2.
	#  |  };                                             | #pragma pack(n) only decreases the alignment, never increases it.
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  | #pragma pack(4)                                 | sizeof(B) = now 8.
	#  |  struct B {                                     | This example shows why #pragma pack(n) does not mean "apply align(n) to every member" automatically.
	#  |      char c1 __attribute__((aligned(2)))        | This is exactly the same as the previous example, but we have added the aligned(4) to c2 explicitly.
	#  |              __attribute__((aligned(8)));       | In the previously example, had #pragma pack(n) applied an "align(4)" to c2, it would be equivalent to this.
	#  |      char c2 __attribute__((aligned(4)));       | But now you see that by adding "aligned(4)" makes c2 also aligned to 4, which means it can no longer
	#  |  };                                             | utilize any part of those 3-byte padding after c1.
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  |  #pragma pack(2)                                | sizeof(B) = 14
	#  |  struct B {                                     | Each of these members get an alignment of 2. So that is the overall struct-level alignment.
	#  |    long long l;                                 | 
	#  |    int i;                                       | 
	#  |    short s;                                     | 
	#  |  };                                             | 
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  |  struct B {                                     | sizeof(B) = 8, because the compiler will calculate the struct-level alignment to be the 
	#  |    int i   __attribute__((packed));             | maximum of all individual member-level alignments. Due to the __attribute__((packed)) statement,
	#  |    short s ;                                    | the alignment of int i is now 1. 
	#  |    char c;                                      | So, struct-level alignment = max (1, 2, 1) = 2. Hence there is going to be 1-byte padding at the end.
	#  |  };                                             | 
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  |  struct B {                                     | sizeof(B) = 7, because the compiler will calculate the struct-level alignment to be the 
	#  |    int i   __attribute__((packed));             | maximum of all individual member-level alignments. Due to the __attribute__((packed)) statement,
	#  |    short s __attribute__((packed));             | the alignment of both int i and short s is now 1. 
	#  |    char c;                                      | So, struct-level alignment = max (1, 1, 1) = 1. Hence there is going to be no padding at the end.
	#  |  };                                             | 
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  |  struct B {                                     | 
	#  |    int i;                                       | sizeof(B) = 7, because when there is a packed statement at the struct-level, the compiler will calculate 
	#  |    short s ;                                    | the struct-level alignment to be 1, irrespective of all individual member-level alignments.
	#  |    char c;                                      |
	#  |  }__attribute__((packed));                      | 
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  |  struct B {                                     | This is the same as the previous example, except that we are starting with smaller items.
	#  |    char c;                                      | sizeof(B) = 7, because when there is a packed statement at the struct-level, the compiler will calculate 
	#  |    int i;                                       | the struct-level alignment to be 1, irrespective of all individual member-level alignments.
	#  |    short s ;                                    | Plus, that struct-level packed statement applies to all individual statements.
	#  |  }__attribute__((packed));                      | 
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  |  struct B {                                     | sizeof(B) = 4, because when there is an aligned statement at the struct-level, that only applied to 
	#  |    char c1;                                     | the overall struct-level alignment - it does not apply to any individual member. This is different from
	#  |    char c2;                                     | the struct-level packed statement, which applies to all individual statements.
	#  |    char c3;                                     | Had the struct-level aligned(4) applied to all individual members, the sizeof(B) would have been 12.
	#  |  }__attribute__((aligned(4)));                  | 
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  | #pragma pack(2)                                 | sizeof(B) = 10, because the compiler will pack i2 right after the short s.
	#  |  struct B {                                     | It's because 2 is smaller than sizeof(int), which is 4.
	#  |        int i1;                                  | 
	#  |        short s;                                 |
	#  |        int i2;                                  |
	#  |  };                                             |
	#  |_________________________________________________|____________________________________________________________________________________________________
#####  | #pragma pack(4)                                 | sizeof(C) = 12, because now the compiler will pack int i2 from its natural alignement (4),
	#  |  struct C {                                     | 
	#  |        int i1;                                  | 
	#  |        short s;                                 |
	#  |        int i2;                                  |
	#  |  };                                             |
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  | #pragma pack(4)                                 | sizeof(D) = 12, because now the compiler will pack short s2 from its natural alignement (2),
	#  |  struct D {                                     | It's because 2 is smaller than 4 (the value in #pragma pack). Remember that #pragma pack(n) 
	#  |        int i1;                                  | can only reduce the overall alignment, never increase it.
	#  |        short s1;                                |
	#  |        short s2;                                |
	#  |        int i2;                                  |
	#  |  };                                             |
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  | #pragma pack(4)                                 | sizeof(E) = 12, because now the compiler will pack the double d from the packed-mandated 
	#  |  struct E {                                     | alignment of 4 rather than its natural alignement (8), It's because 4 is smaller than 8. 
	#  |        short s1;                                |
	#  |        double d;                                |
	#  |  };                                             |
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  | struct F1 {              |   struct F2 {        | sizeof(F1) = 1, and sizeof(F2) = 11. It's because the overall struct size will be aligned to the 
	#  |        char c;           |        char c[11];   | size of the largest element among the sturcture member variables, which is char here. 
	#  |  };                      |   };                 |
	#  |__________________________|______________________|____________________________________________________________________________________________________
	#  | #pragma pack(4)                                 | sizeof(G) = 1, despite the #pragma pack(4) directive. That's because #pragma pack() can only
	#  |  struct G {                                     | lower the alignment (than the natural alignment of any struct member variable. Since the member
	#  |        char c;                                  | variable here is a char, #pragma pack(n) for any value of n has no effect.
	#  |  };                                             |
	#  |_________________________________________________|____________________________________________________________________________________________________
	#  | struct H {                                      |sizeof(H) = 2. 
	#  |            short s;                             |
	#  |   };                                            |
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |                                                 | sizeof(I) = 8. That's because now the two aligned directives expands the short to 8 bytes and
	#  | struct I {                                      | 4 bytes, and irrespective of whichever aligned statement came first, the biggger one wins.
	#  |            short s __attribute__((aligned(8)))  | So, the following two declarations have the same effect:
	#  |                    __attribute__((aligned(4))); |  short s __attribute__((aligned(8)))  __attribute__((aligned(4)));
	#  |   };                                            |  short s __attribute__((aligned(4)))  __attribute__((aligned(8)));
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  | #pragma pack(4)                                 | sizeof(J1) = 4. That's because now the two aligned directive expands the short to 8 bytes,
	#  | struct J1 {                                     | and the #pragma pack reduces it to 4. 
	#  |            short s __attribute__((aligned(4)))  | 
	#  |                    __attribute__((aligned(8))); |
	#  |   };                                            |
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  | #pragma pack(8)                                 | sizeof(J2) = 4. That's because now the aligned directive expands the short to 4 bytes,
	#  | struct J2 {                                     | and the #pragma pack (8) cannot increase it because min(4,8) = 4.
	#  |            short s __attribute__((aligned(4))); | This shows the proof that #pragma pack does not mean that "Ignore the other aligned".
	#  |   };                                            | They are still processed.
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  | #pragma pack(1)                                 | sizeof(K) = now 2. That's because now the aligned directive expands the short to 4 bytes,
	#  |                                                 | in both size and alignment, but and the #pragma pack(1) reduces the size to 2.
	#  | struct K {                                      | It cannot reduce the size to 1 because a short takes 2 bytes at the minimum. However, the other part 
	#  |            short s __attribute__((aligned(4))); | of a #pragma pack(n) statement is the "packing" part, which we will see in the next example.
	#  |   };                                            | So, after the aligned(4) expanded the size and alignment for the short to 4 from 2, 
	#  |                                                 | the pragma pack(1) reduces the size from 4 to 2, and the alignment from 4 to 1.
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  | #pragma pack(1)                                 | sizeof(L) = now 3. That's because now the aligned directive expands the short to 4 bytes in size and alignment,
	#  | struct L {                                      | and the #pragma pack(1) reduces the size back to 2. It cannot reduce the size to 1 because a short takes
	#  |            char c;                              | 2 bytes at the minimum. However, the other part of a #pragma pack(n) statement is the
	#  |            short s __attribute__((aligned(4))); | "packing" part, which allows the short s to map from the second byte iteself.
	#  |   };                                            | Also, observe that now the short s is aligned to a 1-byte boundary, overriding its natural 2-byte size.
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |                                                 | This is exactly the same as the previous one, exept the #pragma pack(1) part. Now, we will see
	#  | struct M {                                      | sizeof(M) = now 8. That's because now the aligned directive expands the short to 4 bytes,
	#  |            char c;                              | and without the #pragma pack(1) statement there is nothing to reduce it.
	#  |            short s __attribute__((aligned(4))); | And now this 4-byte short can only be aligned at a 4-byte boundary.
	#  |   };                                            | There is no "packing" part, which allows the short s to map from the second byte iteself.
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |                                                 | This is exactly the same as the previous one, exact the  __attribute__((packed)) part. Now, we will see
	#  | struct __attribute__((packed)) N1 {             | sizeof(N1) = still 8. That's because now the aligned directive expands the short to 4 bytes,
	#  |            char c;                              | and without the #pragma pack(1) statement there is nothing to reduce it.
	#  |            short s __attribute__((aligned(4))); | And now this 4-byte short can only be aligned at a 4-byte boundary.
	#  |   };                                            | There is no packing "packing" part, which allows the short s to map from the second byte iteself.
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  | #pragma pack(1)                                 | This is exactly the same as the previous one, exact the  #pragma pack(1). Now, we will see
	#  | struct __attribute__((packed)) N2 {             | sizeof(N2) = now 3. That's because now the aligned directive expands the short to 4 bytes,
	#  |            char c;                              | but the #pragma pack(1) statement reduces it back to 2 bytes. Also, the #pragma pack(1) overrides the requirement
	#  |            short s __attribute__((aligned(4))); | for the aligned(4) that the short can only be aligned at a 4-byte boundary.
	#  |   };                                            | So it starts packing from the second byte itself.
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#
	#
	######################################################################################################################################
	# Rules of Bitfields 
	######################################################################################################################################
	#
	#  A bitfield statement is like char c1 : 7; They can be signed or unsigned. There can be __attribute__(()) statements like packed or aligned().
	#  The container (datatype) for a bitfield is the integer type - char / short / int / long / long long etc.
	#  In a bitfield sequence, we can have a mixture of datatypes. For example, this following is a valid struct:
	#
	#  struct mixed {                      _
	#					char c: 7;			\
	#					short s: 14;         |
	#					long long ll: 63;     >  bitfield sequence # 1
	#					char c2: 1;        _/ 
	#
	#					int i;
	#                                      _
	#					char c2: 7;			\
	#					short s2: 14;        |
	#					int i1: 3;            >  bitfield sequence # 2
	#					int i2: 20;          |
	#					char c3: 1;        _/ 
	#				};
	#
	
	
	
	
	
	
	
	

	#  ===================================   This part below needs to be deleted once we implement it correctly ==============================
	#
	# It is highly compiler-dependent. There is no guarantee it will match with the actual implementations.
	#
	# 1. Bitfields cannot cross their container boundaries - it will just add padding. Which means, the situation below will result in 12 bytes (3 ints), not 8 (2 ints)
	#      int a:31, b:2, c:31;
	#
	# 2. Size of structs containing Bitfields CAN have odd values, like 1,3,5,7,9 etc.
	#
	# 3. Total Bitfield size will depend on the maximum-sized container within the list, if it is mixed type. If all the types are identical, there is no choosing (makes life easy).
	#    For example, int i:28; char c: 7; will get a size of two ints (8 bytes). Yet, char c1: 7, c2: 7, c3: 7, c4: 7; char c5: 7; will get a size of 5 bytes.
	#    This is because in the latter case the maximum-sized container is a char, while in the former it is an int.
	#
	#    Also, <char b3:2; int i: 28; short s: 3;> will require 2 ints (8 bytes) where <char b3:2; int i: 27; short s: 3;> would only require 1 int (4 bytes).
	#
	#    Only one exception: If there is a long long (whose size is 8 bytes), we still seem to be using the multiple of 4 bytes only after 8.
	#    So,  <char b3:7; long long int i: 58;> would require 12 bytes (not 16) while <char b3:6; long long int i: 58;> would only require 8.
	#
	#  This can lead to a paradoxical situation where by supplying a BIGGER container, one can REDUCE the overall size. But that is really not paradoxical,
	#  because a bigger container can allow better packing, while for a smaller container one would waste more empty space.
	# 
	#    <short a:9, b:9, c:9; > would take 6 bytes. But <int a:9, b:9, c:9; > would take only 4 bytes. 
	#
	#  Therefore, whenever you get a sequence of bitfields in a struct definition (recall that a single struct can have multiple disjoint bitfield sequences, 
	#  this the way to figure out the size of that sequence:
	# 
	#   a. Suppose the structure has 3 members, with 3 different containers X, Y and Z. Go through the sequence to find out the largest container out of X, Y and Z(say it is Y).
	#   b. For each member, ignore the respective container. For example, if the first member's container size is X but size(X) < size(Y), ignore X. Assume every container is Y.
	#   c. Start packing items one by one into an Y container. The moment adding another item would exceed the container, start another Y container.
	#   d. For Big-endian, pack from MSb to LSb (where the MSb can be at the max 63). For Little-endian, pack from LSb to MSb.

	#  ===================================   This part above needs to be deleted once we implement it correctly ==============================
	#
	
	
	#
	#  Some examples of bitfields with aligned, packed and #pragma pack (the used bits are marked as 1, the pads are 0, MSb on the left, LSb on the right):
	#
	#	Main rule:
	#	
	#	1. Usually, look at the current first unfilled bit. From there, go back to the closest past address that will support the alignment of the current datatype.
	#      For example, if it is a char, it will be aligned to a byte. For short, 2-bytes. For int, 4 bytes etc.
	#
	#   2. Check if there is an __aligned__ attribute at the member-level. If there is, irrespective of whether this member is packed or not, aligned would prevail.
	#      That aligned(m) may potentially be reduced by a #pragma pack(n), but in no case will it fall below the 1-byte boundary. And this works even if the
	#      m in aligned(m) is less than the naturnal size of the variable (for example, a "short s:5 __attribute__((aligned(1)));" statement.
	#
	#      You might be wondering - wait, for non-bitfields, aligned(m) always INCREASES the alignment - it never reduces. That's why, if we have a statement
	#      like "int i __attribute__((aligned(2)));", the aligned(2) is ignored since its aligned value (2) is less than the current alignment (4). Of course,
	#      if there were a __attribute__ ((packed)) too, then it were a different matter since the packed would first bring down the alignment to 1 byte, which
	# 	   the __attribute__((aligned(2))) will then INCREASE to 2. But, without any such packed thing here, how does the aligned(m) in statements like
	#	   "short s:5 __attribute__((aligned(1)));" still work? Aren't they reducing rather than increasing?
	#
	#	   The answer is - an aligned(m) always increases the alignment, never reduces. When you think in terms of bitfields, even without a packed statement,
	#      a bitfield occupies the very next bit (a packed statement makes a single  bitfiled to potentially overlap two different containers, if required).
	#      This means that current alignment is 1 BIT. When there is an aligned(1) statement, that means we are expanding the bit-packing-alignment to 1 BYTE.
	#      That's a increase from 1 BIT to 1 BYTE, which is an eight-fold increase.
	#
	#      In essense, the rules for determining the first eligible bit for loading the current bitfield member is:
	#		- No aligned(m):
	#			Choose the first unfilled bit (bit #c) as the possible packing place, assuming you do not cross the current container boundary.
	#			If you are crossing the container boundary, check if there is a PACKED attribute.
	#			  	- No PACKED: skip the current container and start filling from a new container.
	#				- Has PACKED: start filling from c. Yes, it will spill over to the next container, that's fine.
	#		
	#		- There are member-level aligned(m) attributes. Find out the overall alignment (which will be aligned to some 2's power of bytes). The first bit
	#		  adhering to this alignment is first eligible bit. PACKED or not PACKED, either at the member- or struct-level does not matter.
	#      
	#	   But, remember that just because we find this first "eligible" bit does not mean we will be able to pack the current member here - it depends on
	#      how big (number of bits) the current bitfield member is, and how many bits are left in the current container.
	#
	#   3. See if the remaining unfilled bits will be able to fully accommodate the current bits. If yes, fill it. 
	#      If not, then you need to check if it is packed.
	#      A struct can be packed by either at the packed attribute at the member-level, at the struct-level, or by a #pragma pack(n) statement.
	#      - If the member is not "packed", then go to the next address that supports the current alignment.
	#        For that, you need to look at the natural size(s), aligned(m), packed, and #pragma pack(n). Use the same ruleset as non-bitfield.
	#      - If it is packed, start packing from the current bit.
	#   
	#   4. The overall alignment of the structure follows the same rule - max of the individual alignments of each member. However,
	#
	#	We use these notations in the examples below:
	#	   	m - the power of 2 (1/2/4/8) in any __attribute__((aligned(m))) statement, if one exists
	#	   	n - the power of 2 (1/2/4/8) in any #pragma pack(n) statement, if one exists
	#		s - natural size for a data type (1 for char, 2 for short, 4 for int/long, 8 for long long etc.)
	#		a - final alignment for a struct member, after considering all the s, m and n. The overall struct is a multiple of this
	#		b - the number of bits sought for the current bitfield, must have b <= s (no, even if a > s, we still cannot have s < b < a)
	#	        So, this is illegal ==> 	short s:17 __attribute__((aligned(4)));
	#      		It does not matter that we have increased the alignment to 32 bits - if we are using short, we cannot use b > 16.
	#		c - the cumulative number of bits that have already been filled (including pads) up to now. Also represents the bit# for the first available bit to pack.
	#
	#
	#      This essentially means that, if a < s (like aligned(1) for a short or aligned(1/2) for an int), 
	#	   then you can start packing within the current container but at the a-byte alignment. So, find the first a-byte-aligned bit after the first c bits.
	#      Suppose you already filled c bits (0 < c < 8) and now you have to pack the next bitfield member.
	#		- short s1: b __attribute__((aligned(1))); 	<== Here the s1 can start packing from the bit #8 of the current short container. 
	#		  If b <= 8, then it can be accommodated in the byte1. Else, start from Byte2.
	#		- int i: b __attribute__((aligned(1))); 	<== Here the s can start packing from the second LSbyte of the current short container. 
	#	   On the other hand, for the ultimate alignment of m and natural container size (s), if m < s (like aligned(1) for a short or aligned(1/2) for an int), 
	#
	#  So, the golden rules are:
	#  
	#  - By default, in bitfields, the alignment is 1 BIT, packed or no packed. However, if inserting the next member variable causes it to overflow to the next container,
	#    that is not allowed unless we use a __packed__ or #pragma pack() statement.
	#  - #prgama pack(n) = packed + aligned(n). The PACKED part is always applied, but that aligned(n) is only applied in the following two cases:
	#     1. To the overall alignment of struct, if the m is less than that.
	#     2. Any individual member alignment, if the m is less than that.
	#  - A packed attribute does two things for a bitfield:
	#     1. It brings down the natural size of ALL containers (char / short / int / long / long long) to just 1 BYTE. This means the overall struct size may be less.
	#     2. It says that pack it from the first available bit, even if it does not fit in the current container (assuming no ALIGNED, which prevails over packed)
	#  - An ALIGNED(m) attribute does two things (m is 1/2/4/8):
	#     1. It dictates that a variable must be starting from (aligned to) a m-byte boundary, assuming no #pragma pack(n) exists where n<m.
	#	  2. It increases the size of the container, in case the m is larger than s (remember that s=1 byte if there is a packed).
	#  - A #pragma pack(n) statement lowers the aligned(m) to aligned(n), if n<m (recall that both n and m are 1/2/4/8/16). It also applies PACKED.
	#   _______________________________________________________________________________________________________________________________________________________
	#  |                                                 |
	#  |  struct C{  char  c:1;};                        | sizeof(C) = 1, sizeof(S) = 2, sizeof(I) = 4, sizeof(L) = 4, sizeof(LL) = 4.
	#  |  struct S{  short s:1;};                        |
	#  |  struct I{  int   i:1;};                        | It does not matter that we are just using one bit, the container size will prevail.
	#  |  struct L{  long  l:1;};                        | So, without any packed or aligned(), the natural size is the alignment, just like non-bitfield.
	#  |  struct LL{ long long  ll:1;};                  |
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  | #define A(n) __attribute__((__aligned__(n)))    |
	#  | A(1)  struct C{  char  c:1;};                   | sizeof(C) = 1, sizeof(S) = 2, sizeof(I) = 4, sizeof(L) = 4, sizeof(LL) = 4.
	#  | A(1)  struct S{  short s:1;};                   |
	#  | A(1)  struct I{  int   i:1;};                   | It does not matter that we are just using one bit, the container size will prevail.
	#  | A(1)  struct L{  long  l:1;};                   | The aligned(1) was ignored since it can only bring up the overall alignment, not decrease it.
	#  | A(1)  struct LL{ long long  ll:1;};             |
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  | #define A(n) __attribute__((__aligned__(n)))    |
	#  | A(2)  struct C{  char  c:1;};                   | sizeof(C) = 2, sizeof(S) = 2, sizeof(I) = 4, sizeof(L) = 4, sizeof(LL) = 4.
	#  | A(2)  struct S{  short s:1;};                   |
	#  | A(2)  struct I{  int   i:1;};                   | It does not matter that we are just using one bit, the container size will prevail.
	#  | A(2)  struct L{  long  l:1;};                   | The aligned(1) was ignored since it can only bring up the overall alignment, not decrease it.
	#  | A(2)  struct LL{ long long  ll:1;};             | Except the the first case (C), where it increased it because sizeof(C) was 1 byte without the aligned.
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  | #define A(n) __attribute__((__aligned__(n)))    |
	#  |  A(1) struct C0{                                |
	#  |  char      c1:1     , c2:1     , c3:1     ;};   | sizeof(C0) = 1, because the aligned(1) applies only at the overall structural level, not individually to c1/c2/c3.
	#  |  struct C1{                                     |
	#  |  char A(1) c1:1     , c2:1     , c3:1     ;};   | sizeof(C1) = 3, because the aligned(1) applies to each of c1/c2/c3 individually.
	#  |  struct C2{                                     |
	#  |  char      c1:1 A(1), c2:1     , c3:1     ;};   | sizeof(C2) = 1, because the aligned(1) applies to only c1, and c2/c3 can fit in right after c1.
	#  |  struct C3{                                     |
	#  |  char      c1:1     , c2:1 A(1), c3:1     ;};   | sizeof(C3) = 2, because the aligned(1) applies to only c2, and c3 can fit in right after c2.
	#  |  struct C4{                                     |
	#  |  char      c1:1     , c2:1     , c3:1 A(1);};   | sizeof(C4) = 2, because the aligned(1) applies to only c3, but c1 and c2 are occupying the first byte.
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct C{  char  c:1;}                         | sizeof(C) = 1, sizeof(S) = 2, sizeof(I) = 4, sizeof(L) = 4, sizeof(LL) = 4.
	#  |       __attribute__((aligned(1)));              | 
	#  |  struct S{  short s:1;}                         | Recall that Aligned only INCREASES the alignment, it cannot decrease it.
	#  |       __attribute__((aligned(1)));              | Hence, in absence of any PACKED attribute, it cannot reduce the default alignment (natural container size)
	#  |  struct I{  int   i:1;}                         | to the specified value of 1. Neither can the Aligned(1) ensure that the member variables should be
	#  |       __attribute__((aligned(1)));              | aligned to a byte boundary, because the member variable themselves have a higher alignment.
	#  |  struct L{  long  l:1;}                         |
	#  |       __attribute__((aligned(1)));              |
	#  |  struct LL{ long long  ll:1;}                   |
	#  |       __attribute__((aligned(1)));              |
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |                                                 |
	#  |  struct C{  char  c:1;} __attribute__((packed));| sizeof(C) = 1, sizeof(S) = 1, sizeof(I) = 1, sizeof(L) = 1, sizeof(LL) = 1.
	#  |  struct S{  short s:1;} __attribute__((packed));|
	#  |  struct I{  int   i:1;} __attribute__((packed));| It does not matter what we container size we are using, since we are just using one bit, 
	#  |  struct L{  long  l:1;} __attribute__((packed));| the PACKED will prevail. This is a new thing for bitfield - it is overriding the natural size to 1 byte.
	#  |  struct LL{ long long ll:1;}                    | 
	#  |           __attribute__((packed));              |
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |                                                 |
	#  |  struct C{  char  c:1;}                         | sizeof(C) = 1, sizeof(S) = 1, sizeof(I) = 1, sizeof(L) = 1, sizeof(LL) = 1.
	#  |       __attribute__((packed, aligned(1)));      | 
	#  |  struct S{  short s:1;}                         | Observe that if we had removed all the packed attributes, we would have ended up with 
	#  |       __attribute__((packed, aligned(1)));      |
	#  |  struct I{  int   i:1;}                         | sizeof(C) = 1, sizeof(S) = 2, sizeof(I) = 4, sizeof(L) = 4, sizeof(LL) = 4.
	#  |       __attribute__((packed, aligned(1)));      |
	#  |  struct L{  long  l:1;}                         |
	#  |       __attribute__((packed, aligned(1)));      |
	#  |  struct LL{ long long ll:1;}                    |
	#  |       __attribute__((packed, aligned(1)));      |
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |                                                 |
	#  |  struct C{  char  c:1;}                         | sizeof(C) = 4, sizeof(S) = 4, sizeof(I) = 4, sizeof(L) = 4, sizeof(LL) = 4.
	#  |       __attribute__((packed, aligned(4)));      |
	#  |  struct S{  short s:1;}                         | Proof that even though the packed is bringing down the natural size to 1 byte,
	#  |       __attribute__((packed, aligned(4)));      | aligned(4) is ensuring that the ultimate container size must be 4.
	#  |  struct I{  int   i:1;}                         | 
	#  |       __attribute__((packed, aligned(4)));      |
	#  |  struct L{  long  l:1;}                         |
	#  |       __attribute__((packed, aligned(4)));      |
	#  |  struct LL{ long long ll:1;}                    |
	#  |       __attribute__((packed, aligned(4)));      |
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |                                                 |
	#  |  struct C{  char  c:1;}                         | sizeof(C) = 2, sizeof(S) = 2, sizeof(I) = 2, sizeof(L) = 2, sizeof(LL) = 2.
	#  |       __attribute__((packed, aligned(2)));      |
	#  |  struct S{  short s:1;}                         | Again, PACKED reduced its alignment to one bit and its natural size to 1 byte.
	#  |       __attribute__((packed, aligned(2)));      | Then ALIIGNED(2) brought up its alignment and natural size to 2 bytes.
	#  |  struct I{  int   i:1;}                         | 
	#  |       __attribute__((packed, aligned(2)));      |
	#  |  struct L{  long  l:1;}                         |
	#  |       __attribute__((packed, aligned(2)));      |
	#  |  struct LL{ long long ll:1;}                    |
	#  |       __attribute__((packed, aligned(2)));      |
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  #pragma pack(2)                                |
	#  |  struct C{  char  c:1;}                         | sizeof(C) = 2, sizeof(S) = 2, sizeof(I) = 2, sizeof(L) = 2, sizeof(LL) = 2.
	#  |       __attribute__((aligned(4)));              |
	#  |  struct S{  short s:1;}                         | Think of the #pragma pack(2) = PACKED + ALIGNED(max 2)
	#  |       __attribute__((aligned(4)));              | 
	#  |  struct I{  int   i:1;}                         | Packed brought down to all the natural sizes to 1 byte, and alignment to one BIT.
	#  |       __attribute__((aligned(4)));              | Observe that presense or absense of PACKED had absolutely no effect once we had ALIGNED(4).
	#  |  struct L{  long  l:1;}                         | And then #pragma pack(2) was able to bring down the alignment to 2.
	#  |       __attribute__((aligned(4)));              |
	#  |  struct LL{ long long ll:1;}                    |
	#  |       __attribute__((aligned(4)));              |
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct C1{char  c1:5, c2:5,c3:5;};             | sizeof(C1) = 3 . Because without any packed, each of c1/c2/c3 starts on a new char container.
	#  |  struct C2{char  c1:5, c2:5,c3:5;}              | sizeof(C2) = 2 . Because packed allows us to  pack c2 over two char containers, leading to a denser packing.
	#  |      __attribute__((packed));                   |
	#  |  struct S1{short s1:5, s2:5, s3:5;};            | sizeof(S1) = 2. Becase we do not need any packed to put 15 bits of s1/s2/s3 into a 16-bit short container.
	#  |  struct S2{short s1:5, s2:5, s3:5;}             | sizeof(S2) = 2. Packed here is redundant.
	#  |      __attribute__((packed));                   |
	#  |  struct I1{int i1:5, i2:5, i3:5;}               | sizeof(I1) = 2. Packed brings down the natural size to 1 byte for the int. And we only need two such bytes.
	#  |      __attribute__((packed));                   |
	#  |  struct I2{int i1:5, i2:5, i3:25;}              | sizeof(I2) = 5. Observe that with the packed, we are not adding a second full int container -
	#  |      __attribute__((packed));                   | we are just adding one more byte. It's because PACKED has reduced the natural size to 1 byte.
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct A {                                     | sizeof(A) = 2, because now the compiler will pack int i2 right after i1.
	#  |        short i1:5;                              | So there will be a pad of 4 bits after i2.
	#  |        short i2:7;                              | i1 = 00000000 00011111 
	#  |  };                                             | i2 = 00001111 11100000
	#  |                                                 | ALL  00001111 11111111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct A {                                     | sizeof(A) = 2, because now the compiler will pack int i2 right after i1.
	#  |        short i1:5;                              | So there will be a pad of 4 bits after i2.
	#  |        short i2:7 __attribute__((packed));      | i1 = 00000000 00011111 
	#  |  };                                             | i2 = 00001111 11100000
	#  |  // The __attribute__((packed)) is redundant    | ALL  00001111 11111111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct A {                                     | sizeof(A) = now 2, because without the packed, now it is aligned to its "utilized" size (2 bytes).
	#  |        short i1:5;                              |       byte1    byte0  
	#  |        short i2:7 __attribute__((aligned(1)));  | i1 = 00000000 00011111
	#  |  };                                             | i2 = 01111111 00000000
	#  |                                                 | ALL  01111111 00011111
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct __attribute__((packed)) A {             | sizeof(A) = still 2, irrespective of the fact that there is a struct-level packed.
	#  |                                                 | Shows that the moment we have aligned(), you can never pack at the bit-level - you start at a new byte.
	#  |   char i1:1 __attribute__((packed));            | Here we went overboard with putting packed statement everywhere, but it did not matter.
	#  |                                                 |       byte1    byte0  
	#  |   char i2:1 __attribute__((packed,aligned(1))); | i1 = 00000000 00000001
	#  |  };                                             | i2 = 00000001 00000000
	#  |                                                 | ALL  00000001 00000001
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  | // No pragma pack                               | sizeof(A) = 2.
	#  |  struct A {                                     |       byte1    byte0  
	#  |     short i1: 1;                                |i1 = 00000000 00000001
	#  |   };                                            | In absence of any pragma pack, the natural size and alignment of i1 is the alignment of a short - 2 bytes.
	#  |                                                 | Since the overall size of a struct is a multiple of the biggest alignment, sizeof(A) = 2.
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  | #pragma pack(1)                                 | sizeof(A) = 1. Because #pragma pack(1) means packed + aligned(1). The packed brings down the natural size to 1 byte.
	#  |  struct A { short i1:1;};                       |        
	#  | #pragma pack(2)                                 | sizeof(B) = 1. Remember that pragma only bring DOWN the alignment, it cannot increase.
	#  |  struct B { short i1:1;};                       |        
	#  | #pragma pack(4)                                 | sizeof(C) = 1. Remember that pragma only bring DOWN the alignment, it cannot increase.
	#  |  struct C { short i1:1;};                       |        
	#  | #pragma pack(8)                                 | sizeof(D) = 1. Remember that pragma only bring DOWN the alignment, it cannot increase.
	#  |  struct D { short i1:1;};                       |        
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  | #pragma pack(1)                                 | sizeof(A) = 1. Because #pragma pack(1) means packed + aligned(1). The packed brings down the natural size to 1 byte.
	#  |  struct A { short i1:1, i2:1;};                 |        
	#  | #pragma pack(2)                                 | sizeof(B) = 1. Remember that pragma only bring DOWN the alignment, it cannot increase.
	#  |  struct B { short i1:1, i2:1;};                 |        
	#  | #pragma pack(4)                                 | sizeof(C) = 1. Remember that pragma only bring DOWN the alignment, it cannot increase.
	#  |  struct C { short i1:1, i2:1;};                 |        
	#  | #pragma pack(8)                                 | sizeof(D) = 1. Remember that pragma only bring DOWN the alignment, it cannot increase.
	#  |  struct D { short i1:1, i2:1;};                 | This example shows that #pragma pack(n) does NOT mean that we add any ALIGNED(n) attribute anywhere.       
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  | // No pragma pack                               | sizeof(A) = 4.
	#  |  struct A {                                     |       byte3    byte2    byte1    byte0  
	#  |     int i1: 1;                                  |i1 = 00000000 00000000 00000000 00000001
	#  |   };                                            |
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  | // No pragma pack                               | sizeof(A) = still 4. The aligned(2) is ignored since align can only increase, not reduce alignment.
	#  |  struct A {                                     |       byte3    byte2    byte1    byte0  
	#  |     int i1: 1 __attribute__((aligned(2)));      |i1 = 00000000 00000000 00000000 00000001
	#  |   };                                            | 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  | // No pragma pack                               | sizeof(A) = now 2. The aligned(2) now works since align can now increase the post-packed alignment of 1
	#  |  struct A {                                     |       byte1    byte0  
	#  |     int i1: 1 __attribute__((aligned(2)))       |i1 = 00000000 00000001
	#  |               __attribute__((packed));          |
	#  |   };                                            | The packed made the size of i1 to 1 byte, which the aligned(2) increased to 2 bytes.
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  | // No pragma pack                               | sizeof(A) = now 3. The aligned(2) now works since align can now increase the post-packed alignment of 1
	#  |  struct __attribute__((packed)) A {             |         byte2    byte1    byte0  
	#  |       int i1: 1 __attribute__((aligned(1)));    |  i1 = 00000000 00000000 00000001 
	#  |       int i2: 1 __attribute__((aligned(1)));    |  i2 = 00000000 00000001 00000000 
	#  |       int i3: 1 __attribute__((aligned(1)));    |  i3 = 00000001 00000000 00000000 
	#  |   };                                            | ALL = 00000001 00000001 00000001 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  | 
	#  | // No packed, or pragma pack                    | sizeof(A) = 4. Since a short can only hold 16 bits, we start from a new short boundary.
	#  |  struct A {                                     |        byte3    byte2    byte1    byte0  
	#  |     short i1: 15;                               | i1 = 00000000 00000000 01111111 11111111 
	#  |     short i2: 2;                                | i2 = 00000000 00000011 00000000 00000000 
	#  |  };                                             | ALL  00000000 00000011 01111111 11111111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  | // No pragma pack, but there is a packed        | sizeof(A) = still 4. But, we are NOT starting from the new short boundary - i2 overlaps both shorts.
	#  |  struct A {                                     |        byte3    byte2    byte1    byte0  
	#  |     short i1: 15;                               | i1 = 00000000 00000000 01111111 11111111 
	#  |     short i2: 2 __attribute__((packed));        | i2 = 00000000 00000001 10000000 00000000 
	#  |  };                                             | ALL  00000000 00000001 11111111 11111111 
	#  |                                                 | Why still 4 bytes? Well, the alignment of i1 is still 2 bytes, and the overall struct's alignment 
	#  |                                                 | must be a multiple of that.
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |                                                 | sizeof(A) = 3. Bits are packed in the same packed fashion, but the overall alignment is 1 byte, thanks to packed.
	#  |  struct A {                                     |        byte2    byte1    byte0  
	#  |     short i1:15;                                | i1 = 00000000 01111111 11111111 
	#  |     short i2: 2;                                | i2 = 00000001 10000000 00000000 
	#  |  } __attribute__((packed));                     | ALL  00000001 11111111 11111111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |                                                 | sizeof(A) = 3. The aligned(1) does not change anything since the overall struct alignment was 1 anyway.
	#  |  struct A {                                     |        byte2    byte1    byte0  
	#  |     short i1:15;                                | i1 = 00000000 01111111 11111111 
	#  |     short i2: 2;                                | i2 = 00000001 10000000 00000000 
	#  |  } __attribute__((packed, aligned(1)));         | ALL  00000001 11111111 11111111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  | #pragma pack(1)                                 | sizeof(A) = 3. Bits are packed in the same packed fashion, but the overall alignment is 1 byte.
	#  | struct A {short i1:15, i2:2;};                  | 
	#  |                                                 | The equivalence works because we are choosing a pack(n=1) which is <= overall structural alignment.
	#  |  // Is equivalent to                            |
	#  |                                                 |
	#  |  struct A {                                     |        byte2    byte1    byte0  
	#  |     short i1:15;                                | i1 = 00000000 01111111 11111111 
	#  |     short i2: 2;                                | i2 = 00000001 10000000 00000000 
	#  |  } __attribute__((packed, aligned(1)));         | ALL  00000001 11111111 11111111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  | #pragma pack(2)                                 | sizeof(A1) = Still 4. Again, we are NOT starting from the new short boundary - i2 overlaps both shorts.
#####  | struct A {short i1:15, i2:2;};                  | Which basically means, that for bitfields, #pragma pack() means PACKED at the struct level anyway.
	#  | // PACKED has no extra effect                   | And then, sizeof(short) = 2.
	#  |  // Is equivalent to                            | 
	#  |                                                 | 
	#  |  struct A {                                     |        byte3    byte2    byte1    byte0  
	#  |     short i1:15;                                | i1 = 00000000 00000000 01111111 11111111 
	#  |     short i2: 2;                                | i2 = 00000000 00000001 10000000 00000000 
	#  |  } __attribute__((packed, aligned(2)));         | ALL  00000000 00000001 11111111 11111111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
#####  | #pragma pack(4)                                 | sizeof(A) = Still 4. Again, we are NOT starting from the new short boundary - i2 overlaps both shorts.
	#  | struct A {short i1:15, i2:2;};                  | Which basically means, that for bitfields, #pragma pack() means PACKED at the struct level anyway.
	#  | // PACKED has no extra effect                   |  And then, sizeof(short) = 2.
	#  |  // Is equivalent here to                       | 
	#  |                                                 | 
	#  |  struct A {                                     |        byte3    byte2    byte1    byte0  
	#  |     short i1:15;                                | i1 = 00000000 00000000 01111111 11111111 
	#  |     short i2: 2;                                | i2 = 00000000 00000001 10000000 00000000 
	#  |  } __attribute__((packed, aligned(4)));         | ALL  00000000 00000001 11111111 11111111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |_________________________________________________|_____________________________________________________________________________________________________
#####  | #pragma pack(8)                                 | sizeof(A1) = Still 4. From #pragma pack(8), only the PACKED part will have any effect, by allowing 
	#  | struct A1 {short i1:15, i2:2;};                 | i2 to span both byte1 and byte2. However, the other part of #pragma pack(8) - the aligned(8) will not be applied
	#  | // PACKED has no extra effect                   |  since the overall struct alignment of 4 is less than 8. Recall that #pragma pack(n) only lowers the alignment
	#  |  // Is NOT equivalent to                        | values to n - it never increases it to n.
	#  |                                                 | sizeof(A2) = 8, not 4. The layout of the bottom 4 bytes is the same though.
	#  |  struct A2 {                                    |        byte7    byte6    byte5    byte4    byte3    byte2    byte1    byte0  
	#  |     short i1:15;                                | i1 = 00000000 00000000 00000000 00000000 00000000 00000000 01111111 11111111 
	#  |     short i2: 2;                                | i2 = 00000000 00000000 00000000 00000000 00000000 00000001 10000000 00000000 
	#  |  } __attribute__((packed, aligned(8)));         | ALL  00000000 00000000 00000000 00000000 00000000 00000001 11111111 11111111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct A {                                     | sizeof(A) = 4, because now i2 is aligned to a 2-byte boudary. So there will be a pad of 4 bits after i2.
	#  |        short i1:5;                              | Observe that 5+7 bits = 12 bits fit into a single short, yet i2 starts from a new short boundary.
	#  |                                                 |       byte3    byte2    byte1    byte0  
	#  |        short i2:7 __attribute__((aligned(2)));  | i1 = 00000000 00000000 00000000 00011111  
	#  |  };                                             | i2 = 00000000 01111111 00000000 00000000 
	#  |                                                 | ALL  00000000 01111111 00000000 00011111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct A {                                     | sizeof(A) = still 4, because now i2 is aligned to a 2-byte boudary. So there will be a pad of 4 bits after i2.
	#  |        short i1:5;                              | Observe that 5+7 bits = 12 bits fit into a single short, yet i2 starts from a new short boundary.
	#  |                                                 |       byte3    byte2    byte1    byte0  
	#  |        short i2:7 __attribute__((aligned(2)));  | i1 = 00000000 00000000 00000000 00011111  
	#  |  } __attribute__((packed)) ;                    | i2 = 00000000 01111111 00000000 00000000 
	#  |                                                 | ALL  00000000 01111111 00000000 00011111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct B {                                     | sizeof(B) = 2, because now the compiler will pack int i2 right after i1.
	#  |        short i1:5;                              | So there will be a pad of 2 bits after i2. 
	#  |        short i2:9;                              | i1 = 00000000 00011111 
	#  |  };                                             | i2 = 00111111 11100000
	#  |                                                 | ALL  00111111 11111111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  __attribute__((packed)) struct B {             | sizeof(B) = 2, because now the compiler will pack int i2 right after i1.
	#  |        short i1:5;                              | So there will be a pad of 2 bits after i2. The __attribute__((packed)) is redundant here (no aligned).
	#  |        short i2:9;                              | i1 = 00000000 00011111 
	#  |  };                                             | i2 = 00111111 11100000
	#  |  // packed is redundant                         | ALL  00111111 11111111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct C {                                     | sizeof(C) = 4, because i2 will now be aligned to a 2-byte boundary.
	#  |        short i1:5;                              |       byte3    byte2    byte1    byte0  
	#  |        short i2:9 __attribute__((aligned(2)));  | i1 = 00000000 00000000 00000000 00011111 
	#  |  };                                             | i2 = 00000001 11111111 00000000 00000000 
	#  |                                                 | ALL  00000001 11111111 00000000 00011111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  __attribute__((packed)) struct C {             | sizeof(C) = still 4, because aligned has more power than packed.
	#  |        short i1:5;                              |       byte3    byte2    byte1    byte0  
	#  |        short i2:9 __attribute__((aligned(2)));  | i1 = 00000000 00000000 00000000 00011111 
	#  |  };                                             | i2 = 00000001 11111111 00000000 00000000 
	#  |                                                 | ALL  00000001 11111111 00000000 00011111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct C {                                     | sizeof(C) = now 4, because without the packed, now it is aligned to i1's size (2 bytes).
	#  |        short i1:5;                              |       byte3    byte2    byte1    byte0  
	#  |        short i2:9 __attribute__((aligned(1)));  | i1 = 00000000 00000000 00000000 00011111  
	#  |  };    //aligned(1) is ignored since it can     | i2 = 00000001 11111111 00000000 00000000 
	#  |        //only INCREASE alignment, not reduce    | ALL  00000001 11111111 00000000 00011111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct C {                                     | sizeof(C) = still 4, because without the packed for i1, it's still aligned to max-sized i1's size (2 bytes).
	#  |        short i1:5 __attribute__((aligned(1)));  |       byte3    byte2    byte1    byte0  
	#  |        short i2:9 __attribute__((aligned(1)));  | i1 = 00000000 00000000 00000000 00011111 
	#  |  };                                             | i2 = 00000001 11111111 00000000 00000000 
	#  |     // No packed anywhere, aligneds ignored     | ALL  00000001 11111111 00000000 00011111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct C {                                     | sizeof(C) = still 4, because without the packed for i1, it's still aligned to max-sized i1's size (2 bytes).
	#  |        short i1:5 __attribute__((aligned(1)));  |       byte3    byte2    byte1    byte0      And while i2 is now aligned to 1-byte, even if it starts from
	#  |        short i2:9 __attribute__((aligned(1)))   | i1 = 00000000 00000000 00000000 00011111    bit 8 (beginning of byte1), its 9 bits will still not fit within
	#  |                   __attribute__((packed));      | i2 = 00000001 11111111 00000000 00000000    byte1. Hence it must start on byte2 and spill into byte3.
	#  |  };                                             | ALL  00000001 11111111 00000000 00011111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct C {                                     | sizeof(C) = still 4, because without the packed for i2, it's still aligned to max-sized i2's size (2 bytes).
	#  |        short i1:5 __attribute__((aligned(1)))   |       byte3    byte2    byte1    byte0  
	#  |                   __attribute__((packed));      | i1 = 00000000 00000000 00000000 00011111 
	#  |        short i2:9 __attribute__((aligned(1)));  | i2 = 00000001 11111111 00000000 00000000 
	#  |  };                                             | ALL  00000001 11111111 00000000 00011111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct C {                                     | sizeof(C) = now 3, because now the max-sized alignment is 1 byte. We have packed on each struct member level,
	#  |        short i1:5 __attribute__((aligned(1)))   | which is same as putting a packed in the struct-level, as the example below
	#  |                   __attribute__((packed));      |       byte2    byte1    byte0  
	#  |        short i2:9 __attribute__((aligned(1)))   | i1 = 00000000 00000000 00011111 
	#  |                   __attribute__((packed));      | i2 = 00000001 11111111 00000000 
	#  |  };                                             | ALL  00000001 11111111 00011111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  __attribute__((packed)) struct C {             | sizeof(C) = now 3, because now it is byte-aligned.
	#  |        short i1:5;                              |       byte2    byte1    byte0  
	#  |        short i2:9 __attribute__((aligned(1)));  | i1 = 00000000 00000000 00011111 
	#  |  };                                             | i2 = 00000001 11111111 00000000 
	#  |                                                 | ALL  00000001 11111111 00011111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  #pragma pack(2)                                | sizeof(C) = 2, because #pragma pack means PACKED on the whole struct.
	#  |   struct C {                                    |
	#  |        short i1:5;                              |       byte1    byte0  
	#  |        short i2:9;                              | i1 = 00000000 00011111 
	#  |  };                                             | i2 = 00111111 11100000 
	#  |                                                 | ALL  00111111 11111111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
#####  |  #pragma pack(2)                                | sizeof(C) = 4, because even though i2 is byte-aligned, i1's alignment is still 2-bytes.
	#  |   struct C {                                    |
	#  |        short i1:5;  // aligned(1) is redundant  |       byte3    byte2    byte1    byte0  
	#  |        short i2:9 __attribute__((aligned(1)));  | i1 = 00000000 00000000 00000000 00011111 
	#  |  };                                             | i2 = 00000000 00000001 11111111 00000000 
	#  | // PACKED has no extra effect                   | ALL  00000000 00000001 11111111 00011111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
#####  |  #pragma pack(2)                                | sizeof(C) = 4, because even though i1 and i2 are byte-aligned, i1's alignment is still 2-bytes.
	#  |   struct C {                                    |
	#  |        short i1:5 __attribute__((aligned(1)));  |       byte3    byte2    byte1    byte0  
	#  |        short i2:9 __attribute__((aligned(1)));  | i1 = 00000000 00000000 00000000 00011111 
	#  |  };                                             | i2 = 00000000 00000001 11111111 00000000 
	#  | // PACKED has no extra effect                   | ALL  00000000 00000001 11111111 00011111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct C {                                     | sizeof(C) = still 4, but look at the placement of i2. It's no longer at byte #2, it's now at byte#1
	#  |        short i1:5;                              |       byte3    byte2    byte1    byte0  
	#  |        int   i2:9 __attribute__((aligned(1)));  | i1 = 00000000 00000000 00000000 00011111 
	#  |  };                                             | i2 = 00000000 00000001 11111111 00000000 
	#  |  // MATCH BUT BOTH WRONG                        | ALL  00000000 00000001 11111111 00011111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct C {                                     | sizeof(C) = still 4, because you can still start at a byte-aligned second byte, and fill it within 1 int.
	#  |        short i1:5;                              |       byte3    byte2    byte1    byte0  
	#  |        int   i2:24 __attribute__((aligned(1))); | i1 = 00000000 00000000 00000000 00011111 
	#  |  };                                             | i2 = 11111111 11111111 11111111 00000000 
	#  |  //MATCH  BUT BOTH WRONG                        | ALL  11111111 11111111 11111111 00011111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct C {                                     | sizeof(C) = still 4, because you can still start at a byte-aligned second byte, and fill it within 1 int.
	#  |        short i1:5;                              |       byte3    byte2    byte1    byte0  
	#  |        int   i2:24 __attribute__((aligned(1))); | i1 = 00000000 00000000 00000000 00011111 
	#  |  } __attribute__((packed));  // redundant       | i2 = 11111111 11111111 11111111 00000000 
	#  |  //MATCH  BUT BOTH WRONG                        | ALL  11111111 11111111 11111111 00011111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct C {                                     | sizeof(C) = 8, because when you start packing from the byte2, you cannot fit in 24 bits witin the next 2 bytes.
	#  |                                                 | So you go to the next place where the int container can start (byte4) and pack from there.
	#  |        short i1:5;                              |        byte7    byte6    byte5    byte4   byte3    byte2    byte1    byte0  
	#  |        int   i2:24 __attribute__((aligned(2))); | i1 = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00011111 
	#  |  };                                             | i2 = 00000000 11111111 11111111 11111111 00000000 00000000 00000000 00000000 
	#  |                                                 | ALL  00000000 11111111 11111111 11111111 00000000 00000000 00000000 00011111 
	#  |  //MATCH  BUT BOTH WRONG                        | Because we did not have a packed attribute, aligned(2) was not able to REDUCE the alignemnt of where the 
	#  |                                                 | next int container could start from. Its alignment remained it natural size, 4.
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct C {                                     | sizeof(C) = 6, because when you start packing from the byte2, you cannot fit in 24 bits witin the next 2 bytes.
	#  |                                                 | So you go to the next place where the int container can start (byte2) and pack from there.
	#  |        short i1:5;                              |        byte5    byte4   byte3    byte2    byte1    byte0  
	#  |        int   i2:24 __attribute__((aligned(2)))  | i1 = 00000000 00000000 00000000 00000000 00000000 00011111 
	#  |                    __attribute__((packed));     | i2 = 00000000 11111111 11111111 11111111 00000000 00000000 
	#  |  };                                             | ALL  00000000 11111111 11111111 11111111 00000000 00011111 
	#  |                                                 | Because we have a packed attribute, it initially reduced the the alignemnt to 1 of where the next int container
	#  |  //MATCH  BUT BOTH WRONG                        | could start from. Then aligned(2) INCREASED that alignment to 2.
	#  |_________________________________________________|_____________________________________________________________________________________________________
#####  |  struct C {                                     | sizeof(C) = still 4, No change due to the int -> long long shift
	#  |      short i1:5;                                |       byte3    byte2    byte1    byte0  
	#  |      long long i2:9 __attribute__((aligned(1)));| i1 = 00000000 00000000 00000000 00011111 
	#  |  };                                             | i2 = 00000000 00000001 11111111 00000000 
	#  |  //MATCH  BUT BOTH WRONG                        | ALL  00000000 00000001 11111111 00011111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
#####  |   struct C {                                    | sizeof(C) = still 4, No change due to the int -> long long shift
	#  |      short i1:5;                                |       byte3    byte2    byte1    byte0  
	#  |      long long i2:9 __attribute__((aligned(2)));| i1 = 00000000 00000000 00000000 00011111 
	#  |  };                                             | i2 = 00000001 11111111 00000000 00000000
	#  |  //MATCH  BUT BOTH WRONG                        | ALL  00000001 11111111 00000000 00011111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
#####  |   struct C {                                    | sizeof(C) = now 8, No change due to the int -> long long shift ???????????????????????????????????
	#  |      short i1:5;                                |       byte3    byte2    byte1    byte0  
	#  |      long long i2:9 __attribute__((aligned(4)));| i1 = 00000000 00000000 00000000 00011111 is this correct?
	#  |  };                                             | i2 = 00000001 11111111 00000000 00000000
	#  |  //MATCH  BUT BOTH WRONG                        | ALL  00000001 11111111 00000000 00011111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  struct D {                                     | sizeof(D) = 8, because i2 will now be aligned to a 4-byte boundary.
	#  |        short i1:5;                              |       byte7    byte6    byte5    byte4   byte3    byte2    byte1    byte0  
	#  |        short i2:9 __attribute__((aligned(4)));  | i1 = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00011111 
	#  |  };                                             | i2 = 00000000 00000000 00000001 11111111 00000000 00000000 00000000 00000000 
	#  |  //MATCH  BUT BOTH WRONG                        | ALL  00000000 00000000 00000001 11111111 00000000 00000000 00000000 00011111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  __attribute__((packed)) struct E {             | sizeof(E) = still 8, because __attribute__ aligned has more power than packed.
	#  |        short i1:5;                              |       byte7    byte6    byte5    byte4   byte3    byte2    byte1    byte0  
	#  |        short i2:9 __attribute__((aligned(4)));  | i1 = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00011111 
	#  |  };                                             | i2 = 00000000 00000000 00000001 11111111 00000000 00000000 00000000 00000000 
	#  |  //MATCH  BUT BOTH WRONG                        | ALL  00000000 00000000 00000001 11111111 00000000 00000000 00000000 00011111 
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  #pragma pack(2)                                | sizeof(F) = 4, because even though aligned brings up the alignement to 4, the #pragma pack brings it
	#  |  struct F {                                     | down to 2.
	#  |                                                 |       byte3    byte2    byte1    byte0  
	#  |        short i1:5;                              | i1 = 00000000 00000000 00000000 00011111
	#  |        short i2:9 __attribute__((aligned(4)));  | i2 = 00000001 11111111 00000000 00000000
	#  |  };   //MATCH  BUT BOTH WRONG                   | ALL  00000001 11111111 00000000 00011111
	#  |_________________________________________________|_____________________________________________________________________________________________________
	#  |  #pragma pack(1)                                | sizeof(F) = 3, because even though aligned brings up the alignement to 4, the #pragma pack brings it
	#  |  struct F {                                     | down to 1.
	#  |        short i1:5;                              | i1 = 00000000 00000000 00011111 
	#  |        short i2:9 __attribute__((aligned(4)));  | i2 = 00000001 11111111 00000000 
	#  |  };   //MATCH  BUT BOTH WRONG                   | ALL  00000001 11111111 00011111
	#  |_________________________________________________|_____________________________________________________________________________________________________


	#########################################################################################################################
	#  Step 1. Iterate over all struct members for calculating all the size and alignments (including bitfield sizes)		#
	#          For Dynamic structs during Interpret stage, we only get the struct-level alignments, nothing else.			#
	#########################################################################################################################


	# We do all the calculations in bits so that we can use one single metric for both bitfield and non-bitfield (will have to divide it by BITS_IN_BYTE to get Byte #)
	trailingPadSizeBits = 0
	structSizeBytes = 0		
#	structSizeBits = 0 # Keep in mind that a struct size can never be an incomplete byte. It must always end at a byte boundary.
	largestMemberLevelAlignmentBytes = 1
	
	# For bitfields, there are two ways to calculate the bit offsets (GCC and Microsoft).
	# Technically, once can mix the storage containers. For example, struct MixedContainers { short s:2; int i:4; long l:20;}; is legal in C.
	# However, it is not a good way to code in C, since the output bit offset would vary from compiler to compiler.
	# Similarly, when you have different attributes for a bitfield-weilding struct (like packed, aligned and #pragma pack), the result may vary.
	structHasMemberLevelOrStructLevelAttributes = False
	structHasBitFields = False
	structHasBitFieldsWithMixedContainers = False
	structBitFieldContainers = []	# This gets filled with the various datatypes over the various bitfields
	
	lastItemWasZeroWidthBitfield = False
	
	PRINT("runtimeStatementsRelativeToComponentIndex =",runtimeStatementsRelativeToComponentIndex)
	PRINT("runtimeStatementsRelativeToComponentIndexStatus =",runtimeStatementsRelativeToComponentIndexStatus)		# Initially, all the members are set to 'execute'

	# Since this checkPreprocessingDirectivesInterleaving() routine expects an array of simple lines (not lists), we first convert the 
	# existing runtimeStatementsRelativeToComponentIndex to simple lines
	runtimeLines = [list2plaintext(x) if isinstance(x,list) else STR(x) for x in runtimeStatementsRelativeToComponentIndex]
	PRINT("The stringified runtimeStatementsRelativeToComponentIndex list is", runtimeLines)
	
	# Put the struct header record in unraveled for Dynamic structs
	if isDynamic: 
		if executionStage == "Map":	# Means the offset will have real value
			PRINT("Putting out the struct header row to the unraveled at the given level, although the struct length is unknown at this time and will need to get updated later")
			# Add the struct to the unraveled at the given level directly (without invoking addVariableToUnraveled() routine). Note that there is no end size since this is Dynamic.
			PRINT("Executing unraveledSupplied.append([level=",level,",",prefix+" is of type "+structDetails["type"],structName, ",offset =",offset, ", offset+structSizeBytes =",'"", "", "",',STR(ancestry),"]")
			
#			unraveledSupplied.append([level,prefix+" is of type "+structDetails["type"],structName, offset, "","","","",ancestry+[structVariableId]])		# BUG???
			unraveledSupplied.append([level,prefix+" is of type "+structDetails["type"],structName, offset, "","","","",ancestry])
			
			PRINT("\nstructName",structName,"is ",structDetails["type"]," - calling addVariableToUnraveled() for each member.")
			#Keep a note of which # record of unraveled we are adding, since we will have to update it later
			unraveledDynamicStructHeaderRowIndex = len(unraveledSupplied)-1
		else:
			PRINT("Not doing anything regarding the unraveled during the Interpret stage (obviously)")

	'''
	PRINT("\n\n\n","==="*50,"\nNow printing locals")
	for key in getDictKeyList(locals()):
		PRINT ("\t"*2,key, ':', locals()[key])
	PRINT("\n\n\n","==="*50,"\nNow printing globals")
	for key in getDictKeyList(globals()):
		PRINT ("\t"*2,key, ':', globals()[key])
	PRINT("==="*50,"\n\n")
	'''
	
	n = 0
	while True:
		if n >= len(runtimeStatementsRelativeToComponentIndex):
			break
	
		PRINT("\n\nCurrently dealing with runtimeStatementsRelativeToComponentIndex[n=",n,"] =",runtimeStatementsRelativeToComponentIndex[n],", where runtimeStatementsRelativeToComponentIndexStatus[",n,"] =",runtimeStatementsRelativeToComponentIndexStatus[n])

		# First check if the statement should be executed, or skipped. During Interpret, nothing should be skipped
		if runtimeStatementsRelativeToComponentIndexStatus[n] != 'execute' and executionStage == "Interpret":
			OUTPUT("Bad coding - during Interpret, every statement should have 'execute' status")
			sys.exit()
		# During Map stage, if it says not to execute a statement, just ignore that statement
		elif runtimeStatementsRelativeToComponentIndexStatus[n] != 'execute'  and executionStage == "Map":	
			PRINT("Skipping it because of its runtimeStatementsRelativeToComponentIndexStatus[",n,"] =",runtimeStatementsRelativeToComponentIndexStatus[n],"!")
			n = n+1	
			continue
		# Control come here means runtimeStatementsRelativeToComponentIndexStatus[n] is 'execute'. Now let's examine what kind of a statement it is
		# If it is not a #RUNTIME statement, no need to evaluate it (obviously)
		elif checkIfIntegral(runtimeStatementsRelativeToComponentIndex[n]): # An integreal value means it is the component index of the struct, not a #RUNTIME statement
			PRINT("Statement #",n,"(",runtimeStatementsRelativeToComponentIndex[n],") is NOT a Runtime statement")
		# If it is a #RUNTIME statement, don't evaluate it if we are in the Interpret stage (because the data will not be available anyway)
		elif not checkIfIntegral(runtimeStatementsRelativeToComponentIndex[n]) and executionStage == "Interpret":
			PRINT("Statement #",n,"(",runtimeStatementsRelativeToComponentIndex[n],") is a Runtime statement - ignoring it during", executionStage,"stage")
			n = n+1	
			continue
		# If it is a #RUNTIME statement, evaluate it if we are in the Map stage (because the data will now be available)
		elif not checkIfIntegral(runtimeStatementsRelativeToComponentIndex[n]) and executionStage == "Map":	
			PRINT("runtimeStatementsRelativeToComponentIndex[",n,"] =",runtimeStatementsRelativeToComponentIndex[n])
			if (not isinstance(runtimeStatementsRelativeToComponentIndex[n],list)) or (not runtimeStatementsRelativeToComponentIndex[n][0] == preProcessorSymbol) or (runtimeStatementsRelativeToComponentIndex[n][1] not in runtimeDirectives) or (len(runtimeStatementsRelativeToComponentIndex[n])<=1):
				errorMessage = "ERROR in calculateStructureLength(): Illegal #RUNTIME statement"
				errorRoutine(errorMessage)
				return False

			# First, find the scope of any if condition
			if runtimeStatementsRelativeToComponentIndex[n][1] in ('if', 'loop'):	# Starting of a if-elif-else-endif block
				# First figure out the which all source code statements are impacted by this if statement.
				# There might be multiple code blocks between the if-elif-elif-else-endif statements, but only one of them would succeed.
				PRINT("From calculateStructureLength(), calling checkPreprocessingDirectivesInterleaving(runtimeLines[n:],True) for runtime statement during map")
				scope = checkPreprocessingDirectivesInterleaving(runtimeLines[n:],True)
				if scope == False:
					errorMessage = "ERROR in calculateStructureLength() after calling checkPreprocessingDirectivesInterleaving() from line %d"%n
					errorRoutine(errorMessage)
					return False

				# Recall that the returned scope is nothing but a list like the one below, where all the linenumbers are relative to the first if statement
				# [ [0,"if"], [8,"elif"], [9,"elif"], [15, "endif"],[20, "loop"],[25, "endloop"] ]


				PRINT("For line #",n," the scope for the if-elif-else-endif is",scope)
				# Recall that the the line numbers returned from checkPreprocessingDirectivesInterleaving() are relative, i.e. they start from 0.
				# So, you need to add the current line number to get any absolute line number
				k = 0

				# Out of the many if-elif-elif-else-endif code blocks, only one will succeed. And once that succeeds, the rest must be deleted irrespecive of
				# whether corresponding #elif condition evaluates to True or not.
				ifConditionTruthValueAlreadyFound = False
				
				while k<len(scope):	# Recall that the scope has the if-elif-else-endif statements only, not the actual code blocks coming under those if-elif-else-endif statements 
					# We following this logic.
					# If the 
					targetLineNumber = scope[k][0]+n	# This is the actual line number in runtimeStatementsRelativeToComponentIndex
					PRINT("Looking at line #",targetLineNumber,"(",runtimeStatementsRelativeToComponentIndex[targetLineNumber],")")

					# Our main goal is to find if a code block should be skipped or not. It can be don
					# If we already had one of the if-elif-elif-else-endif conditions
					if ifConditionTruthValueAlreadyFound == False:
						skipCodeBlock = False	# We first default it to False, but will set it to True if the condition evaluates to be true
						targetLineTokenList = runtimeStatementsRelativeToComponentIndex[targetLineNumber]
						
						# First do a little bit of sanity checking that these are valid #RUNTIME statements
						if (not isinstance(targetLineTokenList,list)) or (len(targetLineTokenList)<2) or (targetLineTokenList[0] != preProcessorSymbol) or (targetLineTokenList[1] not in runtimeDirectives):
							errorMessage = "ERROR in calculateStructureLength(): Illegal #RUNTIME statement "+STR(targetLineTokenList)
							errorRoutine(errorMessage)
							return False
						elif targetLineTokenList[1] in ('if','ifdef','ifndef', 'elif') and len(targetLineTokenList)<3:
							errorMessage = "ERROR in calculateStructureLength() in line #"+targetLineNumber+": a "+ STR(targetLineTokenList[0:2]) +" statement must not be empty"
							errorRoutine(errorMessage)
							return False
						elif targetLineTokenList[1] in ('else','endif') and len(targetLineTokenList)>2:
							errorMessage = "ERROR in calculateStructureLength() in line #"+targetLineNumber+": a "+ STR(targetLineTokenList[0:2]) +" statement must not supply more than one argument"
							errorRoutine(errorMessage)
							return False
						
						# Calculate the if condition result (True or False). By here we know that all ifdef etc. things have proper arguments
						ifConditionEvaluationResult = False	# The default value

						if targetLineTokenList[1] in ('if','elif'):
							
							# Handle one special case - before calling parseArithmeticExpression(), we must resolve the case of defined().
							# This is because parseArithmeticExpression() is agnostic of exactly where in the source file the code is,
							# but the result of a defined(symbol) depends precisely on that. So parseArithmeticExpression() cannot
							# figure that out. So, we handle it locally first. We relace the defined(symbol) with 1 or 0.
							
							parseArithmeticExpressionResult = parseArithmeticExpression(targetLineTokenList[2:])
							if parseArithmeticExpressionResult == False:
								errorMessage = "ERROR in calculateStructureLength() parsing <%s>"%tokenizeLinesResult
								errorRoutine(errorMessage)
								return False
								
							evaluateArithmeticExpressionResult = evaluateArithmeticExpression(parseArithmeticExpressionResult)
							PRINT("evaluateArithmeticExpression(",STR(parseArithmeticExpressionResult),") evaluates to", evaluateArithmeticExpressionResult)
							if evaluateArithmeticExpressionResult[0] == False:
								errorMessage = "ERROR in calculateStructureLength() evaluating <%s> during %s stage"%(evaluateArithmeticExpressionResult,executionStage)
								errorRoutine(errorMessage)
								return False
							elif evaluateArithmeticExpressionResult[1] == 1:	# Truth value in C is 1, not True of Python
								ifConditionEvaluationResult = True
								PRINT("The if condition in line#",targetLineNumber," = <",lines[targetLineNumber],"> succeeded")
								ifConditionTruthValueAlreadyFound = True
							elif evaluateArithmeticExpressionResult[1] == 0:	# False value in C is 0, not False of Python
								PRINT("The if condition in line#",targetLineNumber," = <",lines[targetLineNumber],"> failed")
							elif evaluateArithmeticExpressionResult[1] == LOGICAL_TEST_RESULT_INDETERMINATE: 
								errorMessage = "ERROR in calculateStructureLength(): Cannot evaluate <%s> during %s stage - the evaluation result is"%(executionStage, STR(evaluateArithmeticExpressionResult))
								errorRoutine(errorMessage)
								return False
							else:
								errorMessage = "ERROR in calculateStructureLength() during %s stage - the evaluation result <%s> is neither 1 (True) nor 0 (False)"%(executionStage, STR(evaluateArithmeticExpressionResult))
								errorRoutine(errorMessage)
								return False
								
						elif targetLineTokenList[1] == 'else': 	# If you are falling on an #else, it is by defintion true
							ifConditionEvaluationResult = True
							PRINT("The '"+preProcessorSymbol+"else' succeeded")
								

						if ifConditionEvaluationResult == True:
							ifConditionTruthValueAlreadyFound = True
							PRINT("The overall if condition in line#",targetLineNumber," = <",lines[targetLineNumber],"> succeeded")
						elif ifConditionEvaluationResult == False:
							PRINT("The overall if condition in line#",targetLineNumber," = <",lines[targetLineNumber],"> failed")
							skipCodeBlock = True
						else:
							OUTPUT("Bad coding in calculateStructureLength() regarding ifConditionEvaluationResult checking - exiting!")
							sys.exit()
							
					elif ifConditionTruthValueAlreadyFound:
						skipCodeBlock = True
					else:
						OUTPUT("Bad coding regarding ifConditionTruthValueAlreadyFound checking in calculateStructureLength() - exiting!")
						sys.exit()
						
					# Now that we have calculated the if condition result (True or False), skip the if statements and corresponding non-executing code blocks
					if skipCodeBlock == False or k == len(scope)-1:
						numComponentsToSkip = 1
					else:
						numComponentsToSkip = scope[k+1][0] - scope[k][0]
						
					PRINT ("Going to skip line",scope[k][0]+n,"through line",scope[k][0]+n+numComponentsToSkip-1," - a total of",numComponentsToSkip,"lines" )
					d = 0
					while d < numComponentsToSkip:
						PRINT("Going to skip the line #",scope[k][0]+n+d, runtimeStatementsRelativeToComponentIndex[scope[k][0]+n+d])
						runtimeStatementsRelativeToComponentIndexStatus[scope[k][0]+n+d] = "skip"
						d += 1
					k += 1
					
					PRINT("\nCurrent status of runtimeStatementsRelativeToComponentIndex is")
					for j in range(len(runtimeStatementsRelativeToComponentIndexStatus)):
						PRINT(runtimeStatementsRelativeToComponentIndexStatus[j]+" "*(len("execute")-len(runtimeStatementsRelativeToComponentIndexStatus[j]))+"\t"*3+STR(runtimeStatementsRelativeToComponentIndex[j]))

				
			# For #RUNTIME statements, don't do anything else. 
			n = n+1	
			continue	# Corresponding to the loop statement: for n in range(len(runtimeStatementsRelativeToComponentIndex)):
			
		else:	# Should never happen
			OUTPUT("Bad coding in calculateStructureLength() - exiting!!")
			sys.exit()
			

		# From this point, we are not dealing with #RUNTIME statements	
		N = runtimeStatementsRelativeToComponentIndex[n]
		PRINT("\n\nFor n =",n, ", N =",N,", runtimeStatementsRelativeToComponentIndex =",runtimeStatementsRelativeToComponentIndex)
		executedStructMemberIndex.append(N)
		
		structMemberName 		= structDetails["components"][N][0]
		structMemberSizeBytes 	= structDetails["components"][N][1]		# How many bytes this member occupies, which is complicated because it could be an array and/or struct
		isBitField				= structDetails["components"][N][4]["isBitField"]
		isArray					= structDetails["components"][N][4]["isArray"]
		datatype				= structDetails["components"][N][4]["datatype"]
		variableId				= structDetails["components"][N][4]["variableId"]

		# During Map, we take two different actions at the beginning and the ending of this loop for actual member variables.
		#
		# At the beginning, we find out if this variable is the ancestor of either a blank-dimension array (varB).
		# At the end, we find out if this variable is the ancestor of the initialization counterpart (varI) of the blank-dimension array (varB).
		#
		# Actions at the beginning of the loop:
		#
		# If if this variable (varA) is the ancestor of a blank-dimension array variable (varB), do the following:
		#   - Look at the global speculative execution status of the blank-dimension-array variable (call it varA).
		#     - If there is no varA entry on top of the stack, then this is the first time we are dealing with it. In that case, push an entry there with all the information
		#       like which variableId, what speculative value (starting from 0 etc.). Also, save the execution state onto the Global execution state stack.
		#	  - If there is an varA entry on top of the stack, then this is NOT the first time we are dealing with it. In that case, increment the last speculative value there.
		#		Also, restore all the execution state from the Global execution state stack.
		#   
		#
		# Actions at the end of the loop:
		#
		# If if this variable (varA) is the ancestor of the initialization partner (varI) of a blank-dimension array variable (varB), do the following:
		#   - Look at the global speculative execution status of the blank-dimension-array variable (call it varA).
		#	  - If there is an varA entry on top of the stack, then we look at the status of the Initialization. 
		#		 	- It it was a success, then pop the entry and from the Global execution stack and life goes on.
		#			- If it was a failure, then do NOT pop the stack. Choose the next the ancestor sibling of this varR as the next loop index n.
		# 

		if executionStage == "Map" and blankArraysAndTerminationInfo:		# No point calling it during Interpret since then the blankArraysAndTerminationInfo{} gets created only at the end of parseCodeSnippet()
			# Find out if the current struct member is the ancestor of a blank dimensional array
			isAncestorOfBlankArray = False
			for blankDimensionArrayVariableId in getDictKeyList(blankArraysAndTerminationInfo):
				if blankDimensionArrayVariableId != blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["blankDimensionArrayVariableId"]:
					EXIT("Bad coding - blankDimensionArrayVariableId != blankArraysAndTerminationInfo[blankDimensionArrayVariableId][\"blankDimensionArrayVariableId\"]")
				partnerVariableId = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["partnerVariableId"]
				ancestorOfBlankDimensionArrayVariableId = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["siblingAncestors"][0]
				ancestorOfInitializationPartner = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["siblingAncestors"][1]
				if variableId == ancestorOfBlankDimensionArrayVariableId:
					isAncestorOfBlankArray = True
					identifierRecord = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]
					PRINT("The structMemberName",structMemberName,"(id",variableId,") is the ancestor of a blank array variable", variableDeclarations[blankDimensionArrayVariableId][0],"(id",blankDimensionArrayVariableId,") - its sibling ancestor has the variable id (",ancestorOfInitializationPartner,") that is the ancestor of the initialization partner", variableDeclarations[partnerVariableId][0],"(id",partnerVariableId,")")
					break
			if isAncestorOfBlankArray:
				if blankDimensionArrayVariableId == ancestorOfBlankDimensionArrayVariableId and partnerVariableId == ancestorOfInitializationPartner and partnerVariableId == blankDimensionArrayVariableId+1:
					PRINT("\nWe have the situation where the initialization partner is the very next sibling variable in a struct\n")
				PRINT("The current executionStateStack[] has the followin identifierRecord and speculativeValue: ")
				for row in executionStateStack:
					PRINT("identifierRecord =",row["identifierRecord"],", speculativeValue =",row["speculativeValue"])
#				if blankArrayDimensionStack:
				if executionStateStack:
#					PRINT("The top of the stack is",blankArrayDimensionStack[-1])
					PRINT("The top of the stack is",STR(executionStateStack[-1]))
#					if blankArrayDimensionStack[-1]["blankDimensionArrayVariableId"] == blankDimensionArrayVariableId:
					if executionStateStack[-1]["callerFunctionName"] != "calculateStructureLength()":
						EXIT("Coding bug in calculateStructureLength(): top of executionStateStack[] contains entry from "+executionStateStack[-1]["callerFunctionName"])
					if executionStateStack[-1]["identifierRecord"]["blankDimensionArrayVariableId"] == blankDimensionArrayVariableId:
#						speculativeValue = blankArrayDimensionStack[-1]["speculativeValue"]
						speculativeValue = executionStateStack[-1]["speculativeValue"]
#						PRINT("The top of the blankArrayDimensionStack now has the speculative array dimension of",speculativeValue,"for the blank array variable",variableDeclarations[blankDimensionArrayVariableId][0])
						PRINT("The top of the executionStateStack now has the speculative array dimension of",speculativeValue,"for the blank array variable",variableDeclarations[blankDimensionArrayVariableId][0])
#						blankArrayDimensionStack[-1]["speculativeValue"] += 1
						speculativeValue += 1
						PRINT("\n\n","///"*50,"\n","\t"*8, "speculativeValue =",speculativeValue,"\n","\\\\\\"*50,"\n\n")
						executionStateStack[-1]["speculativeValue"] = speculativeValue
						
						# Restore the Global variables, and get a copy of what the local symbol table during the previous run
						localVariables = restoreGlobalsAndReturnLocals()
						
						# Restore the local variables one by one. Since Python does not have pointers, I do not know any elegant way to overwrite local variables

						if "structName" in getDictKeyList(locals()) and "structName" in getDictKeyList(localVariables) and structName != localVariables["structName"]:
							PRINT("structName has changed - restoring it")
							structName = deepCopy(localVariables["structName"])
						if "level" in getDictKeyList(locals()) and "level" in getDictKeyList(localVariables) and level != localVariables["level"]:
							PRINT("level has changed - restoring it")
							level = deepCopy(localVariables["level"])
						if "structVariableId" in getDictKeyList(locals()) and "structVariableId" in getDictKeyList(localVariables) and structVariableId != localVariables["structVariableId"]:
							PRINT("structVariableId has changed - restoring it")
							structVariableId = deepCopy(localVariables["structVariableId"])
						if "prefix" in getDictKeyList(locals()) and "prefix" in getDictKeyList(localVariables) and prefix != localVariables["prefix"]:
							PRINT("prefix has changed - restoring it")
							prefix = deepCopy(localVariables["prefix"])
						if "offset" in getDictKeyList(locals()) and "offset" in getDictKeyList(localVariables) and offset != localVariables["offset"]:
							PRINT("offset has changed - restoring it")
							offset = deepCopy(localVariables["offset"])
						if "unraveledSupplied" in getDictKeyList(locals()) and "unraveledSupplied" in getDictKeyList(localVariables) and unraveledSupplied != localVariables["unraveledSupplied"]:
							PRINT("unraveledSupplied has changed - restoring it")
							unraveledSupplied = deepCopy(localVariables["unraveledSupplied"])
						if "ancestry" in getDictKeyList(locals()) and "ancestry" in getDictKeyList(localVariables) and ancestry != localVariables["ancestry"]:
							PRINT("ancestry has changed - restoring it")
							ancestry = deepCopy(localVariables["ancestry"])
						if "arrayAlreadyUnraveled" in getDictKeyList(locals()) and "arrayAlreadyUnraveled" in getDictKeyList(localVariables) and arrayAlreadyUnraveled != localVariables["arrayAlreadyUnraveled"]:
							PRINT("arrayAlreadyUnraveled has changed - restoring it")
							arrayAlreadyUnraveled = deepCopy(localVariables["arrayAlreadyUnraveled"])
						if "speculativeArrayDimensions" in getDictKeyList(locals()) and "speculativeArrayDimensions" in getDictKeyList(localVariables) and speculativeArrayDimensions != localVariables["speculativeArrayDimensions"]:
							PRINT("speculativeArrayDimensions has changed - restoring it")
							speculativeArrayDimensions = deepCopy(localVariables["speculativeArrayDimensions"])
						if "initResult" in getDictKeyList(locals()) and "initResult" in getDictKeyList(localVariables) and initResult != localVariables["initResult"]:
							PRINT("initResult has changed - restoring it")
							initResult = deepCopy(localVariables["initResult"])
						if "executionStage" in getDictKeyList(locals()) and "executionStage" in getDictKeyList(localVariables) and executionStage != localVariables["executionStage"]:
							PRINT("executionStage has changed - restoring it")
							executionStage = deepCopy(localVariables["executionStage"])
						if "isDynamic" in getDictKeyList(locals()) and "isDynamic" in getDictKeyList(localVariables) and isDynamic != localVariables["isDynamic"]:
							PRINT("isDynamic has changed - restoring it")
							isDynamic = deepCopy(localVariables["isDynamic"])
						if "structDetails" in getDictKeyList(locals()) and "structDetails" in getDictKeyList(localVariables) and structDetails != localVariables["structDetails"]:
							PRINT("structDetails has changed - restoring it")
							structDetails = deepCopy(localVariables["structDetails"])
						if "runtimeStatementsRelativeToComponentIndex" in getDictKeyList(locals()) and "runtimeStatementsRelativeToComponentIndex" in getDictKeyList(localVariables) and runtimeStatementsRelativeToComponentIndex != localVariables["runtimeStatementsRelativeToComponentIndex"]:
							PRINT("runtimeStatementsRelativeToComponentIndex has changed - restoring it")
							runtimeStatementsRelativeToComponentIndex = deepCopy(localVariables["runtimeStatementsRelativeToComponentIndex"])
						if "runtimeStatementsRelativeToComponentIndexStatus" in getDictKeyList(locals()) and "runtimeStatementsRelativeToComponentIndexStatus" in getDictKeyList(localVariables) and runtimeStatementsRelativeToComponentIndexStatus != localVariables["runtimeStatementsRelativeToComponentIndexStatus"]:
							PRINT("runtimeStatementsRelativeToComponentIndexStatus has changed - restoring it")
							runtimeStatementsRelativeToComponentIndexStatus = deepCopy(localVariables["runtimeStatementsRelativeToComponentIndexStatus"])
						if "trailingPadSizeBits" in getDictKeyList(locals()) and "trailingPadSizeBits" in getDictKeyList(localVariables) and trailingPadSizeBits != localVariables["trailingPadSizeBits"]:
							PRINT("trailingPadSizeBits has changed - restoring it")
							trailingPadSizeBits = deepCopy(localVariables["trailingPadSizeBits"])
						if "structSizeBytes" in getDictKeyList(locals()) and "structSizeBytes" in getDictKeyList(localVariables) and structSizeBytes != localVariables["structSizeBytes"]:
							PRINT("structSizeBytes has changed - restoring it")
							structSizeBytes = deepCopy(localVariables["structSizeBytes"])
						if "largestMemberLevelAlignmentBytes" in getDictKeyList(locals()) and "largestMemberLevelAlignmentBytes" in getDictKeyList(localVariables) and largestMemberLevelAlignmentBytes != localVariables["largestMemberLevelAlignmentBytes"]:
							PRINT("largestMemberLevelAlignmentBytes has changed - restoring it")
							largestMemberLevelAlignmentBytes = deepCopy(localVariables["largestMemberLevelAlignmentBytes"])
						if "structHasMemberLevelOrStructLevelAttributes" in getDictKeyList(locals()) and "structHasMemberLevelOrStructLevelAttributes" in getDictKeyList(localVariables) and structHasMemberLevelOrStructLevelAttributes != localVariables["structHasMemberLevelOrStructLevelAttributes"]:
							PRINT("structHasMemberLevelOrStructLevelAttributes has changed - restoring it")
							structHasMemberLevelOrStructLevelAttributes = deepCopy(localVariables["structHasMemberLevelOrStructLevelAttributes"])
						if "structHasBitFields" in getDictKeyList(locals()) and "structHasBitFields" in getDictKeyList(localVariables) and structHasBitFields != localVariables["structHasBitFields"]:
							PRINT("structHasBitFields has changed - restoring it")
							structHasBitFields = deepCopy(localVariables["structHasBitFields"])
						if "structHasBitFieldsWithMixedContainers" in getDictKeyList(locals()) and "structHasBitFieldsWithMixedContainers" in getDictKeyList(localVariables) and structHasBitFieldsWithMixedContainers != localVariables["structHasBitFieldsWithMixedContainers"]:
							PRINT("structHasBitFieldsWithMixedContainers has changed - restoring it")
							structHasBitFieldsWithMixedContainers = deepCopy(localVariables["structHasBitFieldsWithMixedContainers"])
						if "structBitFieldContainers" in getDictKeyList(locals()) and "structBitFieldContainers" in getDictKeyList(localVariables) and structBitFieldContainers != localVariables["structBitFieldContainers"]:
							PRINT("structBitFieldContainers has changed - restoring it")
							structBitFieldContainers = deepCopy(localVariables["structBitFieldContainers"])
						if "lastItemWasZeroWidthBitfield" in getDictKeyList(locals()) and "lastItemWasZeroWidthBitfield" in getDictKeyList(localVariables) and lastItemWasZeroWidthBitfield != localVariables["lastItemWasZeroWidthBitfield"]:
							PRINT("lastItemWasZeroWidthBitfield has changed - restoring it")
							lastItemWasZeroWidthBitfield = deepCopy(localVariables["lastItemWasZeroWidthBitfield"])
						if "runtimeLines" in getDictKeyList(locals()) and "runtimeLines" in getDictKeyList(localVariables) and runtimeLines != localVariables["runtimeLines"]:
							PRINT("runtimeLines has changed - restoring it")
							runtimeLines = deepCopy(localVariables["runtimeLines"])
						if "unraveledDynamicStructHeaderRowIndex" in getDictKeyList(locals()) and "unraveledDynamicStructHeaderRowIndex" in getDictKeyList(localVariables) and unraveledDynamicStructHeaderRowIndex != localVariables["unraveledDynamicStructHeaderRowIndex"]:
							PRINT("unraveledDynamicStructHeaderRowIndex has changed - restoring it")
							unraveledDynamicStructHeaderRowIndex = deepCopy(localVariables["unraveledDynamicStructHeaderRowIndex"])
						if "scope" in getDictKeyList(locals()) and "scope" in getDictKeyList(localVariables) and scope != localVariables["scope"]:
							PRINT("scope has changed - restoring it")
							scope = deepCopy(localVariables["scope"])
						if "k" in getDictKeyList(locals()) and "k" in getDictKeyList(localVariables) and k != localVariables["k"]:
							PRINT("k has changed - restoring it")
							k = deepCopy(localVariables["k"])
						if "ifConditionTruthValueAlreadyFound" in getDictKeyList(locals()) and "ifConditionTruthValueAlreadyFound" in getDictKeyList(localVariables) and ifConditionTruthValueAlreadyFound != localVariables["ifConditionTruthValueAlreadyFound"]:
							PRINT("ifConditionTruthValueAlreadyFound has changed - restoring it")
							ifConditionTruthValueAlreadyFound = deepCopy(localVariables["ifConditionTruthValueAlreadyFound"])
						if "targetLineNumber" in getDictKeyList(locals()) and "targetLineNumber" in getDictKeyList(localVariables) and targetLineNumber != localVariables["targetLineNumber"]:
							PRINT("targetLineNumber has changed - restoring it")
							targetLineNumber = deepCopy(localVariables["targetLineNumber"])
						if "skipCodeBlock" in getDictKeyList(locals()) and "skipCodeBlock" in getDictKeyList(localVariables) and skipCodeBlock != localVariables["skipCodeBlock"]:
							PRINT("skipCodeBlock has changed - restoring it")
							skipCodeBlock = deepCopy(localVariables["skipCodeBlock"])
						if "targetLineTokenList" in getDictKeyList(locals()) and "targetLineTokenList" in getDictKeyList(localVariables) and targetLineTokenList != localVariables["targetLineTokenList"]:
							PRINT("targetLineTokenList has changed - restoring it")
							targetLineTokenList = deepCopy(localVariables["targetLineTokenList"])
						if "ifConditionEvaluationResult" in getDictKeyList(locals()) and "ifConditionEvaluationResult" in getDictKeyList(localVariables) and ifConditionEvaluationResult != localVariables["ifConditionEvaluationResult"]:
							PRINT("ifConditionEvaluationResult has changed - restoring it")
							ifConditionEvaluationResult = deepCopy(localVariables["ifConditionEvaluationResult"])
						if "parseArithmeticExpressionResult" in getDictKeyList(locals()) and "parseArithmeticExpressionResult" in getDictKeyList(localVariables) and parseArithmeticExpressionResult != localVariables["parseArithmeticExpressionResult"]:
							PRINT("parseArithmeticExpressionResult has changed - restoring it")
							parseArithmeticExpressionResult = deepCopy(localVariables["parseArithmeticExpressionResult"])
						if "evaluateArithmeticExpressionResult" in getDictKeyList(locals()) and "evaluateArithmeticExpressionResult" in getDictKeyList(localVariables) and evaluateArithmeticExpressionResult != localVariables["evaluateArithmeticExpressionResult"]:
							PRINT("evaluateArithmeticExpressionResult has changed - restoring it")
							evaluateArithmeticExpressionResult = deepCopy(localVariables["evaluateArithmeticExpressionResult"])
						if "numComponentsToSkip" in getDictKeyList(locals()) and "numComponentsToSkip" in getDictKeyList(localVariables) and numComponentsToSkip != localVariables["numComponentsToSkip"]:
							PRINT("numComponentsToSkip has changed - restoring it")
							numComponentsToSkip = deepCopy(localVariables["numComponentsToSkip"])
						if "d" in getDictKeyList(locals()) and "d" in getDictKeyList(localVariables) and d != localVariables["d"]:
							PRINT("d has changed - restoring it")
							d = deepCopy(localVariables["d"])
						if "j" in getDictKeyList(locals()) and "j" in getDictKeyList(localVariables) and j != localVariables["j"]:
							PRINT("j has changed - restoring it")
							j = deepCopy(localVariables["j"])
						if "N" in getDictKeyList(locals()) and "N" in getDictKeyList(localVariables) and N != localVariables["N"]:
							PRINT("N has changed - restoring it")
							N = deepCopy(localVariables["N"])
						if "structMemberName" in getDictKeyList(locals()) and "structMemberName" in getDictKeyList(localVariables) and structMemberName != localVariables["structMemberName"]:
							PRINT("structMemberName has changed - restoring it")
							structMemberName = deepCopy(localVariables["structMemberName"])
						if "structMemberSizeBytes" in getDictKeyList(locals()) and "structMemberSizeBytes" in getDictKeyList(localVariables) and structMemberSizeBytes != localVariables["structMemberSizeBytes"]:
							PRINT("structMemberSizeBytes has changed - restoring it")
							structMemberSizeBytes = deepCopy(localVariables["structMemberSizeBytes"])
						if "isBitField" in getDictKeyList(locals()) and "isBitField" in getDictKeyList(localVariables) and isBitField != localVariables["isBitField"]:
							PRINT("isBitField has changed - restoring it")
							isBitField = deepCopy(localVariables["isBitField"])
						if "isArray" in getDictKeyList(locals()) and "isArray" in getDictKeyList(localVariables) and isArray != localVariables["isArray"]:
							PRINT("isArray has changed - restoring it")
							isArray = deepCopy(localVariables["isArray"])
						if "datatype" in getDictKeyList(locals()) and "datatype" in getDictKeyList(localVariables) and datatype != localVariables["datatype"]:
							PRINT("datatype has changed - restoring it")
							datatype = deepCopy(localVariables["datatype"])
						if "variableId" in getDictKeyList(locals()) and "variableId" in getDictKeyList(localVariables) and variableId != localVariables["variableId"]:
							PRINT("variableId has changed - restoring it")
							variableId = deepCopy(localVariables["variableId"])
						if "identifierRecord" in getDictKeyList(locals()) and "identifierRecord" in getDictKeyList(localVariables) and identifierRecord != localVariables["identifierRecord"]:
							PRINT("identifierRecord has changed - restoring it")
							identifierRecord = deepCopy(localVariables["identifierRecord"])

						PRINT("Originally the speculativeArrayDimensions was",speculativeArrayDimensions)
						speculativeArrayDimensions[0]=[speculativeValue]
						PRINT("Incremeted it to speculativeArrayDimensions =",speculativeArrayDimensions)

					else:
						# The stack is not empty, but the top entry is not what we expect. So, it is the first time; Save the current execution state
#						PRINT("The blankArrayDimensionStack[] is not empty, but the top of the blankArrayDimensionStack now has NO speculative array dimension for the blank array variable",variableDeclarations[blankDimensionArrayVariableId][0])
						PRINT("The executionStateStack[] is not empty, but the top of the executionStateStack now has NO speculative array dimension for the blank array variable",variableDeclarations[blankDimensionArrayVariableId][0])
						speculativeValue = 1
						# BUG - This is assuming that the ancestor of the blank dimensional array var is that var itself
#						speculativeArrayDimensions = [[speculativeValue]]+structDetails["components"][N][4]["arrayDimensions"][1:]		# <=== BUG 
						speculativeArrayDimensions = [[speculativeValue]]+variableDeclarations[blankDimensionArrayVariableId][4]["arrayDimensions"][1:]	

						PRINT("\n\n","///"*50,"\n","\t"*8, "speculativeValue =",speculativeValue,"\n","\\\\\\"*50,"\n\n")
						saveExecutionState(identifierRecord, speculativeValue, locals())
						executionStateStack[-1]["callerFunctionName"] = "calculateStructureLength()"
#						executionStateStack.append({{"identifierRecord":identifierRecord,"speculativeValue":speculativeValue}})
				else:		
					# The stack is empty. So, it is the first time; Save the current execution state
#					PRINT("The blankArrayDimensionStack[] is currently empty, so obviously the top of the blankArrayDimensionStack now has NO speculative array dimension for the blank array variable",variableDeclarations[blankDimensionArrayVariableId][0])
					PRINT("The executionStateStack[] is currently empty, so obviously the top of the executionStateStack now has NO speculative array dimension for the blank array variable",variableDeclarations[blankDimensionArrayVariableId][0])
#					calculateSpeculativeValueResult = calculateSpeculativeValue(calculateSpeculativeValue)
					speculativeValue = 1
					# BUG - This is assuming that the ancestor of the blank dimensional array var is that var itself
#					speculativeArrayDimensions = [[speculativeValue]]+structDetails["components"][N][4]["arrayDimensions"][1:]	# <=== BUG
					speculativeArrayDimensions = [[speculativeValue]]+variableDeclarations[blankDimensionArrayVariableId][4]["arrayDimensions"][1:]	
					PRINT("\n\n","///"*50,"\n","\t"*8, "speculativeValue =",speculativeValue,"\n","\\\\\\"*50,"\n\n")
#					saveExecutionState(locals())
					saveExecutionState(identifierRecord, speculativeValue, locals())
					executionStateStack[-1]["callerFunctionName"] = "calculateStructureLength()"
#					blankArrayDimensionStack.append({"blankDimensionArrayVariableId":variableId,"speculativeValue":speculativeValue})
			else:
				PRINT("The structMemberName",structMemberName,"is NOT the ancestor of this blank-dimension array variable", variableDeclarations[blankDimensionArrayVariableId][0],"(id", blankDimensionArrayVariableId,") or its partner")
				PRINT("The current snapshot of executionStateStack =",)
				for row in executionStateStack:
					PRINT("identifierRecord =",row["identifierRecord"],", speculativeValue =",row["speculativeValue"])

		if checkIfIntegral(structMemberSizeBytes):		# We recall that for Dynamic structs the structMemberSizeBytes is put as zero, so this will pass
			PRINT("In calculateStructureLength() during "+executionStage+": for structMemberName " + structMemberName + ", the structMemberSizeBytes value ( <"+list2plaintext(structMemberSizeBytes,"")+"> ), is already integral")
		elif isArray and structDetails["components"][N][4]["arrayDimensions"][0]==['TBD']:
			PRINT("In calculateStructureLength() during "+executionStage+": for structMemberName " + structMemberName + ", will not be able to calculate structMemberSizeBytes value by calling getRuntimeValue( <"+list2plaintext(structMemberSizeBytes,"")+"> ), but it OK since it is a blank dimensional array")
#			speculativeArrayDimensions = structDetails["components"][N][4]["arrayDimensions"][:]
		else:	
			getRuntimeValueResult = getRuntimeValue(structMemberSizeBytes)
			PRINT("For structMemberName =",structMemberName,"getRuntimeValue(structMemberSizeBytes=",structMemberSizeBytes,") is getRuntimeValueResult =",getRuntimeValueResult)
			if getRuntimeValueResult[0] == False:
				errorMessage = "ERROR in calculateStructureLength(): for structMemberName " + structMemberName + ", while calculating structMemberSizeBytes value after calling getRuntimeValue( <%s> )"%(list2plaintext(structMemberSizeBytes,""))
				errorRoutine(errorMessage)
				return False
			elif getRuntimeValueResult[1] == LOGICAL_TEST_RESULT_INDETERMINATE: 
				if executionStage == "Map":
					errorMessage = "ERROR in calculateStructureLength(): for structMemberName " + structMemberName + ", while calculating structMemberSizeBytes value after calling getRuntimeValue( <%s> )"%(list2plaintext(structMemberSizeBytes,""))
					errorRoutine(errorMessage)
					return False
				else:
					PRINT("It is OK not being able to resolve the value of structMemberSizeBytes ("+list2plaintext(structMemberSizeBytes,"")+") during ",executionStage)
			elif not checkIfIntegral(getRuntimeValueResult[1]) or getRuntimeValueResult[1] <0:
				errorMessage = "ERROR in calculateStructureLength(): for structMemberName " + structMemberName + ", while calculating structMemberSizeBytes value after calling getRuntimeValue( <%s> ) - calculated structMemberSizeBytes <%d> is not allowed"%(list2plaintext(structMemberSizeBytes,""),getRuntimeValueResult[1])
				errorRoutine(errorMessage)
				return False
			elif getRuntimeValueResult[0] == True:
				PRINT("SUCCESS in calculateStructureLength(): for structMemberName " + structMemberName + ", while calculating structMemberSizeBytes value after calling getRuntimeValue( <%s> )"%(list2plaintext(structMemberSizeBytes,"")))
				structMemberSizeBytes = getRuntimeValueResult[1]
		

		PRINT("\n\nFor n =",n,", runtimeStatementsRelativeToComponentIndex[",n,"] =",runtimeStatementsRelativeToComponentIndex[n]," = N(",N,"), which corresponds to",variableDeclarations[variableId][2])

		
		################################################################################################################
		# Alignment calculation - Exactly from where it will start to occupy (may cause leading and/or trailing padding)
		#################################################################################################################
		
		# We need to do the alignment calculation even for unions, even though all the members start from bit offset of 0. Because we need to know the size of
		# each union member (which gets potentially increased by __attribute__((aligned(m)))), and the union size is the largest member size.
		
		# 1. First, get the member's datatype's size - that is its natural alignment. For array variables, take the base datatype, not the total size of the array.
		#    For member variables that are struct, take the overall struct's alignment.
		# 2. If there is a member-level or struct-level __attribute__((packed)) statement, it tells that the compiler should start packing the member from the 
		#    first available empty space. You cannot specify a byte-boundary - it's assumed to be 1. So, __attribute__((packed)) overrides natural alignment.
		# 3. __attribute__((aligned(m)))__ overrides __attribute__((packed)) - no matter if the packed is at the struct-level at the member-level.
		#    Once again, recall that the packed doesn't come with a number.
		# 4. #pragma packed(n), when smaller, overrides __attribute__((aligned(m))). It only reduces, but never increases the aligned. So, if n > m, it is ignored.
		
		# If the member item is a struct itself, get its alignment. Recall that unless packed, a structure's alignment is its largest sized member vairable's alignment.
		
		memberAlignmentBytes = 1	# Default value in Bytes
		sanityCheckCount = 0
		
#		PRINT("\nstructDetails =",structDetails)
		
		# 1. get the "natural" alignment. We need to loop because of typedefs
		while (True):
			sanityCheckCount += 1
			PRINT("sanityCheckCount =",sanityCheckCount,", datatype =",datatype)
			if sanityCheckCount > 100:
				errorMessage = "ERROR in calculateStructureLength() - endlessly looping trying to find the alignment for this member"
				errorRoutine(errorMessage)
				return False
				
			if datatype.startswith("unsigned"):
				datatype = datatype[len("unsigned")+1:]
			elif datatype.startswith("function"): # A function pointer has a size. A function does not need any storage. Pure C does not allow structs to have functions in them.
				memberAlignmentBytes = 1		# Possible bug?
				break
			elif datatype in getDictKeyList(primitiveDatatypeLength):
				memberAlignmentBytes = primitiveDatatypeLength[datatype]
				break
			elif datatype in getDictKeyList(typedefs):
				# It typedefs into a structure/union
				if isinstance(typedefs[datatype],list) and len(typedefs[datatype])==2 and (typedefs[datatype][0] == "enum" or typedefs[datatype][0] == "struct" or typedefs[datatype][0] == "union"):
					datatype = typedefs[datatype][1]
				# It typedefs into some other regular variable declaration
				else: 
					item = typedefs[datatype]
					PRINT ("The typedef", datatype,"resolves into",item )
					if len(item) != 5:
						errorMessage = "ERROR in calculateStructureLength() - unknown tuple - exiting"
						errorRoutine(errorMessage)
						return False
					else:
						memberAlignmentBytes = typedefs[datatype][1]
						break
			elif datatype in getDictKeyList(enums):
				if "attributes" in getDictKeyList(enums[datatype]) and ALIGNED_STRING in getDictKeyList(enums[datatype]["attributes"]):
					memberAlignmentBytes = enums[datatype]["attributes"][ALIGNED_STRING]
					break
				else:
					# In C, enum sizes are not specified of at least an INT
					memberAlignmentBytes = primitiveDatatypeLength["int"]
					PRINT ("The size of Enum <",datatype,"> is assumed to be same as an Integer,",size )
					break
			elif datatype in getDictKeyList(suDict):
				structOrUnionName = datatype
				if "attributes" not in getDictKeyList(structuresAndUnions[suDict[datatype][-1]]):
					errorMessage = "ERROR in calculateStructureLength() - struc/union datatype <" + structOrUnionName + "> does not have attributes - exiting"
					errorRoutine(errorMessage)
					return False
				elif ALIGNED_STRING not in getDictKeyList(structuresAndUnions[suDict[datatype][-1]]["attributes"]):
					errorMessage = "ERROR in calculateStructureLength() - struc/union datatype <" + structOrUnionName + "> attributes does not have ALIGNED_STRING - exiting"
					errorRoutine(errorMessage)
					return False
				else:
					memberAlignmentBytes = int(structuresAndUnions[suDict[datatype][-1]]["attributes"][ALIGNED_STRING])
					break

		PRINT("For struct member",structMemberName,"of datatype",datatype, ",original memberAlignmentBytes =",memberAlignmentBytes)
		
		# 2. If there is a struct-level or member-level packed statement, that overrides this natural alignment to  byte (or 1 bit for bitfield)
		isPacked = False
		isPackedReason = ""
		if "attributes" in getDictKeyList(structDetails) and PACKED_STRING in getDictKeyList(structDetails["attributes"]):
			isPacked = True
			isPackedReason = "Struct-level packed attribute"
		if "attributes" in getDictKeyList(structDetails["components"][N][4]) and PACKED_STRING in getDictKeyList(structDetails["components"][N][4]["attributes"]):
			isPacked = True
			isPackedReason += (("" if isPackedReason == "" else "as well as ") + "Member-level packed attribute")
		# This is essentially a hack. We treat #pragma pack(n) = packed + max alignment is n only when it is a bitfield. Otherwise, it is just the max alignment.
		if isBitField and pragmaPackCurrentValue != None:
			isPacked = True
			isPackedReason += (("" if isPackedReason == "" else "as well as ") + "#pragma pack() statement")
		
		if isPacked:
			structHasMemberLevelOrStructLevelAttributes = True
			memberAlignmentBytes = 1 
			PRINT("However, ",structMemberName," is packed thanks to", isPackedReason,", hence memberAlignmentBytes =",memberAlignmentBytes)
		else:
			PRINT(structMemberName,"is NOT packed")

		memberAlignmentBits = 1 if isBitField else memberAlignmentBytes * BITS_IN_BYTE
		PRINT("After checking if",structMemberName, "is PACKED, memberAlignmentBits =",memberAlignmentBits)


		# 3. However, if there is any member-level aligned statement, that overrides this (it cannot decrease, only increase)
		if "attributes" in getDictKeyList(structDetails["components"][N][4]) and ALIGNED_STRING in getDictKeyList(structDetails["components"][N][4]["attributes"]):
			structHasMemberLevelOrStructLevelAttributes = True
			alignedBytes = structDetails["components"][N][4]["attributes"][ALIGNED_STRING]
			alignedBits = alignedBytes * BITS_IN_BYTE
			PRINT("However, there is a member-level __aligned__((",alignedBytes,")) attribute")
			memberAlignmentBytes = max(memberAlignmentBytes,alignedBytes)
			memberAlignmentBits  = max(memberAlignmentBits ,alignedBits )
			PRINT("Post-ALIGNED, New value of memberAlignmentBytes =",memberAlignmentBytes,"bytes, memberAlignmentBits =",memberAlignmentBits," bits")

		
		# 4. #pragma packed(n) overrides the maximum alignment. It only reduces, but never increases the aligned. So, if n > m, it is ignored.
		if pragmaPackCurrentValue != None:
			PRINT("There is also a #pragma pack(",pragmaPackCurrentValue,") statement.")
			memberAlignmentBytes = min(pragmaPackCurrentValue				, memberAlignmentBytes)
			memberAlignmentBits  = min(pragmaPackCurrentValue * BITS_IN_BYTE, memberAlignmentBits )
			PRINT("Post-PRAGMA-PACK, New value of memberAlignmentBytes =",memberAlignmentBytes,"bytes, memberAlignmentBits =",memberAlignmentBits," bits")
			structHasMemberLevelOrStructLevelAttributes = True

		PRINT("Before updating the struct-level alignment, memberAlignmentBytes =",memberAlignmentBytes,", largestMemberLevelAlignmentBytes = ",largestMemberLevelAlignmentBytes)

		# Update the overall struct-level alignment
		largestMemberLevelAlignmentBytes = max(memberAlignmentBytes, largestMemberLevelAlignmentBytes)
		PRINT("After checking PACKED, ALIGNED, and #PRAGMA PACK(), memberAlignmentBytes =",memberAlignmentBytes,". Hence largestMemberLevelAlignmentBytes = ",largestMemberLevelAlignmentBytes)

		# For dynamic structs during Interpret stage, don't do anything else for the member level
		if executionStage == "Interpret" and isDynamic:
			PRINT("For Dynamic struct",structName, ", not doing anything else for struct member",structMemberName,"at the member level (other than alignment calculation) since we have no clue which members will be there during execution time\n")
			n = n+1	
			continue

		# Till now, we have gotten the alignment of EVERY member, irrespective of whether the struct is regular or dynamic.
		# This is because we MUST consider EVERY struct member's alignment for calculating the overall struct alignment.
		# This means that if a dynamic struct has member variables char C,short S and int I, and only C and S gets included during runtime, 
		# the overall struct will STILL have an alignment of 4 (due to int I). This is why we calculate the alignment of EVERY struct member during Interpret.
		# So, the rest of the per-member logic will be executed only for 1) Regular structs during Interpret and 2) Dynamic structs during Map



		#####################################
		#  			   BITFIELD				#
		#####################################
		
		# We handle the bitfield slightly differently than we do non-bitfields. Even a bitfield length can be variable that is only resolvable during runtime.
		# However, once resolved, we know precisely how many bits it will occupy. This is because unlike other datatypes, a bitfield cannot be an array too.
		# On the other hand, we can have a non-bitfield struct member variable as "struct S2 s2[var];", where the struct S2 itself is a dynamic struct.
		# In such cases, it will impossible to calculate even during runtime exactly how many bytes the struct member variable will actually occupy -
		# only way is to actually add it to unraveled and then see how many new bytes were actually added.
		# For Dynamic structs, the 
		
		if isBitField:
		
			structHasBitFields = True
			
			# First we get the value of the bitFieldWidth (reall that we come here only for Regular structs during Interpret or for Dynamic structs during Map)
			bitFieldWidth = structDetails["components"][N][4]["bitFieldWidth"]	# We do not want to overwrite the original list with the value
			PRINT("For struct", structName,"member variable",structMemberName,", the bitFieldWidth = ",bitFieldWidth)
			
			if checkIfIntegral(bitFieldWidth):
				pass	# We assume that it has already passed all the checks for bitfield witdth in the parseVariableDeclaration itself
			elif not isinstance(bitFieldWidth, list):
				errorMessage = "ERROR in calculateStructureLength() - struc/union datatype <" + structOrUnionName + "> is Dynamic, but bitfield width ("+STR(bitFieldWidth)+") is neither int nor list - exiting"
				errorRoutine(errorMessage)
				return False
			else:
				getRuntimeValueResult = getRuntimeValue(bitFieldWidth)
				PRINT("getRuntimeValue(bitFieldWidth=",bitFieldWidth,") is getRuntimeValueResult =",getRuntimeValueResult)
				if getRuntimeValueResult[0] == False or getRuntimeValueResult[1] == LOGICAL_TEST_RESULT_INDETERMINATE:
					if executionStage != "Map":
						OUTPUT(variableDeclarations)
						OUTPUT(structuresAndUnions)
						dumpDetailsForDebug()
						EXIT("Should never come here for Dynamic structs during Interpret")
					errorMessage = "ERROR in calculateStructureLength(): for structMemberName " + structMemberName + ", while calculating bitFieldWidth value after calling getRuntimeValue( <%s> )"%(list2plaintext(bitFieldWidth,""))
					errorRoutine(errorMessage)
					return False
				elif not checkIfIntegral(getRuntimeValueResult[1]) or getRuntimeValueResult[1] <0:
					errorMessage = "ERROR in calculateStructureLength(): for structMemberName " + structMemberName + ", while calculating bitFieldWidth value after calling getRuntimeValue( <%s> ) - calculated bitFieldWidth <%d> is not allowed"%(list2plaintext(bitFieldWidth,""),getRuntimeValueResult[1])
					errorRoutine(errorMessage)
					return False
				elif getRuntimeValueResult[0] == True:
					PRINT("SUCCESS in calculateStructureLength(): for structMemberName " + structMemberName + ", while calculating bitFieldWidth value after calling getRuntimeValue( <%s> )"%(list2plaintext(bitFieldWidth,"")))
					bitFieldWidth = getRuntimeValueResult[1]
					structDetails["components"][N][4]["bitFieldWidth"] = bitFieldWidth
				
					# Check for valid bitfield values
					if bitFieldWidth > primitiveDatatypeLength[datatype]*BITS_IN_BYTE:
						errorMessage = "ERROR: Bitfield width of " + STR(bitFieldWidth) + "cannot be larger than the size (" + STR(primitiveDatatypeLength[datatype]) + ") of the base datatype (" +STR(datatype)+")"
						errorRoutine(errorMessage)
						return False
					elif bitFieldWidth < 0:
						errorMessage = "ERROR in calculateStructureLength(): Bitfield width of " + STR(bitFieldWidth) + "cannot be negative for bit structMemberName " + structMemberName
						errorRoutine(errorMessage)
						return False
					elif bitFieldWidth == 0 and not structMemberName.startswith(dummyUnnamedBitfieldNamePrefix):
						errorMessage = "ERROR in calculateStructureLength(): Bitfield width of " + STR(bitFieldWidth) + "cannot be 0 for bit structMemberName " + structMemberName
						errorRoutine(errorMessage)
						return False
			
			# Now we also have the bitFieldWidth value resolved. We do not try to resolve any more dynamic values like array dimensions. The reason for this is because
			# for simple dynamic array variables like "int intvar[some_other_var];", we might be able to calculate its size, but we could also have variable arrays of
			# dynamic structs, whose size is impossible to predict without actually adding to the unraveled.
			# The reason we still resolved bitFieldWidth is because we can never have arrays of bitfields.
			

			# Here, we have an positive integral value of bitFieldWidth
			
			# Also figure out if the struct has mixed storage containers (highly unusual, makes little sense, and is frowned upon)
			if structBitFieldContainers:
				for item in structBitFieldContainers:
					if item != datatype:
						structHasBitFieldsWithMixedContainers = True
						if isDynamic and structHasBitFieldsWithMixedContainers:
							errorMessage = "ERROR in calculateStructureLength() - struc/union datatype <" + structOrUnionName + "> is Dynamic, but has mixed container type for bitfields - exiting"
							errorRoutine(errorMessage)
							return False
			structBitFieldContainers.append(datatype)

			######################################################################################################################################################
			# Handle the special case where you have an enumDataType, but you do not want it to automatically treat it as integer.
			# 
			#  enum DAY {Sun, Mon, Tue, Wed, Thu, Fri, Sat};
			#
			#  struct S {
			#               char c1			:  	2;
			#				enum DAY day	:	4;
			#				char c2			:	1;
			#			};
			#
			# Enums are by default int type (signed). So, even though we only need 4 bits of an signed char, the compiler will treat the datatype of the day variable
			# as an int, and this will completely mess up the alignment and size of struct S. Ideally, it is very apparent that we want its datatype to be a CHAR, not INT.
			#
			# We solve this dilemma by looking at ALL the datatypes of the current bitfield-containing struct.
			# - If it is another enum, ignore it.
			# - If all non-enum datatypes are the same (say X), see if sizeof(X) is at least enumMinBitSize(enumDataType). If it is, choose X
			#####################################################################################################################################################
			'''
			MUST_PRINT("datatype is ",datatype)
			presumedDatatype = datatype
			if structDetails["components"][N][4]["enumType"] and structDetails["components"][N][4]["enumType"] in getDictKeyList(enums): 	#and executionStage == "Interpret":
				MUST_PRINT("Looking for other datatypes")
				nn = 0
				datatypeSet = []
				while True:
					if nn >= len(runtimeStatementsRelativeToComponentIndex):
						break
					elif checkIfIntegral(runtimeStatementsRelativeToComponentIndex[nn]):
						NN = runtimeStatementsRelativeToComponentIndex[nn]
						if structDetails["components"][NN][4]["enumType"]!=None:
							pass
						else:
							datatypeSet.append(structDetails["components"][NN][4]["datatype"])
					nn += 1
				MUST_PRINT("For bitfield struct",structName,", for variableId,",variableId,", datatypeSet =",datatypeSet)
				sameContainer = True
				if datatypeSet:
					for item in datatypeSet:
						if item != datatypeSet[0]:
							sameContainer = False
					if sameContainer:
						enumMinBitSizeResult = enumMinBitSize(structDetails["components"][N][4]["enumType"])
						if enumMinBitSizeResult != False:
							MUST_PRINT("Looking for a just enough sized container for enumMinBitSizeResult=",enumMinBitSizeResult)
							if enumMinBitSizeResult <= primitiveDatatypeLength["char"]*BITS_IN_BYTE:
								presumedDatatype = "char"
							elif enumMinBitSizeResult <= primitiveDatatypeLength["short"]*BITS_IN_BYTE:
								presumedDatatype = "short"
							elif enumMinBitSizeResult <= primitiveDatatypeLength["int"]*BITS_IN_BYTE:
								presumedDatatype = "int"
							elif enumMinBitSizeResult <= primitiveDatatypeLength["long"]*BITS_IN_BYTE:
								presumedDatatype = "long"
							elif enumMinBitSizeResult <= primitiveDatatypeLength["long long"]*BITS_IN_BYTE:
								presumedDatatype = "long long"
							else:
								EXIT("Unhandled coding case")
							MUST_PRINT("Found presumedDatatype=",presumedDatatype,"as a just enough sized container for enumMinBitSizeResult=",enumMinBitSizeResult)
							if datatypeSet[0] in ("char", "short", "int", "long", "long long") and primitiveDatatypeLength[datatypeSet[0]]*BITS_IN_BYTE >= enumMinBitSizeResult:
								presumedDatatype = datatypeSet[0]
								MUST_PRINT("We are overriding the container type for variableId",variableId,"as ",presumedDatatype)
								MUST_PRINT("Also, we are changing the original value of structMemberSizeBytes =",structMemberSizeBytes)
								structMemberSizeBytes = primitiveDatatypeLength[datatypeSet[0]]
								MUST_PRINT("We are overriding the container type for variableId",variableId,"as ",presumedDatatype," and structMemberSizeBytes to",structMemberSizeBytes)
							else:
								MUST_PRINT("Even though the only other non-enum datatype is",datatypeSet[0],", we cannot override the container type for variableName",variableName,"since it requires",presumedDatatype,", which is bigger in size than",datatypeSet[0])
			'''					

			#######################################################################################################################################################
			## Calculating where to start this bitfield from (bitOffsetWithinStruct). We will also update the structSizeBytes and trailingPadSizeBits accordingly
			#######################################################################################################################################################

			# From here, we have integral bitFieldWidth.

			# For zero-width bitfields, just reset the flag and don't do anything else
			if bitFieldWidth == 0:
				lastItemWasZeroWidthBitfield = True
				n = n+1	
				continue

			naturalSizeBytes = structMemberSizeBytes	# This will be the bitfield container size
			if isPacked:
				naturalSizeBytes = 1	# We are lowering the size to a byte, but NOT the alignment
				PRINT("In fact,",structMemberName," is a packed bitfield, so naturalSizeBytes =",naturalSizeBytes)
			else:
				PRINT(structMemberName,"is NOT a packed bitfield, so naturalSizeBytes =",naturalSizeBytes)
			PRINT("For structMemberName",structMemberName,", naturalSizeBytes = ",naturalSizeBytes,", memberAlignmentBytes =",memberAlignmentBytes)
			effectiveSizeBytes = max(naturalSizeBytes, memberAlignmentBytes)
			
			if len(executedStructMemberIndex)==1 or structDetails["type"]=="union":
				bitOffsetWithinStruct = 0
				structSizeBytes = max(structSizeBytes,effectiveSizeBytes)
				trailingPadSizeBits = structSizeBytes * BITS_IN_BYTE - bitFieldWidth 		# It's no use for unions, only for structs
			else:
				# We need 3 pieces of information for calculating where this bitfield will start from:
				# 1. effectiveSizeBytes: How big is the bitfield. It is impacted by its container size, PACKED and ALIGNED.
				# 2. structSizeBytes: The current struct size after filling the previous member.
				# 3. trailingPadSizeBits: Out of structSizeBytes*8 bits, how much is trailing pads. 
				
				# Find out the first available unfilled bit. Starts from bit # 0.
				firstUnfilledBitNumber = structSizeBytes * BITS_IN_BYTE - trailingPadSizeBits # This trailingPadSizeBits was calculated by the previous struct member in previous iteration
				firstUnfilledBitNumberAligned = alignedOnOrAfter(firstUnfilledBitNumber, memberAlignmentBits) # Careful - this might be AFTER the struct size
				
				PRINT("For Bitfield structMemberName = ",structMemberName, "structSizeBytes =",structSizeBytes,"(",structSizeBytes * BITS_IN_BYTE," bits), trailingPadSizeBits = ",trailingPadSizeBits,", firstUnfilledBitNumber =",firstUnfilledBitNumber)
				
				# If there is no ALIGNED(m), and basically we have the liberty to fill the member from whichever bit we want, then it is simple (except when we have mixed containers)
				
				if not lastItemWasZeroWidthBitfield:
				
					PRINT("We can start packing",structMemberName,"right from the first available bit aligned to",memberAlignmentBits,"bits, which is bit#", firstUnfilledBitNumberAligned)
					
					# If it is packed, just don't care how much bits are left in the current container. If it spills over, add another byte, not another effectiveSizeBytes
					if isPacked:
					
						PRINT(structMemberName,"can be packed without worrying about if it would spill to another container")
						bitOffsetWithinStruct = firstUnfilledBitNumberAligned
						currentMemberEndsAtBitNumberInclusive = firstUnfilledBitNumberAligned + bitFieldWidth - 1
						PRINT(structMemberName,"starts and ends at bit numbers <",bitOffsetWithinStruct,",",currentMemberEndsAtBitNumberInclusive,"(inclusive)>")
						# If we could accommodate the full member within the leading pad, then structSizeBytes is unchanged
						if currentMemberEndsAtBitNumberInclusive < structSizeBytes * BITS_IN_BYTE:
							PRINT("The current member",structMemberName,"of bitfield width", bitFieldWidth,"could be accommodated within the", trailingPadSizeBits,"bits of trailing pads itself")
							trailingPadSizeBits = trailingPadSizeBits - bitFieldWidth
							PRINT("After filling",structMemberName,"of bitfield width", bitFieldWidth,", the new value of trailingPadSizeBits =", trailingPadSizeBits)
							PRINT(structMemberName,"starts and ends at bit numbers <",bitOffsetWithinStruct,"(",bit2ByteAndBit(bitOffsetWithinStruct),"),",currentMemberEndsAtBitNumberInclusive,"(",bit2ByteAndBit(currentMemberEndsAtBitNumberInclusive),") (inclusive)>")
							PRINT("The structSizeBytes is still",structSizeBytes,"(",structSizeBytes * BITS_IN_BYTE," bits") 
							PRINT("\n","==="*50,"\n")
						else:
							PRINT("The current bitfield member",structMemberName,"of", bitFieldWidth,"bits width could NOT be accommodated within the", trailingPadSizeBits,"bits of trailing pads itself")
							extraBitsReqd = currentMemberEndsAtBitNumberInclusive + 1 - structSizeBytes * BITS_IN_BYTE
							extraBytesReqd = integerDivision(extraBitsReqd, BITS_IN_BYTE) if extraBitsReqd % BITS_IN_BYTE == 0 else integerDivision(extraBitsReqd, BITS_IN_BYTE) + 1
							PRINT("Need to add",extraBytesReqd,"bytes to the structSizeBytes =",structSizeBytes)
							structSizeBytes += extraBytesReqd					# We are updating the structSizeBytes to the new value
							trailingPadSizeBits = structSizeBytes * BITS_IN_BYTE - currentMemberEndsAtBitNumberInclusive - 1
							PRINT("After filling",structMemberName,"of bitfield width", bitFieldWidth,", the new value of trailingPadSizeBits =", trailingPadSizeBits)
							PRINT(structMemberName,"starts and ends at bit numbers <",bitOffsetWithinStruct,"(",bit2ByteAndBit(bitOffsetWithinStruct),"),",currentMemberEndsAtBitNumberInclusive,"(",bit2ByteAndBit(currentMemberEndsAtBitNumberInclusive),") (inclusive)>")
							PRINT("The new value of structSizeBytes is",structSizeBytes,"(",structSizeBytes * BITS_IN_BYTE," bits)") 
							PRINT("\n","==="*50,"\n")
							
					else:	# Not packed; need to be careful about staying within contaner boundary. Add effectiveSizeBytes if spills over to a new container
					
						PRINT(structMemberName,"can NOT be packed without worrying about if it would spill to another container")
						# First look back and find the closest bit that matches the current member alignment. If it is first available bit itself, take appropriate actions.
						if firstUnfilledBitNumberAligned == structSizeBytes * BITS_IN_BYTE:
							bitOffsetWithinStruct = firstUnfilledBitNumberAligned
							structSizeBytes += effectiveSizeBytes
						else:
							# First, there is no guarantee that the current container will match the previous container. So, one must first bring up the structSizeBytes if needed
							# to align to at least the current container.
							lastBitAlignedToNaturalSize = firstUnfilledBitNumber - firstUnfilledBitNumber % (effectiveSizeBytes * BITS_IN_BYTE)
							newMinimumStructSizeBits = lastBitAlignedToNaturalSize + effectiveSizeBytes * BITS_IN_BYTE
							if newMinimumStructSizeBits > structSizeBytes * BITS_IN_BYTE:
								PRINT("The existing structSizeBytes =",structSizeBytes,"does not align to the", datatype," and/or its corresponding effectiveSizeBytes =",effectiveSizeBytes)
								structSizeBytes = bit2Byte(newMinimumStructSizeBits)
								PRINT("Hence increased it to structSizeBytes =",structSizeBytes,"that does align to the", datatype,", alignment =",effectiveSizeBytes,"bytes" )
							# Even though firstUnfilledBitNumberAligned > firstUnfilledBitNumber, the bits between them is unusable
							bitsUsedWithinNaturalSizeAlignment = firstUnfilledBitNumberAligned - lastBitAlignedToNaturalSize
							maxBitsAvailableWithinNaturalSizeAlignment = effectiveSizeBytes * BITS_IN_BYTE - bitsUsedWithinNaturalSizeAlignment
							PRINT("Looking backwards, lastBitAlignedToNaturalSize =",lastBitAlignedToNaturalSize,"is the bit number that aligns to the effective size of",effectiveSizeBytes,"bytes")
							PRINT("Starting from bit #",lastBitAlignedToNaturalSize,"a total of bitsUsedWithinNaturalSizeAlignment =",bitsUsedWithinNaturalSizeAlignment,"bits have already been filled, leaving",maxBitsAvailableWithinNaturalSizeAlignment,"bits ready for use")
							# Now, the problem is that
							if bitFieldWidth > maxBitsAvailableWithinNaturalSizeAlignment:	# Need to start a new container
								# 	Suppose we are dealing with a struct like:
								#   struct S1{				MSb	=============================================================== LSb
								#              	char c1:7; 				    	       									   01111111	structSizeBytes = 1, trailingPadSizeBits = 1
								#              	char c2:7;                    							 		  01111111 01111111	structSizeBytes = 2, trailingPadSizeBits = 1
								#              	char c3:5; 		     									 00011111 01111111 01111111	structSizeBytes = 3, trailingPadSizeBits = 3
								#				int  i1:12;	00000000 00000000 00001111 11111111 00000000 01111111 01111111 01111111	structSizeBytes = 4, trailingPadSizeBits = 9
								#   };
								# In the above case, when we are trying to fit i1 (12 bits), even when we added a fourth byte to structSizeBytes so that overall it aligns to
								# to an integer boundary, the effective trailing pad = 11 bits (not enough). So, we needed to add a whole new 4 bytes.
								PRINT("Unfortunlately, bitFieldWidth (",bitFieldWidth,"bits) > maxBitsAvailableWithinNaturalSizeAlignment (",maxBitsAvailableWithinNaturalSizeAlignment,"bits)")
								bitOffsetWithinStruct = lastBitAlignedToNaturalSize + effectiveSizeBytes * BITS_IN_BYTE
								PRINT("Hence adding a new container of effectiveSizeBytes =",effectiveSizeBytes, "bytes to the current structSizeBytes =",structSizeBytes)
								structSizeBytes += effectiveSizeBytes
								PRINT("The new value of structSizeBytes =",structSizeBytes)
							else: # No need to start a new container
								# 	Suppose we are dealing with a struct like:
								#   struct S1{				MSb	=========================== LSb
								#              	char c1:7; 				    	       01111111	structSizeBytes = 1, trailingPadSizeBits = 1
								#              	char c2:7;                    01111111 01111111	structSizeBytes = 2, trailingPadSizeBits = 1
								#              	char c3:5; 		     00011111 01111111 01111111	structSizeBytes = 3, trailingPadSizeBits = 3
								#				int  i1:2;	00000000 01111111 01111111 01111111	structSizeBytes = 4, trailingPadSizeBits = 9
								#   };
								# In the above case, when we are trying to fit i1 (2 bits), it fits within the third byte. Yet,  we added a fourth byte to structSizeBytes 
								# so that overall it aligns to an integer boundary. 
								PRINT("Fortunlately, bitFieldWidth (",bitFieldWidth,"bits) <= maxBitsAvailableWithinNaturalSizeAlignment (",maxBitsAvailableWithinNaturalSizeAlignment,"bits)")
								bitOffsetWithinStruct = firstUnfilledBitNumberAligned
								PRINT("Hence we do not need to add another",effectiveSizeBytes,"-byte-sized",datatype,"container")
								PRINT("The structSizeBytes =",structSizeBytes,"does not need to be changed")
				else:	# Last bit was a zero-width bitfield
					bitOffsetWithinStruct = alignedOnOrAfter(firstUnfilledBitNumber, effectiveSizeBytes * BITS_IN_BYTE)
				
			
			#Common for all bitfield
			PRINT("Hence the new bitOffsetWithinStruct =",bitOffsetWithinStruct)
			currentMemberEndsAtBitNumberInclusive = bitOffsetWithinStruct + bitFieldWidth - 1
			trailingPadSizeBits = structSizeBytes * BITS_IN_BYTE - currentMemberEndsAtBitNumberInclusive - 1
			PRINT(structMemberName,"starts and ends at bit numbers <",bitOffsetWithinStruct,"(",bit2ByteAndBit(bitOffsetWithinStruct),"),",currentMemberEndsAtBitNumberInclusive,"(",bit2ByteAndBit(currentMemberEndsAtBitNumberInclusive),") (inclusive)>")
			PRINT("After filling the bitfield <",datatype,structMemberName,":", bitFieldWidth,">, the new value of trailingPadSizeBits =", trailingPadSizeBits)
			structDetails["components"][N][4]["bitOffsetWithinStruct"] = bitOffsetWithinStruct
			structDetails["components"][N][4]["offsetWithinStruct"] = integerDivision(bitOffsetWithinStruct,BITS_IN_BYTE)
			PRINT("The new value of structSizeBytes is",structSizeBytes,"(",structSizeBytes * BITS_IN_BYTE," bits)") 
			PRINT("\n","==="*50,"\n")

			# For dynamic structs, we add it to the unraveled for each struct member (remember that this routine gets called during map ONLY for dynamic structures)
			if executionStage == "Map":
				PRINT("From calculateStructureLength(), invoking addVariableToUnraveled()")
				PRINT("\nInput to addVariableToUnraveled() - level =",level+1, ", variableId =", variableId, "(",variableDeclarations[variableId][0], ", prefix =",prefix, ", offset =",offset,"ancestry =",STR(ancestry),", arrayAlreadyUnraveled =","True, " if arrayAlreadyUnraveled else "False, ",", speculativeArrayDimensions =", "None" if not speculativeArrayDimensions else STR(speculativeArrayDimensions))
				# For bitfield, we do not supply the offset+offsetWithinStructBytes, just the offset. Because inside addVariableToUnraveled it will figure it out.
#				addVariableToUnraveledResult = addVariableToUnraveled(level+1, variableId, prefix, offset+offsetWithinStructBytes, unraveledSupplied, ancestry+[variableId], False) #, speculativeArrayDimension)
#				addVariableToUnraveledResult = addVariableToUnraveled(level+1, variableId, prefix, offset, unraveledSupplied, ancestry+[variableId], False, speculativeArrayDimension)	# BUG????
				addVariableToUnraveledResult = addVariableToUnraveled(level+1, structDetails["components"][N][4], prefix, offset, unraveledSupplied, ancestry, False, speculativeArrayDimensions)
				if addVariableToUnraveledResult == False:
					errorMessage = "ERROR in calculateStructureLength() after calling addVariableToUnraveled("+STR(level+1)+", "+ STR(variableId) + ", " + prefix + ", "+STR(offset)+", unraveledSupplied, "+STR(ancestry+[variableId])+", False)"
					errorRoutine(errorMessage)
					return False
				else:
					unraveledSupplied = addVariableToUnraveledResult[0]
					initResult = False if initResult == False else addVariableToUnraveledResult[1] if addVariableToUnraveledResult[1] in (True, False) else initResult


				# Below for non-bitfield variables, we need to call the minOrMaxValueInColumn() routine to figure out exactly how many new bytes did this struct member added.
				# However, for bitfield variable, we do not need to do that, since we already knew that beforehand, even before adding it to unraveled.
				
		#####################################
		#  			NON-BITFIELD			#
		#####################################
		
		else: # Not bitfield; regular struct member
		
			# Step 1. Find the offset withint the struct where it will be added
			if len(executedStructMemberIndex)==1 or structDetails["type"]=="union":
				bitOffsetWithinStruct = 0
				offsetWithinStructBytes = 0
			else:
				trailingPadSizeBytes = integerDivision((trailingPadSizeBits - (trailingPadSizeBits % BITS_IN_BYTE)), BITS_IN_BYTE)
				PRINT("The trailing pad size is",trailingPadSizeBits,"bits, or FULL", trailingPadSizeBytes,"bytes, with possible few (<8) bits extra")
				# See if we can fit it in current member of effectiveSizeBytes within the trailing pads
				
				# Both structSizeBytes and previousMemberEndedAtSizeBytes represent SIZE. Thet are NOT byte numbers. Hence they do not start from 0, they start from 1.
				# The byte numbering is 0, 1, 2 like this. But, if the byte 0 is filled, the size is not 0 - it is 1. Hence, the size numbering must start from 1.
				# Remember that structSizeBytes is total NUMBER of bytes that the struct is currently occupying. For example, if the first member is a short, structSizeBytes = 2
				# For previousMemberEndedAtSizeBytes, the size numbering is like 1, 2, 3 (NOT 0, 1, 2). Remember that this is NOT byte numbering, this is SIZE.
				previousMemberEndedAtSizeBytes = structSizeBytes - trailingPadSizeBytes 	# This trailingPadSizeBytes was calculated by the previous struct member in previous iteration
				
				PRINT ("Although currently structSizeBytes =",structSizeBytes,"trailingPadSizeBytes =",trailingPadSizeBytes,"which means previousMemberEndedAtSizeBytes =",previousMemberEndedAtSizeBytes, ", essentially at byte #",previousMemberEndedAtSizeBytes-1)
				
				# First find out exactly where the current member data starts
				leadingPadSizeBytes = 0 if previousMemberEndedAtSizeBytes % memberAlignmentBytes == 0 else memberAlignmentBytes - (previousMemberEndedAtSizeBytes % memberAlignmentBytes)
				# Remember that offsetWithinStructBytes starts from 0, not 1
				offsetWithinStructBytes = previousMemberEndedAtSizeBytes + leadingPadSizeBytes
				PRINT ("For previousMemberEndedAtSizeBytes =",previousMemberEndedAtSizeBytes,"memberAlignmentBytes =",memberAlignmentBytes,"leadingPadSizeBytes =",leadingPadSizeBytes,", resulting in offsetWithinStructBytes =",offsetWithinStructBytes)

			# Step 2. For dynamic structs, we add it to the unraveled for each struct member (remember that this routine gets called during map ONLY for dynamic structures)
			#         Recall that for Dynamic structs, the structMemberSizeBytes in variableDeclarations and component entry is zero, but that value is not really true.
			#		  If we want to know the true value of structMemberSizeBytes for a dynamic variable, there no way to know it during Interpret stage, and even during the
			#         Map stage,  the only way to get the true value of structMemberSizeBytes is to actually add it to unraveled and see how many new bytes got added.
			if executionStage == "Map":
#				findHardcodedDataInFile
				PRINT("From calculateStructureLength(), invoking addVariableToUnraveled()")
				PRINT("\nInput to addVariableToUnraveled() - level =",level+1, ", variableId =", variableId, "(",variableDeclarations[variableId][0], ", prefix =",prefix, ", offset =",offset,"ancestry =",STR(ancestry),", arrayAlreadyUnraveled =","True, " if arrayAlreadyUnraveled else "False, ",", speculativeArrayDimensions =", "None" if not speculativeArrayDimensions else STR(speculativeArrayDimensions))
#				addVariableToUnraveledResult = addVariableToUnraveled(level+1, variableId, prefix, offset+offsetWithinStructBytes, unraveledSupplied, ancestry+[variableId], False, speculativeArrayDimension)	# BUG?
				addVariableToUnraveledResult = addVariableToUnraveled(level+1, structDetails["components"][N][4], prefix, offset+offsetWithinStructBytes, unraveledSupplied, ancestry, False, speculativeArrayDimensions)
				if addVariableToUnraveledResult == False:
					errorMessage = "ERROR in calculateStructureLength() after calling addVariableToUnraveled("+STR(level+1)+", "+ STR(variableId) + ", " + prefix + ", "+STR(offset + offsetWithinStructBytes)+", unraveledSupplied, "+STR(ancestry+[variableId])+", False)"
					errorRoutine(errorMessage)
					return False
				else:
					unraveledSupplied = addVariableToUnraveledResult[0]
					initResult = False if initResult == False else addVariableToUnraveledResult[1] if addVariableToUnraveledResult[1] in (True, False) else initResult
					
				minOrMaxValueInColumnResult = minOrMaxValueInColumn(unraveledSupplied, 4, "max")	# The Addr end (exclusive) is the column #4 in unraveled
				if minOrMaxValueInColumnResult[0] != True:
					errorMessage = "ERROR in calculateStructureLength() - for variable " + structMemberName + ", could not calculate the max end addr"
					errorRoutine(errorMessage)
					OUTPUT("\nunraveledSupplied =")
					for row in unraveledSupplied:
						OUTPUT(row)
					return False
				else:
					maxEndAddrInUnraveledSupplied = minOrMaxValueInColumnResult[1]
					newBytesAdded = maxEndAddrInUnraveledSupplied - (offset+offsetWithinStructBytes)
					PRINT("For Dynamic struct "+ structName +" member variable " + structMemberName + " of type "+ datatype+", the structMemberSizeBytes = "+STR(structMemberSizeBytes)+", while the number of new bytes it aded to unraveled (newBytesAdded) = "+STR(newBytesAdded))
					# If the struct member type itself is a dynamic struct, then get its true size from the unraveled
					# Do NOT trust the structMemberSizeBytes noted in structuresAndUnions, because for Dynamic structs it is put there as zero.
					if datatype in getDictKeyList(suDict) and structuresAndUnions[suDict[datatype][-1]]["isDynamic"]:
						structMemberSizeBytes = newBytesAdded
					# Also, for blank-dimension arrays, its structMemberSizeBytes is not resolved yet, so don't trust that either
					elif not checkIfIntegral(structMemberSizeBytes):
						structMemberSizeBytes = newBytesAdded
					elif checkIfIntegral(structMemberSizeBytes) and newBytesAdded != structMemberSizeBytes:
						errorMessage = "ERROR in calculateStructureLength() - for Dynamic struct "+ structName +" member variable " + structMemberName + " of type "+ datatype+", the structMemberSizeBytes = "+STR(structMemberSizeBytes)+", but newBytesAdded = "+STR(newBytesAdded)
						errorRoutine(errorMessage)
						return False

			# Step 3. Once we know the size of the added variable (it could very well be as bad as an array of dynamic structs), so we could not know its size beforehand
			
			# Find the natural size
			naturalSizeBytes = structMemberSizeBytes
			PRINT(structMemberName,"is NOT a packed bitfield, so naturalSizeBytes =",naturalSizeBytes)
			
			# Once we know the alignment, calculate its effective size. It must be at least as big as the natural size (except for non-packed bitfields), otherwise we will lose data
			# For bitfields, when it is packed, the natural size defaults to 1 byte, irrespective of whether the container is char/short/int/long etc.
			PRINT("For structMemberName",structMemberName,", naturalSizeBytes = ",naturalSizeBytes,", memberAlignmentBytes =",memberAlignmentBytes)
			effectiveSizeBytes = max(naturalSizeBytes, memberAlignmentBytes)

			PRINT("After processing all the attributes for struct member",structMemberName,"of original naturalSizeBytes =",naturalSizeBytes,"and effectiveSizeBytes =",effectiveSizeBytes,"and member-level alignment =",memberAlignmentBytes,", set largestMemberLevelAlignmentBytes = ",largestMemberLevelAlignmentBytes) 

			currentMemberRealDataEndByte  = offsetWithinStructBytes + structMemberSizeBytes	# thanks to an aligned(m), a member's size may artifically increase. This is where real data ends
			PRINT("For",structName, "member variable",structMemberName,", set currentMemberRealDataEndByte (",currentMemberRealDataEndByte,") = offsetWithinStructBytes (",offsetWithinStructBytes,") + structMemberSizeBytes (",structMemberSizeBytes,")")
			currentMemberAlignmentEndByte = offsetWithinStructBytes + effectiveSizeBytes
			PRINT("For",structName, "member variable",structMemberName,", set currentMemberAlignmentEndByte (",currentMemberAlignmentEndByte,") = offsetWithinStructBytes (",offsetWithinStructBytes,") + effectiveSizeBytes (",effectiveSizeBytes,")")
			PRINT("structSizeBytes = max(structSizeBytes =",structSizeBytes,", currentMemberAlignmentEndByte =",currentMemberAlignmentEndByte,")")
			structSizeBytes = max(structSizeBytes, currentMemberAlignmentEndByte)
			PRINT("New value of structSizeBytes =",structSizeBytes)
			
			# MUST NOT define trailingPadSizeBytes before this since it will be used by the next struct member in next iteration
			# Right in this statement below, we are OVERWRITING the trailingPadSizeBytes
			trailingPadSizeBytes = structSizeBytes - currentMemberRealDataEndByte
			trailingPadSizeBits = trailingPadSizeBytes * BITS_IN_BYTE
			PRINT("Reset the trailing pad to",trailingPadSizeBits,"bits, or",trailingPadSizeBytes,"bytes")

			# Update within the main structure dictionary from which bit number this struct is starting
			bitOffsetWithinStruct = offsetWithinStructBytes * BITS_IN_BYTE
			structDetails["components"][N][4]["bitOffsetWithinStruct"] = bitOffsetWithinStruct
			structDetails["components"][N][4]["offsetWithinStruct"] = offsetWithinStructBytes
			PRINT("Updated the bitOffsetWithinStruct =",bitOffsetWithinStruct,"bits, and offsetWithinStruct =",offsetWithinStructBytes,"bytes")

		lastItemWasZeroWidthBitfield = False
		
		# Actions at the end of the loop:
		#
		# If if this variable (varA) is the ancestor of the initialization partner (varI) of a blank-dimension array variable (varB), do the following:
		#   - Look at the global speculative execution status of the blank-dimension-array variable (call it varA).
		#	  - If there is an varA entry on top of the stack, then we look at the status of the Initialization. 
		#		 	- It it was a success, then pop the entry and from the Global execution stack and life goes on.
		#			- If it was a failure, then do NOT pop the stack. Choose the next the ancestor sibling of this varR as the next loop index n.
		# 
		if executionStage == "Map" and blankArraysAndTerminationInfo: 
			isAncestorOfInitializationPartner = False
			for blankDimensionArrayVariableId in getDictKeyList(blankArraysAndTerminationInfo):
				if blankDimensionArrayVariableId != blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["blankDimensionArrayVariableId"]:
					EXIT("Bad coding - blankDimensionArrayVariableId != blankArraysAndTerminationInfo[blankDimensionArrayVariableId][\"blankDimensionArrayVariableId\"]")
				partnerVariableId = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["partnerVariableId"]
				ancestorOfBlankDimensionArrayVariableId = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["siblingAncestors"][0]
				ancestorOfInitializationPartner = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["siblingAncestors"][1]
				if variableId == ancestorOfInitializationPartner:
					identifierRecord = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]
					isAncestorOfInitializationPartner = True
					PRINT("The structMemberName",structMemberName,"(id",variableId,") is the ancestor of an initialization partner",variableDeclarations[partnerVariableId][0],"(id",partnerVariableId,") of a blank array variable", variableDeclarations[blankDimensionArrayVariableId][0],"(id",blankDimensionArrayVariableId,")")
					break
			if isAncestorOfInitializationPartner:
#				PRINT("The current blankArrayDimensionStack = ",blankArrayDimensionStack)
				if initResult == True:
					PRINT("The initialization succeeded")
					if not executionStateStack:
						errorMessage = "ERROR in calculateStructureLength() - for variable " + structMemberName + ", the initResult is a success, but the executionStateStack[] is empty - to pop"
						errorRoutine(errorMessage)
						return False
					elif executionStateStack[-1]["identifierRecord"] != identifierRecord:
						errorMessage = "ERROR in calculateStructureLength() - for variable " + structMemberName + ", the initResult is a success, and the executionStateStack[] is NOT empty either, but the top of the execution stack does not match the identifier record - it has a value of "+STR(executionStateStack[-1]["identifierRecord"])
						errorRoutine(errorMessage)
						return False
					else:
						PRINT("for variable ", structMemberName, ", the initResult is a success, and the executionStateStack[] is NOT empty either, and the top of the execution stack also matches the identifier record - it has a value of ",STR(executionStateStack[-1]["identifierRecord"]))
						PRINT("Now going to pop the executionStateStack manually")
						executionStateStack.pop()
				elif initResult == False:		
					PRINT("The initialization failed - need to go back to the loop structMember variable", variableDeclarations[ancestorOfBlankDimensionArrayVariableId][0],"(id =",ancestorOfBlankDimensionArrayVariableId,")")
					# Find its blank variable counterpart
					goBackTarget = None
					for k in runtimeStatementsRelativeToComponentIndex:
						if checkIfIntegral(runtimeStatementsRelativeToComponentIndex[k]): 
							if structDetails["components"][runtimeStatementsRelativeToComponentIndex[k]][4]["variableId"]==ancestorOfBlankDimensionArrayVariableId:
								goBackTarget = k
								break
					if goBackTarget == None:
						EXIT("Coding bug in calculateStructureLength() - cannot find structMember variable "+ variableDeclarations[ancestorOfBlankDimensionArrayVariableId][0]+" (id = "+STR(ancestorOfBlankDimensionArrayVariableId)+")")
					else:
						PRINT("\nLooping back to n=",goBackTarget,"\n\n")
						n = goBackTarget
						continue
				elif initResult == None:
					EXIT("Coding bug in calculateStructureLength() - initResult should not be None here.")
				else:
					EXIT("Coding bug in calculateStructureLength() - invalid initResult = ", initResult)
		
		n = n+1
		# This is the end of the code body that loops over all the members of the struct

	# After processing ALL the members for a struct
	# We are done with the member-level calculations. Let's do struct-level end-processing
	structLevelAlignmentFinal = largestMemberLevelAlignmentBytes
	PRINT("After processing all members of this struct, largestMemberLevelAlignmentBytes =",largestMemberLevelAlignmentBytes)
	
	# Now perform struct-level alignment. If there is a struct-level aligned specified, that may increase the member-level alignment.
	if ALIGNED_STRING in getDictKeyList(structDetails["attributes"]):
		structLevelAlignmentSpecified = structDetails["attributes"][ALIGNED_STRING]
		PRINT("However, there is a struct-level alignment specified =",structLevelAlignmentSpecified)
		if structLevelAlignmentSpecified > structLevelAlignmentFinal:
			PRINT("largestMemberLevelAlignmentBytes (",largestMemberLevelAlignmentBytes,") overridden by structLevelAlignmentSpecified(",structLevelAlignmentSpecified,")")
			structLevelAlignmentFinal = structLevelAlignmentSpecified
		else:
			PRINT("largestMemberLevelAlignmentBytes (",largestMemberLevelAlignmentBytes,") not overridden by structLevelAlignmentSpecified(",structLevelAlignmentSpecified,")")
			
	#pragma packed(n) overrides the maximum alignment. It only reduces, but never increases the aligned. So, if n > m, it is ignored.
	if pragmaPackCurrentValue != None:
		if pragmaPackCurrentValue < structLevelAlignmentFinal:
			PRINT("structLevelAlignmentFinal (",structLevelAlignmentFinal,") overridden by pragmaPackCurrentValue(",pragmaPackCurrentValue,")")
			structLevelAlignmentFinal = pragmaPackCurrentValue
		else:
			PRINT("structLevelAlignmentFinal (",structLevelAlignmentFinal,") NOT overridden by pragmaPackCurrentValue(",pragmaPackCurrentValue,")")

	if "attributes" in getDictKeyList(structDetails):	# Should always happen
		if ALIGNED_STRING in getDictKeyList(structDetails["attributes"]):
			PRINT("structDetails[\"attributes\"][ALIGNED_STRING] already exists",structDetails["attributes"])
			PRINT("Overwriting its current value (",structDetails["attributes"][ALIGNED_STRING],") with new structLevelAlignmentFinal value = ",structLevelAlignmentFinal)
			structDetails["attributes"][ALIGNED_STRING] = structLevelAlignmentFinal
		else:
			PRINT("structDetails[\"attributes\"][ALIGNED_STRING] did not exist in",structDetails["attributes"])
			PRINT("Setting it to structLevelAlignmentFinal value = ",structLevelAlignmentFinal)
			structDetails["attributes"][ALIGNED_STRING] = structLevelAlignmentFinal
	else:	# Should never happen, since now we are adding even a blank entry for attributes
		EXIT("Should never happen, since now we are adding even a blank entry for attributes")
		PRINT("structDetails[\"attributes\"] did not exist")
		PRINT("Setting it to {ALIGNED_STRING: structLevelAlignmentFinal value (",structLevelAlignmentFinal,") }")
		attributes = {ALIGNED_STRING:structLevelAlignmentFinal}
		structDetails["attributes"] = attributes
		
	PRINT ("After completing processing for struct/union",structName, ", struct-level attribute =", structDetails["attributes"])
	

	if structSizeBytes % structLevelAlignmentFinal != 0:
		EndStructPadding = (structLevelAlignmentFinal - structSizeBytes % structLevelAlignmentFinal)
		PRINT("Adding",EndStructPadding,"bytes to align structSizeBytes =",structSizeBytes,"bytes to struct-level alignment of",structLevelAlignmentFinal,"bytes")
		structSizeBytes += EndStructPadding
	else:
		PRINT("No end-struct padding needed to align structSizeBytes =",structSizeBytes, "bytes to struct-level alignment of",structLevelAlignmentFinal,"bytes")
	PRINT("\n","==="*50,"\nEnd processing ",structName,"during",executionStage,", Final structSizeBytes =",structSizeBytes,"structLevelAlignmentFinal =",structLevelAlignmentFinal, "\n","==="*50)
	
	structDetails["size"] = structSizeBytes
	
	PRINT ("structuresAndUnions[suDict[",structName,"][-1]][\"size\"]=", structDetails["size"] )
	
	# We want to note down if the structure contains bitfields with different containers, or with different attributes.
	structDetails["structHasBitFields"] = structHasBitFields
	structDetails["structHasMemberLevelOrStructLevelAttributes"] = structHasMemberLevelOrStructLevelAttributes
	if structHasBitFields:
		structDetails["structHasBitFieldsWithMixedContainers"] = structHasBitFieldsWithMixedContainers
		

	if isDynamic:
		# Recall that for a dynamic struct it's impossible to know its length beforehand - only after you process ALL the members, you get to know it.
		# Unfortunately, we already needed to put the header row for the struct at the beginning before even processing the first member.
		# So, the 4th element that designates the end-address for the struct, was incorrect. Now, we correct it.
		if executionStage == "Map":
			PRINT("Now we are going to update the previously-added dynamic struct header row in unraveled")
			structEndAddr = offset+structSizeBytes

			minOrMaxValueInColumnResult = minOrMaxValueInColumn(unraveledSupplied, 4, "max")	# The Addr end (exclusive) is the column #4 in unraveled
			if minOrMaxValueInColumnResult[0] != True:
				errorMessage = "ERROR in calculateStructureLength() - while trying to update the header row for " + structDetails["type"] + " "+ structName + ", could not calculate the max end addr"
				errorRoutine(errorMessage)
				return False
			else:
				maxEndAddrInUnraveledSupplied = minOrMaxValueInColumnResult[1]

				# Sanity check
				if structEndAddr < maxEndAddrInUnraveledSupplied:
					errorMessage = "ERROR in calculateStructureLength() - while trying to update the header row for " + structDetails["type"] + " "+ structName + ", the max end addr in unraveled is "+STR(maxEndAddrInUnraveledSupplied)+", yet offset (" + STR(offset)+") + structSizeBytes (" + STR(structSizeBytes) + ") = structEndAddr (" + STR(structEndAddr) + ") is smaller than that!!"
					errorRoutine(errorMessage)
					OUTPUT("structEndAddr =",structEndAddr,", maxEndAddrInUnraveledSupplied =",maxEndAddrInUnraveledSupplied,"\nunraveledSupplied =")
					for row in unraveledSupplied:
						OUTPUT(row)
					return False
				else:
					unraveledSupplied[unraveledDynamicStructHeaderRowIndex][4]=offset+structSizeBytes
					PRINT("\nReturning the following unraveledSupplied from calculateStructureLength():")
					for row in unraveledSupplied:
						PRINT(row)
					return [True, structSizeBytes, unraveledSupplied, initResult]	# Remember that for dynamic structs we also return the unraveled
		elif executionStage == "Interpret":
			PRINT("\nDuring",executionStage,"just before returning from calculateStructureLength() for structName =",structName,", structDetails =\n",structDetails)
			PRINT("returning [True, LOGICAL_TEST_RESULT_INDETERMINATE]")
			return [True, LOGICAL_TEST_RESULT_INDETERMINATE]
	else:
		PRINT("\nDuring",executionStage,"just before returning from calculateStructureLength() for structName =",structName,", structDetails =\n",structDetails)
		PRINT("returning [True, structSizeBytes=",structSizeBytes,"]")
		return [True, structSizeBytes]


# Custom print function for the unraveled list since we do not want to print the whole of variableDescription dictionary, which is the third item in each row
# This will ONLY get printed in Debug mode, since it uses PRINT
def printUnraveled(unraveled):
	if not unraveled:
		PRINT ("Empty unraveled")
	elif not isinstance(unraveled, list):
		PRINT ("unraveled is NOT a list")
	else:
		PRINT ("\n\n","=="*100,"\nunraveled format (level, variable, datatype, starting offset (inclusive), ending offset+1 (exclusive), Raw Hex Bytes, Value (LE), Value (BE), [Ancestry list ending with current variableId] \n","=="*100,"\n")
		for row in unraveled:
			rowText = "["+STR(row[0])
			for N in range(1,len(row)):
				item = row[N]
				if N == 2 and isinstance(row[N],dict):
					try:
						rowText += ", "+item["datatype"]
					except KeyError:
						OUTPUT ("KeyError in printUnraveled() for N=",N," row[N] =",item)
				else:
					rowText += ", "+STR(item)
			rowText += "]"
			PRINT (rowText)
		PRINT ("\n\n","=="*100 )

def MUST_printUnraveled(unraveled):
	global PRINT_DEBUG_MSG
	backedUpValuePRINT_DEBUG_MSG = PRINT_DEBUG_MSG
	PRINT_DEBUG_MSG = True
	printUnraveled(unraveled)
	PRINT_DEBUG_MSG = backedUpValuePRINT_DEBUG_MSG

#################################################################################################################################
# This routine takes in a variableId with a blank array dimension and returns the variableId that will hold the terminal condition.
# It returns False for errors. Actually in Python, False equates to 0, which is a valid variableId. However, since a valid
# return value must be 1 or more (since the very first declared variable cannot serve as the terminal condition of any variable
# declared before, we are OK.
#################################################################################################################################
def terminalVariableId (variableId):	# variableId is the variable with a blank dimension
	if not checkIfIntegral(variableId) or variableId not in range(len(variableDeclarations)):
		errorMessage = "ERROR in terminalVariableId() - passed variableId <%s> is illegal"%STR(variableId)
		errorRoutine(errorMessage)
		return False
	elif not variableDeclarations[variableId][4]["isArray"] or variableDeclarations[variableId][4]["arrayDimensions"][0]!=["TBD"]:
		errorMessage = "ERROR in terminalVariableId() - passed variableId <%s> (variable name <%s>) is not an array with blank dimension"%(STR(variableId),variableDeclarations[variableId][0])
		errorRoutine(errorMessage)
		return False
	else:
		# We are assuming that variables get their variableId in the lexical order.
		for v in range(variableId+1,len(variableDeclarations)):
			if variableDeclarations[v][4]["isInitialized"]:	# Take the very first variable with an initialization specified and return that
				PRINT("For input variable",variableDeclarations[variableId][0],"( variable id =",variableId,"), the terminal variable is",variableDeclarations[v][0],"(variable id =",v,")")
				return v
		warningMessage = "Could not find any terminal initialization condition for the passed variable "+variableDeclarations[variableId][0]+" - which means it will not stop mapping until the whole data is exhausted!"
		if not IN_DEMO:
			warningRoutine(warningMessage)
		return False
#########################################################################################################################################################
# This routine returns an ancestry history for a variable. The returned ancestry list starts with a global variable and ends with the given variableId
#########################################################################################################################################################
def getAncestorList(variableId):
#	PRINT=OUTPUT
	if not checkIfIntegral(variableId) or variableId not in range(len(variableDeclarations)):
		errorMessage = "ERROR in getAncestorList() - passed variableId <%s> is illegal"%STR(variableId)
		errorRoutine(errorMessage)
		return False
	variableName = variableDeclarations[variableId][0]
	PRINT("inside getAncestorList(variableId=",variableId,") - passed variable name is <"+variableName+">")
	
	# Perform a sanity check on variableDeclarations. Remember that the "structId" indicates which struct this variable is a member of. Don't confuse it with the datatype.
	# For example if there is a global variable "struct S var1;", then inside the variableDeclarations entry for var1, the "structId" would not be there, and
	# the datatype for var1 will be noted as "S".
	for v in range(len(variableDeclarations)):
		if "structId" not in getDictKeyList(variableDeclarations[v][4]) or variableDeclarations[v][4]["level"]==0:	# Global variable
			if "structId" in getDictKeyList(variableDeclarations[v][4]) or variableDeclarations[v][4]["level"]!=0:	# Just confirming
				OUTPUT("variableDeclarations[v="+STR(v)+"][4] =",variableDeclarations[v][4])
				OUTPUT("\nstructuresAndUnions =\n",structuresAndUnions)
				EXIT("ERROR in getAncestorList() - for variable "+variableDeclarations[v][0]+" (variableId="+STR(v)+"), the level and structId information is inconsistent")

	PRINT("Sanity check for variableDeclarations succeeded - now finding the ancestor list for", variableName)
	
	# Find the ancestors
	ancestors = [variableId]
	ancestorListDone = False
	v = variableId
	
	# Every variable is either declared in the open (global variable), or a member variable of some structure
	while not ancestorListDone:
		if "structId" not in getDictKeyList(variableDeclarations[v][4]):	# Global variable
			ancestorListDone = True
			break
		else:
			structId = variableDeclarations[v][4]["structId"]
			structName = structuresAndUnions[structId]["name"]
			for nextVarId in range(v+1, len(variableDeclarations)):
				if variableDeclarations[nextVarId][4]["datatype"]==structName:
					ancestors.append(nextVarId)
					v = nextVarId
					break
	PRINT("Before reversing it, ancestors =",ancestors)
	ancestors.reverse()		# We want it to start from the global variable
	PRINT("After reversing it, ancestors =",ancestors)
	ancestorsNames = [variableDeclarations[v][0]+" ("+STR(v)+")" for v in ancestors]
	PRINT("Ancestors of",variableName,"(",variableId,") are [", ' , '.join(ancestorsNames),"]")
	return ancestors

#############################################################################################################################################
# This routine takes in a variableId (which must be an array variable with a blank arrayDimension), then it finds out its terminalVariableId,
# basically which is the lexically closest following initialization statement that will decide the array dimension.
# Then it takes these two variable ids (variableId and its terminal variable id), and find their closest ancestors that are siblings variables.
#
# Why do we care about finding ancestors that are siblings? That's because, we want to iterate over different values of array dimensions, but
# for that we must have both the blank array variable and its terminal variable being added to unraveled by the same routine. 
# There are exactly 3 places where we current iterate over a bunch of "sibling" variables (basically variables at the same level):
#
#	1. In populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize(), where we iterate over all the global-level variables which have been selected by the user.
#   2. In addVariableToUnraveled(), where we iterate over the struct member variables (all siblings) for REGULAR structs.
#	3. In calculateStructureLength(), where we iterate over the struct member variables (all siblings) for DYNAMIC structs.
#
# So, in all such routines, there will be a loop that we can exploit for speculative execution. We first save the execution state (or the context) 
# before we add the ancestor of the blank array variable. Then we continue iterating until we hit the ancestor of the terminal variable with the initialization.
# If the initialization succeeds, we carry on like as usual. However, if the initialization fails, instead of going to the subsequent variable in the loop,
# we immediately restore the execution state, and jump back to the original ancestor of the blank variable array.
# 
# Example 1:
#
# struct S1 {						// In this case, n is the terminal variable corresponding to the blank array variable c.
#		struct S2{					// And they are direct siblings. So this routine will return the variable ids of c and n.
#				char c[];
#				char n = '\0';
#				} V2;
#			};
#
# Example 2:
#
# struct S1 {						// In this case, n is the terminal variable corresponding to the blank array variable c.
#		struct S2{					// But they are not direct siblings. So this routine will return the variable ids of V2 and n.
#				char c[];			// Not that V2 is the ancestor of c, and n is the sibling of V2.
#				int i;
#				} V2;
#		char n = '\0';
#			};
#
# Example 3:
#
# struct S1 {						// In this case, n is the terminal variable corresponding to the blank array variable c.
#		struct S2{					// But they are not direct siblings. So this routine will return the variable ids of V2 and V3.
#				char c[];			// Not that the ancestor of c is V2, which is the sibling of V3, which is the ancestor of n.
#				int i;
#				} V2;
#		struct S3{
#				char n = '\0';
#				} V3;
#			};
#
# Example 4:
#
# char c[];
# struct S1 {						// In this case, n is the terminal variable corresponding to the blank array variable c.
#		struct S2{					// But they are not direct siblings. So this routine will return the variable ids of c and V1.
#				float f;			// Not that c is a global variable, which is the sibling of V1, which is the ancestor of n.
#				int i;
#				} V2;
#		struct S3{
#				char n = '\0';
#				} V3;
#			} V1;
#############################################################################################################################################
def findSiblingAncestors(variableId):	# variableId is the array variable with a blank dimension
#	PRINT=OUTPUT
	if not checkIfIntegral(variableId) or variableId not in range(len(variableDeclarations)):
		errorMessage = "ERROR in findSiblingAncestors() - passed variableId <%s> is illegal"%STR(variableId)
		errorRoutine(errorMessage)
		return False
	elif not variableDeclarations[variableId][4]["isArray"] or variableDeclarations[variableId][4]["arrayDimensions"][0]!=["TBD"]:
		errorMessage = "ERROR in findSiblingAncestors() - passed variableId <%s> (variable name <%s>) is not an array with blank dimension"%(STR(variableId),variableDeclarations[variableId][0])
		errorRoutine(errorMessage)
		return False
	else:
		partner = terminalVariableId(variableId)
		if partner == False:
			return False
	PRINT("For passed variable",variableDeclarations[variableId][0],"(",variableId,"), its partner variable is",variableDeclarations[partner][0],"(",partner,") that has the initialization condition")
	ownAncestors = getAncestorList(variableId)
	if ownAncestors == False:
		errorMessage = "ERROR in findSiblingAncestors() - for passed variableId <%s> (variable name <%s>), could not find its ancestors"%(STR(variableId),variableDeclarations[variableId][0])
		errorRoutine(errorMessage)
		return False
	partnerAncestors = getAncestorList(partner)
	if ownAncestors == False:
		errorMessage = "ERROR in findSiblingAncestors() - for partner  <%s> (variable name <%s>), could not find its ancestors"%(STR(partner),variableDeclarations[partner][0])
		errorRoutine(errorMessage)
		return False
		
	commonLength = min(len(ownAncestors), len(partnerAncestors))
	if ownAncestors[:commonLength] == partnerAncestors[:commonLength]:
		PRINT("For passed variable",variableDeclarations[variableId][0],"(",variableId,"), its partner variable",variableDeclarations[partner][0],"(",partner,") itself is its ancestor")
		return [ownAncestors[commonLength-1],partnerAncestors[commonLength-1]]
	else:
		for i in range(commonLength):
			if ownAncestors[i] != partnerAncestors[i]:
				PRINT("For passed variable",variableDeclarations[variableId][0],"(",variableId,") and its partner variable",variableDeclarations[partner][0],"(",partner,") the first sibling ancestors are [",variableDeclarations[ownAncestors[i]][0],"(",ownAncestors[i],") ,",variableDeclarations[partnerAncestors[i]][0], "(",partnerAncestors[i],") ]")
				return [ownAncestors[i], partnerAncestors[i]]
	EXIT("Coding bug in findSiblingAncestors() - should have never come here")

##################################################################################################################################
# Consider all the sibling ancestor pairs for all the blank-array-variable and its initialization counterparts.
# If you give this routine one valid ancestor sibling, it will return you the other ancestor sibling.
# This routine is NOT for finding the partners (like initialization variable for a blank array variable, or vice versa).
##################################################################################################################################
def findSibling(variableId):
#	PRINT=OUTPUT
	if variableId not in range(len(variableDeclarations)):
		errorMessage = "ERROR in findSibling() - illegal variableId <"+STR(variableId)+">"
		errorRoutine(errorMessage)
		return False
	else:
		variableName = variableDeclarations[variableId][0]
		PRINT("Currently, blankArraysAndTerminationInfo =",blankArraysAndTerminationInfo)
		for blankDimensionArrayVariableId in getDictKeyList(blankArraysAndTerminationInfo):
			if blankDimensionArrayVariableId != blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["blankDimensionArrayVariableId"]:
				EXIT("Bad coding - blankDimensionArrayVariableId != blankArraysAndTerminationInfo[blankDimensionArrayVariableId][\"blankDimensionArrayVariableId\"]")
			partnerVariableId = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["partnerVariableId"]
			ancestorOfBlankDimensionArrayVariableId = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["siblingAncestors"][0]
			ancestorOfInitializationPartner = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["siblingAncestors"][1]
			if variableId == ancestorOfBlankDimensionArrayVariableId:
				PRINT("The variable",variableName,"(id",variableId,") is the ancestor of a blank array variable", variableDeclarations[blankDimensionArrayVariableId][0],"(id",blankDimensionArrayVariableId,") - returning the variable id (",ancestorOfInitializationPartner,") that is the ancestor of the initialization partner", variableDeclarations[partnerVariableId][0],"(id",partnerVariableId,")")
				return [ancestorOfInitializationPartner, "ancestorOfBlankDimensionArrayVariable"]
			elif blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["siblingAncestors"][1]==variableId:
				PRINT("The variable",variableName,"(id",variableId,") is the ancestor of the initialization partner variable", variableDeclarations[partnerVariableId][0],"(id", partnerVariableId,"), whose blank variable counterpart is variable",variableDeclarations[blankDimensionArrayVariableId][0], "(id",blankDimensionArrayVariableId,"), whose ancestor is", variableDeclarations[ancestorOfBlankDimensionArrayVariableId][0],"(id",ancestorOfBlankDimensionArrayVariableId,")")
				return [ancestorOfBlankDimensionArrayVariableId, "ancestorOfInitializationPartner"]
			else:
				PRINT("The variable",variableName,"is NOT the ancestor of this blank-dimension array variable", variableDeclarations[blankDimensionArrayVariableId][0],"(id", blankDimensionArrayVariableId,") or its partner")
		return None

def findInitializationPartnerForBlankArrayVariable(variableId):
#	PRINT=OUTPUT
	if variableId not in range(len(variableDeclarations)):
		errorMessage = "ERROR in findInitializationPartnerForBlankArrayVariable() - illegal variableId <"+STR(variableId)+">"
		errorRoutine(errorMessage)
		return False
	else:
		variableName = variableDeclarations[variableId][0]
		for blankDimensionArrayVariableId in getDictKeyList(blankArraysAndTerminationInfo):
			if variableId == blankDimensionArrayVariableId:
				partnerVariableId = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["partnerVariableId"]
				PRINT("Returing initialization partner variable",variableDeclarations[partnerVariableId][0],"(id",partnerVariableId,") for",variableName,"(id",variableId,")")
				return partnerVariableId
		return None

def findBlankArrayVariableForInitializationPartner(variableId):
#	PRINT=OUTPUT
	if variableId not in range(len(variableDeclarations)):
		errorMessage = "ERROR in findBlankArrayVariableForInitializationPartner() - illegal variableId <"+STR(variableId)+">"
		errorRoutine(errorMessage)
		return False
	else:
		variableName = variableDeclarations[variableId][0]
		for blankDimensionArrayVariableId in getDictKeyList(blankArraysAndTerminationInfo):
			partnerVariableId = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["partnerVariableId"]
			if variableId == partnerVariableId:
				PRINT("Returing blank array dimension variable",variableDeclarations[blankDimensionArrayVariableId][0],"(id",blankDimensionArrayVariableId,")","for initialization partner variable",variableDeclarations[partnerVariableId][0],"(id",partnerVariableId,")")
				return blankDimensionArrayVariableId
		return None
'''		
#################################################################################################################################
# This routine takes a variableId and adds all the "unraveled" variables to the supplied allPossibleQualifiedNames recursively
# This routine is pretty much same as addVariableToUnraveled(), except that we do not add any values, and we do not care about the level.
# It is possible to merge these two functions into a single one, but for now I am keeping them separate for clarity.
#################################################################################################################################
def printAllArrayVariableNames(variableId, prefix, arrayDimensionsSupplied, allPossibleQualifiedNamesSupplied):
	PRINT=OUTPUT
	arrayDimensions = deepCopy(arrayDimensionsSupplied)
	PRINT("\nInside printAllArrayVariableNames(variableId =",variableId,", prefix =",prefix,", arrayDimensions =",arrayDimensions,", allPossibleQualifiedNamesSupplied)")
	MUST_printUnraveled(unraveled)
	for row in unraveled:
		PRINT(row)
	allPossibleQualifiedNamesSupplied.append(prefix)
	if arrayDimensions:	# For array, the prefix already contains the array variable name
		if checkIfIntegral(arrayDimensions[0]):
			arrayDimensionValue = arrayDimensions[0]
		else:
			getRuntimeValueResult = getRuntimeValue(arrayDimensions[0])
			if getRuntimeValueResult[0] == True:
				arrayDimensionValue = getRuntimeValueResult[1]
			else:
				arrayDimensionValue = LOGICAL_TEST_RESULT_INDETERMINATE
		
		if checkIfIntegral(arrayDimensionValue) and arrayDimensionValue > 1:
			PRINT("arrayDimensions[0] =",arrayDimensions[0])
			for d in range(arrayDimensionValue):
				allPossibleQualifiedNamesSupplied = printAllArrayVariableNames(variableId, prefix+"["+STR(d)+"]", arrayDimensions[1:], allPossibleQualifiedNamesSupplied)
	elif variableDeclarations[variableId][4]["datatype"] in getDictKeyList(suDict):
		structName = variableDeclarations[variableId][4]["datatype"]
		N = 0
		while N < len(structuresAndUnions[suDict[structName][-1]]["components"]):
			PRINT("Component #",N)
			structMember = structuresAndUnions[suDict[structName][-1]]["components"][N]
			PRINT ("\nInside printAllArrayVariableNames(), Processing from structMember =",structMember )
			structMemberVariableName 		= structMember[0]
			structMemberDescription 		= structMember[4]
			structMemberVariableId			= structMemberDescription["variableId"]
			if structMemberVariableName.startswith(dummyUnnamedBitfieldNamePrefix):
				PRINT ("Omitting structMemberVariableName =",structMemberVariableName)
			else:
				structMemberArrayDimensions = [] if not structMemberDescription["isArray"] else structMemberDescription["arrayDimensions"]
				allPossibleQualifiedNamesSupplied = printAllArrayVariableNames(structMemberVariableId, prefix+"."+structMemberVariableName, structMemberArrayDimensions, allPossibleQualifiedNamesSupplied)
			PRINT ("\nfor structName =", structName,", for N =",N,", structMemberVariableName =",structMemberVariableName,", structMemberVariableId =",structMemberVariableId,", structMemberDescription =",structMemberDescription)
			N += 1
	return allPossibleQualifiedNamesSupplied

#string = '{0}'
#result = True if re.match(r'{}|{0(,0)*}',string) else False
#OUTPUT(result)
#sys.exit()
'''
######################################################################################################################################################
# This routine taken in a named variable (like "a.b[2].c[var+1][4]") and splits it into names and array sizes. It returns 4 lists:
# 1) nameList = ["a","b","c"], 	<== only contains the variable names
# 2) arrayDimensionsList = [[],[2],['var','+',1],4]], 	<== only contains the array dimensions
# 3) variableId list if the parentStruct name or variableId was specified
# The parentStruct is the struct type name, not the struct id name or the struct variable name. For example, if we have a code like this
# struct S1 {int i[2]};  						// <=== If we try to split "Svar1.i[1]", then we should pass "S1" as the parentStruct parameter.
# struct S2{ struct S1 Svar1; float f} V;		//      Alternatively, we could also pass the variableId of V too.
######################################################################################################################################################
def splitName(namedVariable, variableIdOrParentStructName=""):
	if checkIfString(namedVariable):
		if not namedVariable:
			errorMessage = "ERROR in splitName() - passed name <%s> is blank"%namedVariable
			errorRoutine(errorMessage)
			return False
		tokenizeLinesResult = tokenizeLines(namedVariable)
		if tokenizeLinesResult == False:
			errorMessage = "ERROR in splitName() tokenizing <%s>"%namedVariable
			errorRoutine(errorMessage)
			return False
		else:
			namedVariable = tokenizeLinesResult[0]	# Replace the original string with a tokenized list
	if isinstance(namedVariable, list):
		if not namedVariable:
			errorMessage = "ERROR in splitName() - passed name <%s> is blank"%STR(namedVariable)
			errorRoutine(errorMessage)
			return False
		for item in namedVariable:
			if not checkIfString(item):
				errorMessage = "ERROR in splitName() - the list <%s> contains non-string elements"%list2plaintext(namedVariable,"")
				errorRoutine(errorMessage)
				return False
	
	# Now let's split the name
	onlyVariableNames = []
	onlyArrayIndices = []
	
	lastVarName = None
	lastIndices = []
	k = 0
	while True:
		if k>=len(namedVariable):
			onlyVariableNames.append(lastVarName)
			onlyArrayIndices.append(lastIndices)
			break
		# The name cannot be blank
		elif namedVariable[k] in ('[','.') and lastVarName == None:
			errorMessage = "ERROR in splitName() - the namedVariable <"+list2plaintext(namedVariable,"")+"> is not a valid named variable since the named variable contains an array index alone without the array variable name"
			errorRoutine(errorMessage)
			return False
		elif namedVariable[k] == '.':
			onlyVariableNames.append(lastVarName)
			onlyArrayIndices.append(lastIndices)
			lastVarName = None
			lastIndices = []
			k = k+1
		elif namedVariable[k] == '[':
			d = matchingBraceDistance(namedVariable[k:])
			if d<0:
				errorMessage = "ERROR in splitName() - the namedVariable <"+list2plaintext(namedVariable,"")+"> is not a valid named variable since the named variable "+namedVariable+" is not a valid array item"
				errorRoutine(errorMessage)
				return False
			lastIndices.append(namedVariable[k+1:k+d])	# We are discarding the enclosing [] braces
			k = k+d+1
		else:
			lastVarName = namedVariable[k]
			k = k+1

	PRINT("onlyVariableNames =",onlyVariableNames)
	PRINT("onlyArrayIndices =",onlyArrayIndices)

	if len(onlyVariableNames) != len(onlyArrayIndices):
		EXIT("Coding bug in splitName() - somehow the len(onlyVariableNames) = "+STR(len(onlyVariableNames))+" != len(onlyArrayIndices) = "+STR(len(onlyArrayIndices)))
	recreated = ""
	for i in range(len(onlyVariableNames)):
		recreated += onlyVariableNames[i]
		if onlyArrayIndices[i]:
			for j in range(len(onlyArrayIndices[i])):
				recreated += '['+list2plaintext(onlyArrayIndices[i][j],"")+']'
		if i<len(onlyVariableNames)-1:
			recreated += '.'
			
	if recreated != list2plaintext(namedVariable,""):
		errorMessage = "ERROR in splitName() - the namedVariable <"+list2plaintext(namedVariable,"")+"> does not match with the recreated namedvariable <"+recreated+">"
		errorRoutine(errorMessage)
		return False

	# If one intends to check if the parent--> child relationship is indeed valid, one must supply either the variable id of the top-level variable in the passed name,
	# or the parent struct name. Without any of these, we cannot really confirm anything, since the same variable name could be reused in many structs.
	if not variableIdOrParentStructName:
		PRINT("For namedVariable =",list2plaintext(namedVariable,""),", returning onlyVariableNames =",list2plaintext(onlyVariableNames,"."), ", onlyArrayIndices =", list2plaintext(onlyArrayIndices,"."))
		return [onlyVariableNames, onlyArrayIndices]


	# This part is optional, only if the user supplied the variableIdOrParentStructName
	onlyVariableIds = []

	if checkIfString(variableIdOrParentStructName):
		parentStruct = variableIdOrParentStructName
		variableId = None
	elif checkIfIntegral(variableIdOrParentStructName):	# Passed parameter is the variableId of the current variable
		variableId = variableIdOrParentStructName
		if variableId >= len(variableDeclarations):
			errorMessage = "ERROR in splitName() - passed variableId <%d> is illegal since there are currently only %d items in variableDeclarations"%(variableIdOrParentStructName, len(variableDeclarations))
			errorRoutine(errorMessage)
			return False
		topLevelVariableName = variableDeclarations[variableId][0]
		if topLevelVariableName != namedVariable[0]:
			errorMessage = "ERROR in splitName() - passed variableId <%d> is illegal since the top-level name (%s) does not match with variable name (%s) in the %d-th item in variableDeclarations"%(variableId, namedVariable[0], topLevelVariableName, variableId)
			errorRoutine(errorMessage)
			return False
			
		if "structId" in getDictKeyList(variableDeclarations[variableId][4]):
			parentStructId = variableDeclarations[variableId][4]["structId"]
			parentStruct = structuresAndUnions[parentStructId]["name"]


	for k in range(len(onlyVariableNames)):
		name = onlyVariableNames[k]
		if parentStruct not in getDictKeyList(suDict):
			errorMessage = "ERROR in splitName() - the namedVariable <"+list2plaintext(namedVariable,"")+"> is not a valid named variable since the datatype "+parentStruct+" is not a valid parent struct for child variable "+name
			errorRoutine(errorMessage)
			return False
		memberVariableId = None
		# First check if the variable name is at all a struct member. If not, flag it immediately.
		if "components" not in getDictKeyList(structuresAndUnions[suDict[parentStruct][-1]]):
			errorMessage = "ERROR in splitName() - for variable <%s> parentStruct <%s> is illegal since it does not have any components"%(name, parentStruct)
			errorRoutine(errorMessage)
			return False
		for component in structuresAndUnions[suDict[parentStruct][-1]]["components"]:
			if component[0] == name:
				memberVariableId = component[4]["variableId"]
				onlyVariableIds.append(memberVariableId)
				parentStruct = component[4]["datatype"]
				break
		if memberVariableId == None:
			errorMessage = "ERROR in splitName() - the namedVariable statement <"+list2plaintext(namedVariable,"")+"> is not a valid named variable since variable <"+name+"> is not a member variable of struct "+parentStruct
			errorRoutine(errorMessage)
			return False
		
		# Also check if the array dimensions
		if onlyArrayIndices[k]: 
			if not variableDeclarations[memberVariableId][4]["isArray"]:
				errorMessage = "ERROR in splitName() - the namedVariable statement <"+list2plaintext(namedVariable,"")+"> is not a valid named variable since variable <"+name+"> is not an array variable under struct "+parentStruct
				errorRoutine(errorMessage)
				return False
			elif len(onlyArrayIndices[k]) > len(variableDeclarations[memberVariableId][4]["arrayDimensions"]):
				errorMessage = "ERROR in splitName() - the namedVariable statement <"+list2plaintext(namedVariable,"")+"> is not a valid named variable since variable <"+name+"> is a "+STR(len(variableDeclarations[memberVariableId][4]["arrayDimensions"]))+"-dimensional array variable under struct "+parentStruct+", but here it is "+STR(len(onlyArrayIndices[k]))+"-dimensional"
				errorRoutine(errorMessage)
				return False
			else:
				arrayDimensions = variableDeclarations[memberVariableId][4]["arrayDimensions"]
				for j in range(len(onlyArrayIndices[k])):
					if not checkIfIntegral(onlyArrayIndices[k][j]) or not checkIfIntegral(arrayDimensions[j]):
						continue
					elif checkIfIntegral(onlyArrayIndices[k][j]) and (onlyArrayIndices[k][j] <0 or onlyArrayIndices[k][j] >= arrayDimensions[j]):
						errorMessage = "ERROR in splitName() - the namedVariable statement <"+list2plaintext(namedVariable,"")+"> is not a valid named variable since variable <"+name+"> is a "+STR(len(arrayDimensions))+"-dimensional array variable under struct "+parentStruct+", but here its "+STR(j)+"-th dimension ("+STR(onlyArrayIndices[k][j])+") is larger than arrayDimensions["+STR(j)+"] = "+STR(arrayDimensions[j])
						errorRoutine(errorMessage)
						return False
					
	onlyVariableNamesRecreated = [variableDeclarations[x][0] for x in onlyVariableIds]
	if onlyVariableNames != onlyVariableNamesRecreated:
		errorMessage = "ERROR in splitName() - the namedVariable statement <"+list2plaintext(namedVariable,"")+"> is not a valid named variable since onlyVariableNames = <"+list2plaintext(onlyVariableNames,"")+"> does not match with "+list2plaintext(onlyVariableNamesRecreated,"")
		errorRoutine(errorMessage)
		return False

	PRINT("For namedVariable =",list2plaintext(namedVariable,""),", returning onlyVariableNames =",list2plaintext(onlyVariableNames,""), ", onlyArrayIndices =", list2plaintext(onlyArrayIndices,""), ", onlyVariableIds =",list2plaintext(onlyVariableIds,""))
	return [onlyVariableNames, onlyArrayIndices, onlyVariableIds]
	
######################################################################################################################################################
# This routine verifies if the actual value of the variable in a certain row of unraveled matches its supposed initialization value (if any).
# The rowNum is defaulted to last row. The reason one is allowed to provide a rowNum is because one might need to verify the initialization for
# a variable that is an array or a struct. In such cases, the "Header row" for the struct or array will be much above, and without specifying
# the rowNum explicitly, there is no way to figure out how high one might need to go up.
# It returns a tuple of [Status, Initialization match found or not [, and the last "consumed" unraveled row # if the match succeeded]]
# So when the match is not found, it will not return any 3rd item. Only for successful match, the last matched row # be returned.
######################################################################################################################################################
#def verifyInitialization(unraveledSupplied, rowNum=-1, initializationValueSupplied = None, commonPrefix="", arrayDimensionsSubsetSupplied=[]):
def verifyInitialization(unraveledSupplied, rowNum=-1, silent = False, initializationValueSupplied = None, commonPrefix=""):
#	PRINT=OUTPUT
	PRINT("\n","==="*50,"\n","Inside verifyInitialization(unraveledSupplied, rowNum=",rowNum,", silent =","True" if silent else "False",", initializationValueSupplied = ",initializationValueSupplied,", commonPrefix = <"+commonPrefix+">", ")\n","==="*50)
	global gVerificationWarningCount
	
	if not unraveledSupplied:
		return [True, False]
	elif rowNum >= len(unraveledSupplied):
		errorMessage = "ERROR in verifyInitialization() - supplied rowNum "+STR(rowNum)+" is bigger than unraveled length"
		errorRoutine(errorMessage)
		return [False, False]
	elif not isinstance(unraveledSupplied, list) or not isinstance(unraveledSupplied[rowNum], list) or not len(unraveledSupplied[rowNum])==9 or not isinstance(unraveledSupplied[rowNum][8], list):
		OUTPUT("unraveledSupplied =\n", unraveledSupplied)
		errorMessage = "ERROR in verifyInitialization() - supplied unraveled is not a proper list"
		errorRoutine(errorMessage)
		return [False, False]
	elif commonPrefix and not unraveledSupplied[rowNum][1].startswith(commonPrefix):
		OUTPUT("unraveledSupplied[",rowNum,"] =\n", unraveledSupplied[rowNum])
		errorMessage = "ERROR in verifyInitialization() - supplied unraveled row variable name <"+unraveledSupplied[rowNum][1]+"> doesn't start with commonPrefix = <"+commonPrefix+">"
		errorRoutine(errorMessage)
		return [False, False]

#	MUST_printUnraveled(unraveledSupplied)

	if rowNum == -1:
		rowNum = len(unraveledSupplied)-1

	# For both array and struct headers, the LE/BE values are blank, but there is something else we can use to tell if it is struct or array
	indicatorStringInHeaderForArray  = " - Array of "
	indicatorStringInHeaderForStruct = " is of type struct"

	unraveledVariableText = unraveledSupplied[rowNum][1]
	if not commonPrefix:
		if unraveledSupplied[rowNum][6+DEFAULT_ENDIANNESS] == "":	# Header row for Array and Struct 
			if indicatorStringInHeaderForArray in unraveledVariableText:
				commonPrefix = unraveledVariableText[:unraveledVariableText.find(indicatorStringInHeaderForArray)]
			elif indicatorStringInHeaderForStruct in unraveledVariableText:
				commonPrefix = unraveledVariableText[:unraveledVariableText.find(indicatorStringInHeaderForStruct)]
			else:
				OUTPUT ("\nFor the header row # "+STR(rowNum)+", unraveledVariableText = <"+unraveledVariableText+">")
				OUTPUT ("\nThe whole header row # "+STR(rowNum)+" = \n",STR(unraveledSupplied[rowNum]))
				OUTPUT ("\nThe whole unraveled = \n")
				MUST_printUnraveled(unraveledSupplied)
				EXIT("Coding bug in verifyInitialization() - blank values means it must be either Array or Struct header row")
		else:
			commonPrefix = unraveledVariableText
		PRINT("No commonPrefix supplied - hence setting it to",commonPrefix)
	else:
		if not unraveledVariableText.startswith(commonPrefix):
			errorMessage = "ERROR in verifyInitialization() - unraveledVariableText <%s> does not start with commonPrefix <%s>"%(unraveledVariableText, commonPrefix)
			errorRoutine(errorMessage)
			return [False, False]
		else:
			PRINT("unraveledVariableText <%s> does start with commonPrefix <%s> - it is acceptable"%(unraveledVariableText, commonPrefix))
		
	variableId = unraveledSupplied[rowNum][8][-1]	# Top of ancestry stack
	variableName = variableDeclarations[variableId][0]
	variableDescriptionExtended = variableDeclarations[variableId][4]
	datatype = variableDescriptionExtended["datatype"]
	isArray = variableDescriptionExtended["isArray"]
	isStruct = True if datatype in getDictKeyList(suDict) else False
	PRINT("We are dealing with variableName =",variableName,"(variableId =",variableId,") of datatype =",datatype,"and is",("" if isArray else "not"),"an array",(("of type struct "+datatype) if isStruct else ""))
	

	# Since we are returning a "False" result if there was nothing to initialize, we are not able to differentiate a "real" False (value doesn't match)
	# with a "wrong" False (where there was nothing to compare). Hence, we must ensure that we are calling verifyInitialization() ONLY when there is an
	# initialization test to perform.
	if not variableDescriptionExtended["isInitialized"] and initializationValueSupplied == None:
		PRINT("variable",variableName," (variableId =",variableId,") is not initialized, and no initialization value is supplied either")
		return [True, False]
	elif initializationValueSupplied != None:
		initializationValue = initializationValueSupplied
	else:
		initializationValue = variableDescriptionExtended["initializationValue"]
		
	#The initialization value must be a list
	if not isinstance(initializationValue, list):
		errorMessage = "ERROR in verifyInitialization() - initializationValue <%s> is not a proper list"%list2plaintext(initializationValue,"")
		errorRoutine(errorMessage)
		return [False, False]

	PRINT("variable",variableName," (variableId =",variableId,") will be checked for initialization value of <", list2plaintext(initializationValue,""),">")



	# We are assuming that the arrayDimensions remains constant for the for loop. That's why we are calculating it only once and keep reusing it.
	if isArray:
		if indicatorStringInHeaderForArray in unraveledSupplied[rowNum][1]:
			arrayHeaderRowNum = rowNum
		else:
			ancestryOfSuppliedRow = unraveledSupplied[rowNum][8]
			arrayHeaderRowNum = rowNum
			while True:	# Keep going up until you find the row above the Array header row
				if arrayHeaderRowNum < 0 or unraveledSupplied[arrayHeaderRowNum][8][:len(ancestryOfSuppliedRow)] != ancestryOfSuppliedRow:
					break
				arrayHeaderRowNum -= 1
			arrayHeaderRowNum += 1	# This is our array header row
		PRINT("The arrayHeaderRowNum =",arrayHeaderRowNum)
		if indicatorStringInHeaderForArray not in unraveledSupplied[arrayHeaderRowNum][1]:
			EXIT("Coding bug in verifyInitialization() while determining the array header row - the calculated array header row # "+ STR(arrayHeaderRowNum) + " doesn't have the array header - its variable name is <"+unraveledSupplied[arrayHeaderRowNum][1]+">")

	if isStruct:
		if indicatorStringInHeaderForStruct in unraveledSupplied[rowNum][1]:
			structHeaderRowNum = rowNum
		elif isArray:	# If it both array and struct, the struct header comes one right after the array header
			structHeaderRowNum = arrayHeaderRowNum + 1
		else:
			ancestryOfSuppliedRow = unraveledSupplied[rowNum][8]
			PRINT("Since ancestryOfSuppliedRow = ",ancestryOfSuppliedRow,", we will look for a row with ancestry =",ancestryOfSuppliedRow[:-1])
			structHeaderRowNum = rowNum
			while True:	# Keep going up until you find the row above the struct header row
				if structHeaderRowNum < 0:
					EXIT("Coding bug in verifyInitialization() while determining the struct header row")
				PRINT("Looking at row #",structHeaderRowNum,"with ancestry =",unraveledSupplied[structHeaderRowNum][8])
				if unraveledSupplied[structHeaderRowNum][8] == ancestryOfSuppliedRow[:-1]:
					break
				structHeaderRowNum -= 1
		PRINT("The structHeaderRowNum =",structHeaderRowNum)
		if indicatorStringInHeaderForStruct not in unraveledSupplied[structHeaderRowNum][1]:
			EXIT("Coding bug in verifyInitialization() while determining the struct header row - the calculated struct header row # "+ STR(structHeaderRowNum) + " doesn't have the struct header - its variable name is <"+unraveledSupplied[structHeaderRowNum][1]+">")

	arrayDimensions = None		# Will only be updated if it is an array variable
	if isArray:
		if indicatorStringInHeaderForArray in unraveledSupplied[arrayHeaderRowNum][1] and unraveledSupplied[rowNum][8] == unraveledSupplied[arrayHeaderRowNum][8]:
			temp = unraveledSupplied[arrayHeaderRowNum][1]	# Here temp should be something like "STUDENT_TYPE.INT - Array of 2 X 3 X 2 ints"
			PRINT("unraveledSupplied[arrayHeaderRowNum][1] =",unraveledSupplied[arrayHeaderRowNum][1])
			i = temp.find(indicatorStringInHeaderForArray)	# We are guaranteed to find it
			temp = temp[i+len(indicatorStringInHeaderForArray):]	# Now temp should be like "2 X 3 X 2 ints"
			PRINT("temp =",temp)
			tempList = re.split(r'[\s+X\s+]+',temp)	# Now tempList should be like ['2', '3', '2', 'ints']
			temp2 = tempList[:-1]	# Now temp2 = ['2', '3', '2']
			PRINT("tempList =",tempList)
			PRINT ("temp2 =",temp2)
			arrayDimensions = [int(x) for x in temp2]	# Now arrayDimensions = [2, 3, 2]
			PRINT("arrayDimensions =",arrayDimensions)
			for dimension in arrayDimensions:
				if not checkIfIntegral(dimension) or dimension<1:
					errorMessage = "ERROR in verifyInitialization(): For struct/array variable "+variableName+", somehow the array dimensions mentioned in heacder row ( "+STR(arrayDimensions)+" ) are not proper"
					errorRoutine(errorMessage)
					return [False, False]
		else:
			EXIT('Coding bug in verifyInitialization() in calculating overall Array header row - somehow the heacder row for an array does not have the " - Array of " keyword')
			
		# Now keep a note of what array dimensions are already part of the common prefix. For example, if commonPrefix="var[1][2]", then arrayDimensionsWithinCommonPrefix=[1,2]
		arrayDimensionsWithinCommonPrefix = []
		if commonPrefix[-1] == ']':
			temp = re.split(r'\[|\]',commonPrefix)
			i = len(temp)-1
			temp2=[]
			while i<=0:
				if checkIfIntegral(temp[i]):
					temp2.append(temp[i])
				else:
					break
				i -= 1
			arrayDimensionsWithinCommonPrefix = temp2[::-1]	# Reversing temp2
	# All zeroes test is done differently
	if re.match(r'{}|{0(,0)*}',list2plaintext(initializationValue,"")):
		PRINT("Initialization value is all zeroes")
#		ancestryForSuppliedVariable = unraveledSupplied[rowNum][8]
		for N in range(rowNum,len(unraveledSupplied),1):
			row = unraveledSupplied[N]
#			ancestry = row[8]
#			if ancestry[:len(ancestryForSuppliedVariable)] != ancestryForSuppliedVariable:	# Do not go beyond current variable
#				break
			if not row[1].startswith(commonPrefix):
				break
			lastRowNumConsumed = N
			rowVariableName = variableDeclarations[row[8][-1]][0]	# For structs, this will be different
			rowVariableValue = row[6+DEFAULT_ENDIANNESS]
			if rowVariableValue not in ("",0,0.0):
				warningMessage = "Variable "+rowVariableName+" in unraveled["+STR(N)+"] is not initialized to zero - it has a value of "+STR(rowVariableValue)
				warningRoutine(warningMessage)
				PRINT(warningMessage)
				return [True, False]
		PRINT("All",len(unraveledSupplied)-rowNum,"rows were successfully initialized to zero")
		return [True, True, lastRowNumConsumed]


	if initializationValue[0]=='{' and initializationValue[-1]=='}':
		PRINT("Initialization value", initializationValue,"is an array of values that are NOT all zeroes")
		parseArgumentListResult = parseArgumentList(initializationValue)
		if parseArgumentListResult == False:
			errorMessage = "ERROR in verifyInitialization() - the initialization value for array  variable "+variableName+" has illegal initialization value - "%list2plaintext(initializationValue)
			errorRoutine(errorMessage)
			return [False, False]
		else:
			PRINT("There are", len(parseArgumentListResult),"inidividual initializations to be made")
	else:
		PRINT("Initialization value", initializationValue,"is a single value that is NOT all zeroes")
		parseArgumentListResult = [initializationValue]

	# We can have a mixture of named and positional (variable name not specified) initialization. The rules are the following:
	#
	# 1. If there are no variable names and just comma-separated values, keep applying it to array or struct member variables one by one from the first member to last.
	# 2. Any time there can be a named variable initialization. When that happens, any subsequent positional initialization will happen AFTER the named variable.
	#    This essentially means that if a struct has members A,B,C,D,E, we can initialize it to {.D=1,.B=2,3,4,5,.A=0,7,8,9,10}. Observe how the same
	#    variable is getting re-intialized again and again during the initialization, all thanks to the named variables messing with the position
	#    from where the non-named initializations will start happening. We track this using the var nextPositionalRowNum.
	# 3. Just like named variable for structs, there can also be indexed initialization for arrays. And just like structs, they can appear in any order, and with each
	#    appearance they reset the point from which the positional initializations restart happening. For example, if we have int i[4]={1,[2]=4,5,[0]=20,30,40,50};
	#    that is a valid initialization statement. The same array member can technically get re-initialized infinitely, though that is a not a good programing practice.
	nextPositionalRowNum = rowNum

	for itemCount in range(len(parseArgumentListResult)):
		item = parseArgumentListResult[itemCount]
		if not isinstance(item, list):
			item = [item]
		PRINT("\n\nDealing with iniitialization value # ",itemCount," = <",list2plaintext(item,""),">")
		PRINT("Current value of nextPositionalRowNum =",nextPositionalRowNum)
		
		###############################################
		### 	Named initialization (for structs)	###
		###############################################
		if item[0]== '.' and "=" in item:	# named Initialization
			PRINT(list2plaintext(item,""), "is not a positional initialization - it is named")
			if datatype not in getDictKeyList(suDict):
				errorMessage = "ERROR in verifyInitialization() - the initialization statement <"+list2plaintext(item,"")+"> is not valid since named variable initialization is only allowed for struct variables, which "+variableName+" is not"
				errorRoutine(errorMessage)
				return [False, False]
			elif not (isinstance(item,list) and len(item)>=4 and item[0] == '.' and item.index('=')<=len(item)-2):
				errorMessage = "ERROR in verifyInitialization() - the initialization statement <"+list2plaintext(item,"")+"> is not a valid named variable initialization"
				errorRoutine(errorMessage)
				return [False, False]
			else:
				# One can give any kind of namedvariable. For example, {.var1.var2[3].var3[var2.i+j] = 100};
				namedVariable = item[1:item.index('=')]
				namedVariableInitializationValue = item[item.index('=')+1:]
				PRINT("Going to initialize variable namedVariable",namedVariable,"of struct",datatype,"to",list2plaintext(namedVariableInitializationValue))
				if datatype not in getDictKeyList(suDict):
					errorMessage = "ERROR in verifyInitialization() - the initialization statement <"+list2plaintext(item,"")+"> is not a valid named variable initialization since variable "+variableName+" is not a struct - its datatype is "+datatype
					errorRoutine(errorMessage)
					return [False, False]
				# We cannot just do this below because the named variables might contain array indices that contain the dot operator
#				namedVariableSplit = re.split(r'\.',namedVariable)		# <=== Left to show bug; do not delete
				namedVariableSplit = []		# Var names [with array indices]
				namedVariableIds = []		# Only var ids (obviously no var names or indices)
				lastVarName = None
				lastIndices = ""
				parentStruct = datatype
				k = 0
				while True:
					if k>=len(namedVariable):
						namedVariableSplit.append(list2plaintext(lastVarName,"")+list2plaintext(lastIndices,""))
						break
					# The name cannot be blank
					elif (k>=len(namedVariable) or namedVariable[k] in ('[','.')) and lastVarName == None:
						errorMessage = "ERROR in verifyInitialization() - the initialization statement <"+list2plaintext(item,"")+"> is not a valid named variable initialization since the named variable contains an array index alone without the array variable name"
						errorRoutine(errorMessage)
						return [False, False]
					elif namedVariable[k] == '.':
						if parentStruct not in getDictKeyList(suDict):
							errorMessage = "ERROR in verifyInitialization() - the initialization statement <"+list2plaintext(item,"")+"> is not a valid named variable initialization since the datatype "+parentStruct+" is not a valid struct "
							errorRoutine(errorMessage)
							return [False, False]
						namedVariableSplit.append(list2plaintext(lastVarName,"")+list2plaintext(lastIndices,""))
						lastVarName = None
						lastIndices = ""
						k = k+1
					elif namedVariable[k] == '[':
						d = matchingBraceDistance(namedVariable[k:])
						if d<0:
							errorMessage = "ERROR in verifyInitialization() - the initialization statement <"+list2plaintext(item,"")+"> is not a valid named variable initialization since the named variable "+namedVariable+" is not a valid array item"
							errorRoutine(errorMessage)
							return [False, False]
						lastIndices = namedVariable[k:k+d+1]
						PRINT("Ignoring the array index", lastIndices,"for the named variable",lastVarName)
						k = k+d+1
					else:
						lastVarName = namedVariable[k]
						memberVariableId = None
						# First check if the variable name is at all a struct member. If not, flag it immediately.
						for component in structuresAndUnions[suDict[parentStruct][-1]]["components"]:
							if component[0] == lastVarName:
								memberVariableId = component[4]["variableId"]
								parentStruct = component[4]["datatype"]
								break
						if memberVariableId == None:
							errorMessage = "ERROR in verifyInitialization() - the initialization statement <"+list2plaintext(item,"")+"> is not a valid named variable initialization since variable <"+m+"> is not a member variable of struct "+parentStruct
							errorRoutine(errorMessage)
							return [False, False]
						else:
							namedVariableIds.append(memberVariableId)
						k = k+1

				namedVariableSplitWithoutIndices = [variableDeclarations[x][0] for x in namedVariableIds]
				PRINT("namedVariable =",namedVariable,"has been split into",'.'.join(namedVariableSplit)," (including array indices) or ",'.'.join(namedVariableSplitWithoutIndices),"(excluding array indices)")
				MUST_printUnraveled(unraveledSupplied)

				# Now find the corresponding entry in unraveled. Remember, it is possible that the variable name is indeed one of the struct members, but the 
				# struct is a dynamic one, and for this instance the struct member is not there. We check it by looking at the ancestry.
				PRINT("The structHeaderRowNum =",structHeaderRowNum)
				ancestryOfStructHeaderRow = unraveledSupplied[structHeaderRowNum][8]
				targetAncestry = ancestryOfStructHeaderRow + namedVariableIds
				targetVariableName = commonPrefix+"."+list2plaintext(namedVariable,"")
				PRINT("ancestryOfStructHeaderRow =",ancestryOfStructHeaderRow)
				targetRowNumber = None
				r = structHeaderRowNum+1
				PRINT("Starting from row#",r,", looking for row with variable name = <"+targetVariableName+"> and ancestry = ",targetAncestry)
				while True:
					if r>=len(unraveledSupplied):
						OUTPUT("Bad coding - must have other rows after the header row")
						sys.exit()
					PRINT("Row #",r,"variable name = <"+unraveledSupplied[r][1]+">, ancestry = ",unraveledSupplied[r][8])
					ancestryOfCurrentRow = unraveledSupplied[r][8]
					if len(ancestryOfCurrentRow)<len(ancestryOfStructHeaderRow) or ancestryOfStructHeaderRow != ancestryOfCurrentRow[:len(ancestryOfStructHeaderRow)]:
						PRINT("Giving up at row #",r)
						break	# Give up, we did not find the named variable row
					# DO NOT DELETE - left to show bug. Suppose a struct variable V has two members "in" and "i". If we look for V.i, even V.in will match.
#					if unraveledSupplied[r][1].startswith(commonPrefix+"."+namedVariable):	# <====    !!! BUG	!!!	BUG	!!!	BUG	!!!
					if unraveledSupplied[r][1].startswith(targetVariableName) and ancestryOfCurrentRow == targetAncestry:
						targetRowNumber = r
						break
					r += 1
				if targetRowNumber == None:
					errorMessage = "ERROR in verifyInitialization() with the initialization statement <"+list2plaintext(item,"")+"> - could not find the corresponding row in unraveled for variable "+list2plaintext(namedVariable,"")+", which is a member variable of struct "+datatype
					errorRoutine(errorMessage)
					return [False, False]
					
				result = verifyInitialization(unraveledSupplied, targetRowNumber, silent, namedVariableInitializationValue, targetVariableName)
				
				if result[0]!= True or result[1]!= True:
					warningMessage = "ERROR in verifyInitialization() - the named initialization statement <"+list2plaintext(item,"")+"> did not succeed"
					gVerificationWarningCount += 1
					if not silent and gVerificationWarningCount < VERIFICATION_WARNING_COUNT_MAX:
						warningRoutine(warningMessage)
					PRINT(warningMessage)
					return [result[0], False]
				else:
					PRINT("Named variable initialization",list2plaintext(item,""),"succeeded!")
					lastRowNumConsumed = result[2]
					nextPositionalRowNum = lastRowNumConsumed + 1
					PRINT("Reset nextPositionalRowNum to",nextPositionalRowNum)
		
		###############################################
		### 	Indexed initialization for array	###
		###############################################
		elif item[0]== '[' and "=" in item and item[item.index("=")-1]==']' and re.match(r'(\[.+\])+',list2plaintext(item)):	# explicit positional Initialization	
			if not variableDescriptionExtended["isArray"]:
				errorMessage = "ERROR in verifyInitialization() - the initialization statement <"+list2plaintext(item,"")+"> is not valid since explicit-indexed positional variable initialization is only allowed for array variables, which "+variableName+" is not"
				errorRoutine(errorMessage)
				return [False, False]
			arrayIndexBracedTotal = item[:item.index("=")]		# arrayIndexBracedTotal is everything before the '=' in a statement like [2][v+5][3]=10 (in list format)
			indexedVariableInitializationValue = item[item.index('=')+1:]	# indexedVariableInitializationValue after the '=' in the same statement
			PRINT("\n\nNEW ITEM <",list2plaintext(item,""),">\n\nWe will be checking if ",list2plaintext(arrayIndexBracedTotal,""),"=",list2plaintext(indexedVariableInitializationValue,""))

			# In the supplied initialized index, it could all be dynamic values
			temp = arrayIndexBracedTotal				# So temp = ['[','2',']','[','v','+','5',']','[','3',']'] 
			if not braceInterleavingLegal(temp, False):
				errorMessage = "ERROR in verifyInitialization() - the initialization statement <"+list2plaintext(item,"")+"> is not valid since the braces there are not legally interleaved"
				errorRoutine(errorMessage)
				return [False, False]
			arrayIndexCalculated = []	# we want to convert the temp = ['[','2',']','[','v','+','5',']','[','3',']'] to arrayIndexCalculated = [2,v+5,3]
			while True:
				if not temp:
					break
				if temp[0]!='[':
					EXIT("Coding bug in verifyInitialization() - exiting!!!")
				d = matchingBraceDistance(temp)
				if d <1:
					errorMessage = "ERROR in verifyInitialization() - out of the initialization statement <"+list2plaintext(item,"")+">, <"+list2plaintext(temp,"")+"> is not valid since we cannot find a matching ] brace"
					errorRoutine(errorMessage)
					return [False, False]
				arrayIndexBraced = temp[1:d]
				if not arrayIndexBraced:
					errorMessage = "ERROR in verifyInitialization() - out of the initialization statement <"+list2plaintext(item,"")+">, <"+list2plaintext(temp,"")+"> is not valid since it is blank"
					errorRoutine(errorMessage)
					return [False, False]
				# Recall that array index in initialization could also be dynamic, hence get their runtime value
				getRuntimeValueResult = getRuntimeValue(arrayIndexBraced)
				PRINT("getRuntimeValue(arrayIndexBraced=",arrayIndexBraced,") is getRuntimeValueResult =",getRuntimeValueResult)
				if getRuntimeValueResult[0] == False or getRuntimeValueResult[1] == LOGICAL_TEST_RESULT_INDETERMINATE:
					PRINT ("ERROR while calculating array index value after calling getRuntimeValue(",arrayIndexBraced,")")
					errorMessage = "ERROR in verifyInitialization() while calculating array index value after calling getRuntimeValue( <%s> )"%(list2plaintext(arrayIndexBraced,""))
					errorRoutine(errorMessage)
					return [False, False]
				elif not checkIfIntegral(getRuntimeValueResult[1]) or getRuntimeValueResult[1] <0:
					errorMessage = "ERROR in verifyInitialization() while calculating array index value after calling getRuntimeValue( <%s> ) - calculated array index <%d> is not allowed"%(list2plaintext(arrayIndexBraced,""),getRuntimeValueResult[1])
					errorRoutine(errorMessage)
					return [False, False]
				elif getRuntimeValueResult[0] == True:
					PRINT("SUCCESS in verifyInitialization() while calculating array index value after calling getRuntimeValue( <%s> )"%(list2plaintext(arrayIndexBraced,"")))
					arrayIndexCalculated.append(getRuntimeValueResult[1])
				else:
					OUTPUT("Unhandled case - exiting!!")
					sys.exit()
				temp = temp[d+1:]
			
			PRINT("The arrayIndexCalculated = ",arrayIndexCalculated)
			# Now that we have calculated the absolute numerical value of the index used in initialization, let's check if it is a valid index by comparing it 
			# with the arrayDimensions obtained from the Array header row.
			if len(arrayDimensionsWithinCommonPrefix)+len(arrayIndexCalculated)>len(arrayDimensions):
				errorMessage = "ERROR in verifyInitialization() - len(arrayDimensionsWithinCommonPrefix="+STR(arrayDimensionsWithinCommonPrefix)+")+len(arrayIndexCalculated="+STR(arrayIndexCalculated)+")>len(arrayDimensions="+STR(arrayDimensions)+")"
				errorRoutine(errorMessage)
				return [False, False]
			else:
				# Suppose it is a 2X3X4 array, but we have an indexed initialization statement like {[2][3]=90}.
				if len(arrayIndexCalculated)<len(arrayDimensions) and not (indexedVariableInitializationValue[0]=='{' and indexedVariableInitializationValue[-1]=='{'):
					errorMessage = "ERROR in verifyInitialization() - the array dimension in the header row is %s, but the explicit array index value value is <%s>, which is not OK unless the initialization value itself is a braced list (which is not the case here since indexedVariableInitializationValue = <%s>)"%(STR(arrayDimensions), STR(arrayIndexCalculated),list2plaintext(indexedVariableInitializationValue,""))
					errorRoutine(errorMessage)
					return [False, False]
				for i in range(len(arrayIndexCalculated)):
					if arrayIndexCalculated[i]>=arrayDimensions[i+len(arrayDimensionsWithinCommonPrefix)]:
						errorMessage = "ERROR in verifyInitialization() - for "+commonPrefix+", the explicit array index is "+STR(arrayIndexCalculated)+ ", which is greater than the "+STR(i)+"-th element of the  overall arrayDimensions of "+STR(arrayDimensions)+" ("+STR(arrayDimensions[i])+")"
						errorRoutine(errorMessage)
						return [False, False]

			variableNameToSearch = commonPrefix
			for d in arrayIndexCalculated:
				variableNameToSearch += "["+STR(d)+"]"
			PRINT("For indexed initialization, we are going to look for variableNameToSearch = <"+variableNameToSearch+">")
			
			# Now go down the unraveledSupplied from the rowNum, looking for the variableNameToSearch string in the unraveledVariableText field (element #1 in each row).
			# Now find the corresponding entry in unraveled
			PRINT("\nNow we are going to look for variableNameToSearch = <%s> in 2nd item of every subsequent row (from row # %d onwards"%(variableNameToSearch, rowNum))
			ancestryOfArrayHeaderRow = unraveledSupplied[rowNum][8]
			targetRowNumber = None
			r = rowNum + 1
			while True:
				if r>=len(unraveledSupplied):
					EXIT("Bad coding - must have other rows after the header row")
				ancestryOfCurrentRow = unraveledSupplied[r][8]
				unraveledVariableTextOfCurrentRow = unraveledSupplied[r][1]
				if len(ancestryOfCurrentRow)<len(ancestryOfArrayHeaderRow) or ancestryOfArrayHeaderRow != ancestryOfCurrentRow[:len(ancestryOfArrayHeaderRow)]:
					PRINT("Crossed the rows pertaining to this array")
					break	# Give up, we did not find the named variable row
				if ancestryOfArrayHeaderRow == ancestryOfCurrentRow: # Should happen automatically
					PRINT("For row # %d, comparing unraveledVariableTextOfCurrentRow = <%s> with variableNameToSearch = <%s>"%(r,unraveledVariableTextOfCurrentRow,variableNameToSearch))
					if variableNameToSearch == unraveledVariableTextOfCurrentRow[:len(variableNameToSearch)]:
						targetRowNumber = r
						break
					else:
						PRINT("For row # %d, unraveledVariableTextOfCurrentRow = <%s> does not match variableNameToSearch = <%s>"%(r,unraveledVariableTextOfCurrentRow,variableNameToSearch))
				r += 1
			if targetRowNumber == None:
				PRINT("\nPretty printed unraveled =")
				MUST_printUnraveled(unraveledSupplied)
				PRINT("\nRaw unraveled =")
				for unraveledRow in unraveledSupplied:
					PRINT(unraveledRow)
				errorMessage = "ERROR in verifyInitialization() - after exploring rows %d through %d in unraveled, could not locate a row unraveledVariableText starting with %s"%(nextPositionalRowNum, r, string2search)
				errorRoutine(errorMessage)
				return [False, False]

			PRINT("Calling verifyInitialization(unraveledSupplied, targetRowNumber=",targetRowNumber, "silent=","True" if silent else "False", ", indexedVariableInitializationValue =",indexedVariableInitializationValue,", variableNameToSearch =",variableNameToSearch,", arrayDimensionsSubsetSupplied =")
			result = verifyInitialization(unraveledSupplied, targetRowNumber, silent, indexedVariableInitializationValue, variableNameToSearch) 
			
			if result[0]!= True or result[1]!= True:
				warningMessage = "Warning in verifyInitialization() - the explicit-indexed array initialization statement <"+list2plaintext(item,"")+"> did not succeed"
				gVerificationWarningCount += 1
				if not silent and gVerificationWarningCount < VERIFICATION_WARNING_COUNT_MAX:
					warningRoutine(warningMessage)
				OUTPUT(warningMessage)
				return [result[0], False]
			else:
				lastRowNumConsumed = result[2]
				PRINT("explicit-indexed array variable initialization",list2plaintext(item,""),"succeeded, with lastRowNumConsumed =",lastRowNumConsumed)
				nextPositionalRowNum = lastRowNumConsumed + 1
				PRINT("Reset nextPositionalRowNum to",nextPositionalRowNum)
		
		###################################################################################
		### 	Neither a named, nor an indexed initialization. So, Positional it is	###
		###################################################################################
		else:
			PRINT(list2plaintext(item,""), "is not a named- or indexed- initialization - it is positional")
			PRINT("And the current nextPositionalRowNum =",nextPositionalRowNum)
			if item[0]=='{' and item[-1]=='}':	# Must be an array or struct
				if not isArray and not isStruct:
					errorMessage = "ERROR in verifyInitialization() - positional initialization value is a braced list but "+commonPrefix+" is neither array nor struct"
					errorRoutine(errorMessage)
					return [False, False]
				
				if unraveledSupplied[nextPositionalRowNum][6+DEFAULT_ENDIANNESS] == "":
					PRINT("Since the initialization value itself is another braced list, calling verifyInitialization() from next row")
					nextPositionalRowNum = nextPositionalRowNum + 1
				
				newCommonPrefix = commonPrefix
				
				# Update the commonPrefix
				if isArray:
					nextRowVariableNameQualified = unraveledSupplied[nextPositionalRowNum][1]
					if commonPrefix not in nextRowVariableNameQualified:
						errorMessage = "ERROR in verifyInitialization() - positional initialization value is a braced list but somehow the next row variable name <"+ nextRowVariableNameQualified + "> doesn't start with commonPrefix = <"+commonPrefix+">"
						errorRoutine(errorMessage)
						return [False, False]
					if nextRowVariableNameQualified[len(commonPrefix)]!="[":
						errorMessage = "ERROR in verifyInitialization() - positional initialization value is a braced list but somehow the next row variable name <"+ nextRowVariableNameQualified + "> doesn't start with commonPrefix = <"+commonPrefix+"> followed by a ["
						errorRoutine(errorMessage)
						return [False, False]
					newCommonPrefix = nextRowVariableNameQualified[ : len(commonPrefix)+nextRowVariableNameQualified[len(commonPrefix):].find(']')+1]
					PRINT("The newCommonPrefix = ",newCommonPrefix)
				
				result = verifyInitialization(unraveledSupplied, nextPositionalRowNum, silent, item, newCommonPrefix) 
				
				if result[0]!= True or result[1]!= True:
					warningMessage = "ERROR in verifyInitialization() - the positional array/struct initialization statement <"+list2plaintext(item,"")+"> did not succeed"
					gVerificationWarningCount += 1
					if not silent and gVerificationWarningCount < VERIFICATION_WARNING_COUNT_MAX:
						warningRoutine(warningMessage)
					PRINT(warningMessage)
					return [result[0], False]
				else:
					# Suppose we are looking for a struct like: 
					#	struct S { int i[3], float f;} V={ {10,15},30};
					# In the struct above, the struct member array i has 3 members but we only provided the initialization value for the first two, viz. {10,15}.
					# So, there will be 3 rows in the unraveled for the corresponding 3 members (with LE/BE values), but we will check the initialization
					# for only the first two rows and return the 2nd row's rowNum as the lastRowNumConsumed. The 3rd row will not get checked. 
					# Even though there is a 3rd initialization value provided (viz. 30), that will apply towards the float f - it will NOT apply to the i[2].
					# So, even though the  lastRowNumConsumed will point to i[1] (second array member), we cannot just say nextPositionalRowNum = lastRowNumConsumed +1
					# and let the next initialization test perform on that row, because in that case we would be wrongly comparing i[2] with 30, when in reality
					# we should be comparing f with 30. So, when the initialization value is a braced list, we need to update the nextPositionalRowNum to point
					# to the unraveled row with the next.
					lastRowNumConsumed = result[2]
					nextPositionalRowNum = lastRowNumConsumed + 1
					PRINT("Now upped the nextPositionalRowNum to lastRowNumConsumed (",lastRowNumConsumed,") + 1 =",nextPositionalRowNum)
			else:	# Not an array or struct
				# So we find the first non-blank value starting from nextPositionalRowNum
				PRINT("So we find the first non-blank value starting from nextPositionalRowNum =",nextPositionalRowNum)
				while True:
					if nextPositionalRowNum == len(unraveledSupplied):
						PRINT("Reached end of unraveled, so no longer incrementing current value of nextPositionalRowNum =",nextPositionalRowNum)
						break
					if unraveledSupplied[nextPositionalRowNum][6+DEFAULT_ENDIANNESS] != "":
						PRINT("Found unraveled row with non-blank LE/BE value, so stopping at nextPositionalRowNum =",nextPositionalRowNum)
						break
					else:
						nextPositionalRowNum += 1
						PRINT("Found unraveled row with blank LE/BE value, so increased nextPositionalRowNum to",nextPositionalRowNum)
				PRINT("Found the first non-blank value at nextPositionalRowNum =",nextPositionalRowNum)
				lastRowNumConsumed = nextPositionalRowNum
				row = unraveledSupplied[nextPositionalRowNum]
				rowVariableValue = row[6+DEFAULT_ENDIANNESS]
				PRINT("row =",row)
				# Simple test to check if the supplied initialization value matches the variable value. Note the extra bracing done, they are super-important
				combinedInitializationTest = ["(","("]+item + [")","==","(",rowVariableValue,")",")"]
				PRINT("Going to getRuntimeValue(combinedInitializationTest= <",list2plaintext(combinedInitializationTest),">)")
				getRuntimeValueResult = getRuntimeValue(combinedInitializationTest)
				PRINT("getRuntimeValue(combinedInitializationTest=",combinedInitializationTest,") is getRuntimeValueResult =",getRuntimeValueResult)
				if getRuntimeValueResult[0] == False or getRuntimeValueResult[1] == LOGICAL_TEST_RESULT_INDETERMINATE:
					PRINT ("ERROR while calculating initialization value after calling getRuntimeValue(",combinedInitializationTest,")")
					errorMessage = "ERROR in verifyInitialization() while calculating initialization value after calling getRuntimeValue( <%s> )"%(list2plaintext(combinedInitializationTest))
					errorRoutine(errorMessage)
					return [False, False]
				elif getRuntimeValueResult[1] == False:
					PRINT ("Failure while calculating initialization value after calling getRuntimeValue(",combinedInitializationTest,")")
					warningMessage = "Warning in verifyInitialization() while calculating initialization value after calling getRuntimeValue( <%s> ) - the comparison result is False"%(list2plaintext(combinedInitializationTest))
					gVerificationWarningCount += 1
					if not silent and gVerificationWarningCount < VERIFICATION_WARNING_COUNT_MAX:
						warningRoutine(warningMessage)
					PRINT(warningMessage)
					PRINT("Returning [True, False]")
					return [True, False]
				elif getRuntimeValueResult == [True, True]:
					PRINT("SUCCESS in verifyInitialization() - initialization test <%s> evaluates to True"%(list2plaintext(combinedInitializationTest)))
					PRINT("positional initialization with value",list2plaintext(item,""),"succeeded for nextPositionalRowNum =",nextPositionalRowNum,"!")
					nextPositionalRowNum = nextPositionalRowNum + 1
					PRINT("Reset nextPositionalRowNum to",nextPositionalRowNum)
					# We do NOT return success here; success message is sent only after evaluating ALL the items in the while loop
				else:
					OUTPUT("Unhandled case - exiting!!")
					sys.exit()

	# For array or structs, if we supplied a curly braced list with less numer of initialization values than the total number of array/struct members,
	# then we need to move the lastRowNumConsumed to the next row after all the rows corresponding to the struct/array
	if initializationValue[0]=='{' and initializationValue[-1]=='}':
		PRINT("Current value of lastRowNumConsumed =",lastRowNumConsumed)
		targetRowNumber = lastRowNumConsumed + 1
		while True:
			if targetRowNumber>=len(unraveledSupplied):
				PRINT("Reached end of unraveled, so resetting lastRowNumConsumed to",targetRowNumber-1)
				break
			elif unraveledSupplied[targetRowNumber][6+DEFAULT_ENDIANNESS] == "":	# Next blank header - will only work for new structs and arrays
				PRINT("Found a row with blank value, so resetting lastRowNumConsumed to",targetRowNumber-1)
				break
			ancestryOfCurrentRow = unraveledSupplied[targetRowNumber][8]
			if len(ancestryOfCurrentRow)<len(unraveledSupplied[rowNum][8]) or unraveledSupplied[rowNum][8] != ancestryOfCurrentRow[:len(unraveledSupplied[rowNum][8])]:
				PRINT("For rowNum",targetRowNumber,"crossed the rows pertaining to this array or struct")
				break	# Give up, we did not find the named variable row
			if isArray and not unraveledSupplied[targetRowNumber][1].startswith(commonPrefix):
				break
			targetRowNumber += 1
		lastRowNumConsumed = targetRowNumber - 1

	PRINT("\n","==="*25," returning from verifyInitialization() ","==="*25)
	# After all the items have been initializated
	return [True, True, lastRowNumConsumed]

###############################################################################################################
# This routine takes a variableId / variableDescription / full variableDeclarations entry, and adds all the "unraveled" variables to the supplied unraveled recursively.
# unraveled = [level, variable, datatype/Description, starting offset (inclusive), ending offset+1 (exclusive), Raw Hex Bytes, Value (LE), Value (BE), Ancestry]
# The last item in any row in unraveled - the ancestry - contains the variableId as the last item.
# However, the input ancestry to this routine does NOT have the variableId as the last item. Rather, it gets filled here only.
################################################################################################################
def addVariableToUnraveled(level, variableIdOrDescriptionOrEntry, prefix, offset, unraveledSupplied, ancestry=[], arrayAlreadyUnraveled = False, speculativeArrayDimensions=None):
#	PRINT=OUTPUT	# Will make ALL the PRINT statements execute
	global speculativeExecutionStack	# this list will contain a dict of keys {"variableId", "arrayDimensionValue", "lastValidUnraveledRowNum" etc.}
	initResult = None	# Result of any initialialization check
	if checkIfIntegral(variableIdOrDescriptionOrEntry):
		if variableId >= len(variableDeclarations):
			errorMessage = "ERROR in calling addVariableToUnraveled("+STR(level+1)+", "+ STR(variableId) + ", " + prefix + ", "+STR(offset)+","+STR(ancestry),", unraveledSupplied)"
			errorRoutine(errorMessage)
			return False
		variableId = variableIdOrDescriptionOrEntry
		variableDeclarationsEntry = deepCopy(variableDeclarations[variableId])
		variableDescription = variableDeclarationsEntry[4]
	elif isinstance(variableIdOrDescriptionOrEntry, dict):
		variableId = variableIdOrDescriptionOrEntry["variableId"]
		variableDeclarationsEntry = deepCopy(variableDeclarations[variableId])
		variableDeclarationsEntry[4] = variableIdOrDescriptionOrEntry
		variableDescription = variableDeclarationsEntry[4]
	elif isinstance(variableIdOrDescriptionOrEntry, list):
		variableDeclarationsEntry = variableIdOrDescriptionOrEntry
		variableDescription = variableDeclarationsEntry[4]
		variableId = variableDescription["variableId"]
	else:
		EXIT("Coding ERROR in addVariableToUnraveled: Passed variableIdOrDescription is neither an integer nor a list or dictionary")
	PRINT("\n\n","---"*50,"\nEntering addVariableToUnraveled (for level",level,", variable =",variableDeclarations[variableId][0]," (variableId =",variableId,"), prefix=<", prefix,">, ancestry =",ancestry, ")")
	PRINT("---"*50,"\nInput to addVariableToUnraveled() - level =",level, ", variableId =", variableId, ", type(variableId) = ",type(variableId), ", prefix =",prefix, ", offset =",offset,"ancestry =",STR(ancestry),", arrayAlreadyUnraveled =","True, " if arrayAlreadyUnraveled else "False, ",", speculativeArrayDimensions =", "None" if not speculativeArrayDimensions else STR(speculativeArrayDimensions))
	PRINT("\nunraveledSupplied (input to addVariableToUnraveled() routine) =\n\n")
	for row in unraveledSupplied:
		PRINT(row)
	PRINT("\n\n")

	dottedPrefixOrBlank = prefix + "." if prefix != "" else ""	#We do not blindly add the dot if the incoming prefix is blank

	variableName = variableDeclarationsEntry[0]
	variableSize = variableDeclarationsEntry[1]
	variableIsDynamic = variableDescription["isDynamic"]
	'''
	selectedVariable = deepCopy(variableDeclarations[variableId])
	if isinstance(variableIdOrDescription, dict):
		selectedVariable[4] = variableIdOrDescription
	variableName 					= selectedVariable[0]
	variableSize 					= selectedVariable[1]	# May be dynamic
	variableDescription 			= selectedVariable[4]	# May be dynamic
	variableIsDynamic				= selectedVariable[4]["isDynamic"]
	'''
	variableBaseType				= variableDescription["baseType"]	# For a declaration like int * pInt; baseType is int, but datatype is pointer
	variableDatatype				= variableDescription["datatype"]   # That's the difference between baseType and datatype
	if variableDescription["isArray"] and variableDescription["arrayDimensions"][0]==['TBD']: 
		if not speculativeArrayDimensions or not isinstance(speculativeArrayDimensions,list):
			if not arrayAlreadyUnraveled:	# We only flash this warning once
				warningMessage = "For variableName "+variableName+", array dimension is unspecified, but no speculativeArrayDimensions is supplied."	\
								+"\n\nWhich means, we will treat variableName "+variableName+" as an infinite array and keep mapping it until there is no more data to map."
				if not IN_DEMO:
					warningRoutine(warningMessage)
				variableDescription["arrayDimensions"][0] = LARGE_POSITIVE_NUMBER		# Basically, infinity
		elif not checkIfIntegral(speculativeArrayDimensions[0][0]) or speculativeArrayDimensions[0][0] <0:
			errorMessage = "ERROR in addVariableToUnraveled(): For variableName "+variableName+", array dimension is "+STR(variableDescription["arrayDimensions"])+", but the supplied speculativeArrayDimensions ("+STR(speculativeArrayDimensions[0][0])+")is illegal"
			errorRoutine(errorMessage)
			return False
		else:
			variableDescription["arrayDimensions"] = deepCopy(speculativeArrayDimensions)
			PRINT("Speculation in addVariableToUnraveled(): For variableName "+variableName+", array dimension is now "+STR(variableDescription["arrayDimensions"])+" after using the supplied speculativeArrayDimensions ("+STR(speculativeArrayDimensions)+")")
	PRINT ("variableName = ",variableName)
	PRINT ("variableBaseType = ",variableBaseType)
	PRINT ("variableDatatype = ",variableDatatype)
	PRINT ("variableDescription =",variableDescription)

	# Find out if this variable is the initialization partner of a blank-dimension-array variable
	isInitializationPartner = False
	silent = False
	if blankArraysAndTerminationInfo: 
		for blankDimensionArrayVariableId in getDictKeyList(blankArraysAndTerminationInfo):
			if blankDimensionArrayVariableId != blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["blankDimensionArrayVariableId"]:
				EXIT("Bad coding - blankDimensionArrayVariableId != blankArraysAndTerminationInfo[blankDimensionArrayVariableId][\"blankDimensionArrayVariableId\"]")
			partnerVariableId = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["partnerVariableId"]
			if variableId == partnerVariableId:
				isInitializationPartner = True
				silent = True	# We do not want to throw a warning if we are just speculating
				PRINT("The variable",variableName,"(id",variableId,") is the initialization partner",variableDeclarations[partnerVariableId][0],"(id",partnerVariableId,") of a blank array variable", variableDeclarations[blankDimensionArrayVariableId][0],"(id",blankDimensionArrayVariableId,")")
				if not executionStateStack:
					errorMessage = "ERROR in addVariableToUnraveled(): For Regular struct "+variableDatatype+" variable "+variableName+", it is the initialization partner of a blank-dimension-array variable, but there is no state in executionStateStack[]"
					errorRoutine(errorMessage)
				break


	# The point of the arrayAlreadyUnraveled flag is to stop infinite recursion. Without this flag, this routine will see the variableDescription["isArray"] every time
	# and will just keep on recursing
	if variableDescription["isArray"] and not arrayAlreadyUnraveled:
		arrayElementSize = variableDescription["arrayElementSize"]	# The array element itself might be a struct, hence its element size could be Dynamic
		arrayDimensions = variableDescription["arrayDimensions"]	# The array dimensions might be dynamic
		PRINT("variableId", variableId,"(",variableName,") is an array with arrayElementSize =",arrayElementSize,"arrayDimensions =",arrayDimensions)
		PRINT("Global variableDeclarations[variableId][4][\"arrayDimensions\"] =",variableDeclarations[variableId][4]["arrayDimensions"])

		# It is entirely possible that the arrayDimensions will contain dynamic entities. So, resolve them right here.
		for arrayIndex in range(len(arrayDimensions)):
			dimension = arrayDimensions[arrayIndex]
			if checkIfIntegral(dimension):
				PRINT("For variable",variableId,"(",variableName,") array dimension", dimension,"is integral - no need to evaluate")
				continue
			elif dimension == LARGE_POSITIVE_NUMBER or dimension == ['TBD']:		# Basically, infinity:
				if arrayIndex != 0:
					errorMessage = "ERROR in addVariableToUnraveled() - array index of 'TBD' only allowed as the first dimension (arrayDimensions = %s)"%STR(arrayDimensions)
					errorRoutine(errorMessage)
					return False
				else:
					PRINT("For variable",variableId,"(",variableName,"), we have a 'TBD' array dimension, so we will be doing speculative execution on that one")
					arrayDimensions[arrayIndex] = LARGE_POSITIVE_NUMBER		# Basically, infinity
					continue
			else:
				PRINT("For variable",variableId,"(",variableName,") array dimension", dimension,"is NOT integral - need to evaluate")
				getRuntimeValueResult = getRuntimeValue(dimension)
				PRINT("For variableName =",variableName,"(variableId=",variableId,"), getRuntimeValue(dimension=",dimension,") is getRuntimeValueResult =",getRuntimeValueResult)
				if getRuntimeValueResult[0] == False:
					errorMessage = "ERROR in addVariableToUnraveled(): for variableName = "+variableName+" (variableId="+STR(variableId)+"), while calculating dimension value after calling getRuntimeValue( <%s> )"%(list2plaintext(dimension,""))
					errorRoutine(errorMessage)
					return False
				elif getRuntimeValueResult[1] == LOGICAL_TEST_RESULT_INDETERMINATE: 
					errorMessage = "ERROR in addVariableToUnraveled(): for variableName = "+variableName+" (variableId="+STR(variableId)+"), while calculating dimension value after calling getRuntimeValue( <%s> )"%(list2plaintext(dimension,""))
					errorRoutine(errorMessage)
					return False
				elif not checkIfIntegral(getRuntimeValueResult[1]) or getRuntimeValueResult[1] <1:
					errorMessage = "ERROR in addVariableToUnraveled(): for variableName = "+variableName+" (variableId="+STR(variableId)+"), while calculating dimension value after calling getRuntimeValue( <%s> ) - calculated dimension <%d> is not allowed"%(list2plaintext(dimension,""),getRuntimeValueResult[1])
					errorRoutine(errorMessage)
					return False
				elif getRuntimeValueResult[0] == True:
					PRINT("SUCCESS in addVariableToUnraveled(): for variableName = "+variableName+" (variableId="+STR(variableId)+"), while calculating dimension value after calling getRuntimeValue( <%s> )"%(list2plaintext(dimension,"")))
					dimension = getRuntimeValueResult[1]
					arrayDimensions[arrayIndex] = dimension
				else:
					EXIT("Unknown code branch")
				
		
		# Once possible dynamic values have been resolved, plug it back to the local copy of variableDescription immediately
		PRINT("After resolving possible runtime values, arrayDimensions =",arrayDimensions,", and speculativeArrayDimensions =","None" if speculativeArrayDimensions == None else speculativeArrayDimensions)
		variableDescription["arrayDimensions"] = arrayDimensions
		totalNumberOfArrayElements = listItemsProduct(arrayDimensions)	# Now, arrayDimensions must have all resolved, integral values. Only hard constants, no more variables
		if totalNumberOfArrayElements == False:
			errorMessage = "ERROR in addVariableToUnraveled("+STR(level+1)+", "+ STR(variableId) + ", " + prefix + ", "+STR(offset)+","+STR(ancestry),", unraveledSupplied) - for array variable "+variableName+", we have indeterminate dimensions: "+STR(arrayDimensions)
			errorRoutine(errorMessage)
			return False
		dimensionsText = "infinite" if arrayDimensions[0] == LARGE_POSITIVE_NUMBER else STR(arrayDimensions[0])
		for d in range(1,len(arrayDimensions)):
			dimensionsText += " X "+ STR(arrayDimensions[d])
		dataTypeText = "unsigned" + " " + variableDatatype if variableDatatype != "pointer" and variableDescription["signedOrUnsigned"] == "unsigned" else variableDatatype
		arrayDescriptionText = dottedPrefixOrBlank + variableName + " - Array of "+ dimensionsText + " " + dataTypeText + "s"
		
		# First add the "Overall" array header statement. This will have no "values", since array as a whole does not have any meaningful value.
		# By now, we know how many array elements will be there (even if it is a dynamic array). Which means, totalNumberOfArrayElements is now no longer dynamic.
		# However, even though totalNumberOfArrayElements is now a numeric, note that arrayElementSize itself may be dynamic, if that is an array of dynamic structs. 
		# So, the length of each array element might be different and it is impossible to know beforehand what it's going to be.
		# Therefore, the total length of the overall array is also going to be "TBD"
		if checkIfIntegral(arrayElementSize) and not variableIsDynamic:
			unraveledSupplied.append([level,arrayDescriptionText,variableDescription, offset, offset+arrayElementSize*totalNumberOfArrayElements,"","","", ancestry+[variableId]])
		else:
			unraveledSupplied.append([level,arrayDescriptionText,variableDescription, offset, "","","","", ancestry+[variableId]])	# Must be updated later.
		rowNumberOfArrayHeaderRowWithBlankEndAddr = len(unraveledSupplied)-1	# We need to note this so that we can come back later to update this row
		PRINT("Kept a note of the header row #",rowNumberOfArrayHeaderRowWithBlankEndAddr,"for  variable" + variableName)

		position = 0
		while True:
			PRINT("position = ",position)
			if position >= totalNumberOfArrayElements:
				break
			arrayIndices = calculateArrayIndicesFromPosition(arrayDimensions, position)
			arrayIndicesCStyle = ""	# We convert the [i,j,k] to C-style [i][j][k]
			for item in arrayIndices:
				arrayIndicesCStyle += "["+STR(item)+"]"
			arrayElementIndexDescription = dottedPrefixOrBlank + STR(variableName) + arrayIndicesCStyle
			
			if position == 0:
				elementOffset = offset
			elif checkIfIntegral(arrayElementSize) and not variableIsDynamic:
				elementOffset = offset + position * arrayElementSize
			else:
				minOrMaxValueInColumnResult = minOrMaxValueInColumn(unraveledSupplied, 4, "max")	# The Addr end (exclusive) is the column #4 in unraveled
				if minOrMaxValueInColumnResult[0] != True:
					errorMessage = "ERROR in addVariableToUnraveled() - for variable " + variableName + ", could not calculate the max end addr before adding element # "+STR(position)
					errorRoutine(errorMessage)
					OUTPUT("\nunraveledSupplied =")
					for row in unraveledSupplied:
						OUTPUT(row)
					return False
				else:
					maxEndAddrInUnraveledSupplied = minOrMaxValueInColumnResult[1]
					elementOffset = maxEndAddrInUnraveledSupplied
					PRINT("maxEndAddrInUnraveledSupplied = ",maxEndAddrInUnraveledSupplied, ", dataFileSizeInBytes =",dataFileSizeInBytes)
					if arrayDimensions[0] == LARGE_POSITIVE_NUMBER and maxEndAddrInUnraveledSupplied >= dataFileSizeInBytes:
						break
	
			# For an array, we have to directly add ALL the array elements to unraveled right here. Why can't we call addVariableToUnraveled() recursively?
			# That's because, when we will pass the variableId to addVariableToUnraveled(), it will again see that variableId is an array, so we will get
			# stuck in an ifinite loop. To save us from that, we have to add all the array elements right here (unless the datatype is struct, of course,
			# in which case we will have to call the addVariableToUnraveled() recursively anyway.
			# That is not a problem for dynamic arrays, since we will never have situations such that only half the array elements would need to be added.
			# Either ALL the array elements gets added and their individual values calcualted, or none. So, doing it collectively in one go is fine.
			# This is different from struct, because in case of a struct we may not execute all the struct members due to runtime conditions.
			
			addVariableToUnraveledResult = addVariableToUnraveled(level+1, variableDeclarationsEntry, arrayElementIndexDescription, elementOffset, unraveledSupplied, ancestry, True, speculativeArrayDimensions)
			if addVariableToUnraveledResult == False:
				errorMessage = "ERROR in addVariableToUnraveled() - for array variable " + variableName + ", encountered error while trying to add the array element "+arrayElementIndexDescription
				errorRoutine(errorMessage)
				return False
			else:
				unraveledSupplied = addVariableToUnraveledResult[0]
				PRINT("Last unraveled row added was row #",len(unraveledSupplied)," =\n", unraveledSupplied[-1])
				initResult = False if initResult == False else addVariableToUnraveledResult[1] if addVariableToUnraveledResult[1] in (True, False) else initResult

			position += 1	# Increment the loop counter
			
		# Where the array element itself is of variable size, we go back and update the array header row with the max end Addr
#		if not checkIfIntegral(arrayElementSize) or variableIsDynamic:
		if unraveledSupplied[rowNumberOfArrayHeaderRowWithBlankEndAddr][4] == "":	# The end addr column for the array header row is blank
			PRINT("The end addr column for the array header row is blank for",variableName," - now filling it")
			minOrMaxValueInColumnResult = minOrMaxValueInColumn(unraveledSupplied, 4, "max")	# The Addr end (exclusive) is the column #4 in unraveled
			if minOrMaxValueInColumnResult[0] != True:
				errorMessage = "ERROR in addVariableToUnraveled() - for array variable " + variableName + ", could not calculate the max end addr before going back to update the array header row in unraveled with it"
				errorRoutine(errorMessage)
				return False
			else:
				maxEndAddrInUnraveledSupplied = minOrMaxValueInColumnResult[1]
				unraveledSupplied[rowNumberOfArrayHeaderRowWithBlankEndAddr][4] = maxEndAddrInUnraveledSupplied
		else:
			PRINT("unraveled[rowNumberOfArrayHeaderRowWithBlankEndAddr =",rowNumberOfArrayHeaderRowWithBlankEndAddr,"][4] is not blank - nothing to update!")
			PRINT(unraveledSupplied[rowNumberOfArrayHeaderRowWithBlankEndAddr][4])

		# After all the individual members are added to unraveled, check if there is any Array-level initialization
		if variableDeclarations[variableId][4]["isInitialized"]:
			PRINT("\nFrom addVariableToUnraveled(), calling verifyInitialization() for array variable",variableName, "unraveledSupplied[rowNumberOfArrayHeaderRow=",rowNumberOfArrayHeaderRowWithBlankEndAddr,"] =\n",unraveledSupplied[rowNumberOfArrayHeaderRowWithBlankEndAddr],"\n")
			verifyInitializationResult = verifyInitialization(unraveledSupplied, rowNumberOfArrayHeaderRowWithBlankEndAddr, silent)
			PRINT("verifyInitializationResult =",verifyInitializationResult)
			if verifyInitializationResult[0] == False:
				errorMessage = "ERROR in addVariableToUnraveled(): For "+variableDatatype+" array variable "+variableName+", error occurred after trying to check initialization via calling verifyInitialization()"
				errorRoutine(errorMessage)
				return False
			elif verifyInitializationResult[1] == False:
				warningMessage = "Warning in addVariableToUnraveled(): For "+variableDatatype+" array variable "+variableName+", initialization check failed after calling verifyInitialization()"
				
				if not silent and gVerificationWarningCount < VERIFICATION_WARNING_COUNT_MAX:
					warningRoutine(warningMessage)
				OUTPUT(warningRoutine)
			elif verifyInitializationResult[1] == True:
				PRINT("SUCCESS in addVariableToUnraveled(): For "+variableDatatype+" array variable "+variableName+", initialization check succeeded after calling verifyInitialization()")
			else:
				EXIT("Coding bug in addVariableToUnraveled(): Exiting")
			initResult = False if initResult == False else verifyInitializationResult[1] if verifyInitializationResult[1] in (True, False) else initResult
		
	
	# For Dynamic structs, all the updation of unraveledSupplied happens inside the calculateStructLength() routine
	elif variableDatatype in getDictKeyList(suDict) and structuresAndUnions[suDict[variableDatatype][-1]]["isDynamic"]:	# Dynamic structs
		PRINT("The datatype of variable", variableName,"is Dynamic structure",variableDatatype," - calling calculateStructureLength() to update unraveled")
		
		# This is to handle a special case where it is an array of struc. If it is array, then we know that array unraveling takes precedence over struc unraveling,
		# and after array unvaleing there is no need to re-add the variable name. Otherwise, it may look something like var1[0][1].var1
		modifiedPrefix = prefix if variableDescription["isArray"] else dottedPrefixOrBlank+variableName
		PRINT("variableName =",variableName,", prefix = ",prefix,", modifiedPrefix =", modifiedPrefix)
		
#		calculateStructureLengthResult = calculateStructureLength(variableDatatype, level, variableId, modifiedPrefix, offset, unraveledSupplied, ancestry)		# BUG??????
		calculateStructureLengthResult = calculateStructureLength(variableDatatype, level, variableId, modifiedPrefix, offset, unraveledSupplied, ancestry+[variableId])
		if calculateStructureLengthResult == False or calculateStructureLengthResult[0] != True:
#			errorMessage = "ERROR in addVariableToUnraveled(): After calling calculateStructureLengthResult("+variableDatatype+","+STR(level)+", "+ STR(variableId) + ", " + prefix + ", "+STR(offset)+", unraveledSupplied, "+STR(ancestry)+")"
			errorMessage = "ERROR in addVariableToUnraveled(): After calling calculateStructureLengthResult("+variableDatatype+","+STR(level)+", "+ STR(variableId) + ", " + prefix + ", "+STR(offset)+", unraveledSupplied, "+STR(ancestry+[variableId])+")"
			errorRoutine(errorMessage)
			return False
		else:
			structSizeBytes = calculateStructureLengthResult[1]
			unraveledSupplied = calculateStructureLengthResult[2]
			initResult = False if initResult == False else calculateStructureLengthResult[3] if calculateStructureLengthResult[3] in (True, False) else initResult
			PRINT("Within addVariableToUnraveled(), after calling calculateStructureLength() for variable", variableDeclarations[variableId][0],"(variableId =",variableId,"), unraveled =")
			printUnraveled(unraveledSupplied)

		# After all the individual members are added to unraveled (in calculateStructureLength() routine), check if there is any struct-level initialization
		# If we have an array of struct variables that is initialized, we want to call the verifyInitialization() after the array, not the struct.
		if variableDeclarations[variableId][4]["isInitialized"] and not variableDescription["isArray"]:
			PRINT("\nFrom addVariableToUnraveled(), calling verifyInitialization() for variable",variableName,"of type Dynamic struct",variableDatatype,"with unraveledSupplied[structHeaderRowNum=",structHeaderRowNum,"] =\n",unraveledSupplied[structHeaderRowNum],"\n")
			verifyInitializationResult = verifyInitialization(unraveledSupplied, structHeaderRowNum, silent)
			if verifyInitializationResult[0] == False:
				errorMessage = "ERROR in addVariableToUnraveled(): For dynamic struct "+variableDatatype+" variable "+variableName+", error occurred after trying to check initialization via calling verifyInitialization()"
				errorRoutine(errorMessage)
				return False
			elif verifyInitializationResult[1] == False:
				warningMessage = "Warning in addVariableToUnraveled(): For dynamic struct "+variableDatatype+" variable "+variableName+", initialization check failed after calling verifyInitialization()"
				if not silent and gVerificationWarningCount < VERIFICATION_WARNING_COUNT_MAX:
					warningRoutine(warningMessage)
				OUTPUT(warningMessage)
			elif verifyInitializationResult[1] == True:
				PRINT("SUCCESS in addVariableToUnraveled(): For dynamic struct "+variableDatatype+" variable "+variableName+", initialization check succeeded after calling verifyInitialization()")
			else:
				OUTPUT("Coding bug in addVariableToUnraveled() for Dynamic struct: Exiting")
				sys.exit()
			initResult = False if initResult == False else verifyInitializationResult[1] if verifyInitializationResult[1] in (True, False) else initResult

		
	elif variableDatatype in getDictKeyList(suDict) and not structuresAndUnions[suDict[variableDatatype][-1]]["isDynamic"]:	# Regular structs
		PRINT("The datatype of variable", variableName," is a non-dynamic structure",variableDatatype," - calling calculateStructureLength() to update unraveled")
		structName = variableDatatype
		structOrUnionType = structuresAndUnions[suDict[structName][-1]]["type"]
		structSizeBytes = structuresAndUnions[suDict[structName][-1]]["size"]
		
		# This is to handle a special case where it is an array of struc. If it is array, then we know that array unraveling takes precedence over struc unraveling,
		# and after array unvaleing there is no need to re-add the variable name. Otherwise, it may look something like var1[0][1].var1
		modifiedPrefix = prefix if variableDescription["isArray"] else dottedPrefixOrBlank+variableName
		PRINT("variableName =",variableName,", prefix = ",prefix,", modifiedPrefix =", modifiedPrefix)
	
		# Add the struct to the unraveled at the given level
		PRINT("Executing unraveledSupplied.append([level=",level,",dottedPrefixOrBlank+variableName =",dottedPrefixOrBlank+variableName+" is of type "+structOrUnionType,structName, ",offset =",offset, ",offset+structSizeBytes =",offset+structSizeBytes,"]")
#		unraveledSupplied.append([level,dottedPrefixOrBlank+variableName+" is of type "+structOrUnionType,structName, offset, offset+structSizeBytes,"","",""])
		PRINT("Before adding the struct header record for variableDatatype =",variableDatatype,", the ancestry+[variableId=",variableId,"] =",ancestry+[variableId])
		unraveledSupplied.append([level,modifiedPrefix+" is of type "+structOrUnionType,structName, offset, offset+structSizeBytes,"","","",ancestry+[variableId]])
		structHeaderRowNum = len(unraveledSupplied)-1	# We need this in case this struct is initialized with named variables
		PRINT("\ndatatype",variableDatatype,"is ",structOrUnionType," - calling addVariableToUnraveled() for each member.")
		
		PRINT("Going to iterate over",len(structuresAndUnions[suDict[structName][-1]]["components"]),"components of",structName)
		N = 0
		while N < len(structuresAndUnions[suDict[structName][-1]]["components"]):
			PRINT("Component #",N)
			structMember = structuresAndUnions[suDict[structName][-1]]["components"][N]
			PRINT ("\nInside addVariableToUnraveled(), Processing from structMember =",structMember )
			structMemberVariableName 		= structMember[0]
			structMemberSizeBytes 			= structMember[1]
			structMemberDescription 		= structMember[4]
			structMemberBaseType			= structMemberDescription["baseType"]
			structMemberDatatype			= structMemberDescription["datatype"]
			structMemberVariableId			= structMemberDescription["variableId"]
			if structMemberVariableName.startswith(dummyUnnamedBitfieldNamePrefix):
				PRINT ("Omitting structMemberVariableName =",structMemberVariableName)
			else:
			
				# The offsetWithinStruct only makes sense for non-bitfield items. For bitfields, it is bitOffsetWithinStruct. And, we will handle the bitOffsetWithinStruct
				# when we will call addVariableToUnraveled() for the bitfield member. So, the rule of thumb is - 
				# - If the struct member is not a bitfield, pass the (offset + offsetWithinStruct) as the new offset to the addVariableToUnraveled(). 
				# - If the struct member is a bitfield, pass the (offset) as the new offset to the addVariableToUnraveled(). 
				offsetWithinStruct 	= structMemberDescription["offsetWithinStruct"]
				modifiedOffsetValue = offset if structMemberDescription["isBitField"] else offset + offsetWithinStruct

				PRINT("Calling addVariableToUnraveled(level="+STR(level+1)+", structMemberVariableId="+ STR(structMemberVariableId) + "("+structMemberVariableName+"), modifiedPrefix=" + modifiedPrefix,", modifiedOffsetValue ="+STR(modifiedOffsetValue)+", unraveledSupplied, ancestryStructMember =",STR(ancestry+[variableId]),")")
				addVariableToUnraveledResult = addVariableToUnraveled(level+1, structMember, modifiedPrefix, modifiedOffsetValue, unraveledSupplied, ancestry+[variableId])
				
				if addVariableToUnraveledResult == False:
					errorMessage = "ERROR in addVariableToUnraveled(): calling addVariableToUnraveled("+STR(level+1)+", "+ STR(structMemberVariableId) + ", " + modifiedPrefix + ", "+STR(modifiedOffsetValue)+", unraveledSupplied"+STR(ancestry+[variableId])+")"
					errorRoutine(errorMessage)
					return False
				else:
					unraveledSupplied = addVariableToUnraveledResult[0]
					initResult = False if initResult == False else addVariableToUnraveledResult[1] if addVariableToUnraveledResult[1] in (True, False) else initResult

			PRINT ("\nfor variableName =", variableName,", for N =",N,", structMemberVariableName =",structMemberVariableName,", structMemberVariableId =",structMemberVariableId,", structMemberDatatype =",structMemberDatatype,", offsetWithinStruct =",offsetWithinStruct,", structMemberDescription =",structMemberDescription)
			N += 1
		# After all the individual members are added to unraveled, check if there is any struct-level initialization
		# If we have an array of struct variables that is initialized, we want to call the verifyInitialization() after the array, not the struct.
		if variableDeclarations[variableId][4]["isInitialized"] and not variableDescription["isArray"]:
			PRINT("\nFrom addVariableToUnraveled(), calling verifyInitialization() for variable",variableName,"of type regular struct",variableDatatype,"with unraveledSupplied[structHeaderRowNum=",structHeaderRowNum,"] =\n",unraveledSupplied[structHeaderRowNum],"\n")
			verifyInitializationResult = verifyInitialization(unraveledSupplied, structHeaderRowNum, silent)
			if verifyInitializationResult[0] == False:
				errorMessage = "ERROR in addVariableToUnraveled(): For Regular struct "+variableDatatype+" variable "+variableName+", error occurred after trying to check initialization via calling verifyInitialization()"
				errorRoutine(errorMessage)
				return False
			elif verifyInitializationResult[1] == False:
				warningMessage = "Warning in addVariableToUnraveled(): For Regular struct "+variableDatatype+" variable "+variableName+", initialization check failed after calling verifyInitialization()"
				OUTPUT(warningMessage)
				if not isInitializationPartner:
					warningRoutine(warningMessage)
			elif verifyInitializationResult[1] == True:
				PRINT("SUCCESS in addVariableToUnraveled(): For Regular struct "+variableDatatype+" variable "+variableName+", initialization check succeeded after calling verifyInitialization()")
			else:
				OUTPUT("Coding bug in addVariableToUnraveled() for Regular struct: Exiting")
				sys.exit()
			initResult = False if initResult == False else verifyInitializationResult[1] if verifyInitializationResult[1] in (True, False) else initResult

		
	elif variableDescription["isBitField"]:
		if ("offsetWithinStruct" not in getDictKeyList(variableDescription)) or ("bitOffsetWithinStruct" not in getDictKeyList(variableDescription)) or ("bitFieldWidth" not in getDictKeyList(variableDescription)):
			missingFields = "" 
			missingFields += " " + "bitFieldWidth"         if "bitFieldWidth"         not in getDictKeyList(variableDescription) else ""
			missingFields += " " + "offsetWithinStruct"    if "offsetWithinStruct"    not in getDictKeyList(variableDescription) else ""
			missingFields += " " + "bitOffsetWithinStruct" if "bitOffsetWithinStruct" not in getDictKeyList(variableDescription) else ""
			OUTPUT("For",variableName,"variableDescription =",variableDescription)
			errorMessage = "ERROR in addVariableToUnraveled(): "+variableName+" is a bitfield without <"+missingFields+">"
			errorRoutine(errorMessage)
			sys.exit()
		else:
			offsetWithinStruct = variableDescription["offsetWithinStruct"]		# Recall that this is constructed using the old method. The new method calculated bits
			bitOffsetWithinStruct = variableDescription["bitOffsetWithinStruct"]
			bitFieldWidth = variableDescription["bitFieldWidth"]
			if not checkIfIntegral(bitFieldWidth):
				getRuntimeValueResult = getRuntimeValue(bitFieldWidth)
				PRINT("For variableName =",variableName,"(variableId=",variableId,"), getRuntimeValue(bitFieldWidth=",bitFieldWidth,") is getRuntimeValueResult =",getRuntimeValueResult)
				if getRuntimeValueResult[0] == False:
					errorMessage = "ERROR in addVariableToUnraveled(): for variableName = "+variableName+" (variableId="+STR(variableId)+"), while calculating bitFieldWidth value after calling getRuntimeValue( <%s> )"%(list2plaintext(bitFieldWidth,""))
					errorRoutine(errorMessage)
					return False
				elif getRuntimeValueResult[1] == LOGICAL_TEST_RESULT_INDETERMINATE: 
					errorMessage = "ERROR in addVariableToUnraveled(): for variableName = "+variableName+" (variableId="+STR(variableId)+"), while calculating bitFieldWidth value after calling getRuntimeValue( <%s> )"%(list2plaintext(bitFieldWidth,""))
					errorRoutine(errorMessage)
					return False
				elif not checkIfIntegral(getRuntimeValueResult[1]) or getRuntimeValueResult[1] <1:
					errorMessage = "ERROR in addVariableToUnraveled(): for variableName = "+variableName+" (variableId="+STR(variableId)+"), while calculating bitFieldWidth value after calling getRuntimeValue( <%s> ) - calculated bitFieldWidth <%d> is not allowed"%(list2plaintext(bitFieldWidth,""),getRuntimeValueResult[1])
					errorRoutine(errorMessage)
					return False
				elif getRuntimeValueResult[0] == True:
					PRINT("SUCCESS in addVariableToUnraveled(): for variableName = "+variableName+" (variableId="+STR(variableId)+"), while calculating bitFieldWidth value after calling getRuntimeValue( <%s> )"%(list2plaintext(bitFieldWidth,"")))
					bitFieldWidth = getRuntimeValueResult[1]
				else:
					EXIT("Unknown code branch in addVariableToUnraveled() for bitFieldWidth")
				
			PRINT("\nFor bitfield variableName =",variableName,", offsetWithinStruct =",offsetWithinStruct, ", bitOffsetWithinStruct =",bitOffsetWithinStruct, ", bitFieldWidth =",bitFieldWidth)
			
		# If it is a packed bitfield variable that spills over two containers, we start from the very byte that the variable starts from
		# Yes, this means the Big-Endian values would be garbage.
		if integerDivision(bitOffsetWithinStruct, primitiveDatatypeLength[variableDatatype]*BITS_IN_BYTE) < integerDivision(bitOffsetWithinStruct+bitFieldWidth-1, primitiveDatatypeLength[variableDatatype]*BITS_IN_BYTE):
			PRINT("Bitfield",variableName,"seems to be a packed variable that spreads over two",variableDatatype,"containers (from ",bit2ByteAndBit(bitOffsetWithinStruct)," through ", bit2ByteAndBit(bitOffsetWithinStruct+bitFieldWidth-1),"). Its Big-Endian value is not implemented yet and should be considered garbage")
#			unraveledSupplied.append([level, dottedPrefixOrBlank+variableName,variableDescription, offset+bit2Byte(bitOffsetWithinStruct), offset+bit2Byte(bitOffsetWithinStruct)+primitiveDatatypeLength[variableDatatype] ])
#			unraveledSupplied.append([level, dottedPrefixOrBlank+variableName,variableDescription, offset+offsetWithinStruct, offset+bit2Byte(bitOffsetWithinStruct)+primitiveDatatypeLength[variableDatatype] ])	# BUG????
			unraveledSupplied.append([level, dottedPrefixOrBlank+variableName,variableDescription, offset+offsetWithinStruct, offset+offsetWithinStruct+bit2Byte((bitOffsetWithinStruct%BITS_IN_BYTE)+bitFieldWidth-1)+1])
		else:	# It's contained within the same container (most common case)
			PRINT("Executing unraveledSupplied.append([level =",level,", dottedPrefixOrBlank+variableName =",dottedPrefixOrBlank+variableName,"variableDescription, offset(",offset,")+offsetWithinStruct(",offsetWithinStruct,") =",offset+offsetWithinStruct, ", offset(",offset,")+offsetWithinStruct(",offsetWithinStruct,")+variableSize(",variableSize,") =",offset+offsetWithinStruct+variableSize," ]")
#			unraveledSupplied.append([level, dottedPrefixOrBlank+variableName,variableDescription, offset+offsetWithinStruct, offset+offsetWithinStruct+variableSize ])	# BUG????
			unraveledSupplied.append([level, dottedPrefixOrBlank+variableName,variableDescription, offset+offsetWithinStruct, offset+offsetWithinStruct+bit2Byte((bitOffsetWithinStruct%BITS_IN_BYTE)+bitFieldWidth-1)+1])

		# Sanity check
		if variableSize != primitiveDatatypeLength[variableDatatype]:
			EXIT("\n\nERROR in addVariableToUnraveled() - for variable", variableName,"( variableId =",variableId,"), variableSize (",variableSize,") != primitiveDatatypeLength[variableDatatype=",variableDatatype,"] = ",primitiveDatatypeLength[variableDatatype],"\n\n")
		else:
			PRINT("\n\nFor variable", variableName,"( variableId =",variableId,"), variableSize (",variableSize,") == primitiveDatatypeLength[variableDatatype=",variableDatatype,"] = ",primitiveDatatypeLength[variableDatatype],"\n\n")

		
	else:
		size = 0
		PRINT("\nvariableDatatype is",variableDatatype," Adding variableName =",variableName,"to unraveledSupplied[] at level", level)
		if variableDatatype.startswith("function"):
			if variableSize != 0:
				OUTPUT("Coding bug!!!")
				sys.exit()
		elif variableDatatype in getDictKeyList(primitiveDatatypeLength):
			if variableDescription["isArray"]:
				size = primitiveDatatypeLength[variableDatatype]
			elif variableSize != primitiveDatatypeLength[variableDatatype]:
				EXIT("Coding bug in addVariableToUnraveled()!!!")
			else:
				size = variableSize
		else:
			errorMessage = "ERROR in addVariableToUnraveled(): "+variableName+" has unknown variableDatatype "+variableDatatype
			errorRoutine(errorMessage)
			sys.exit()

		# Now add the begin-address and end-address+1
			
		prefixedVariableName = prefix if variableDescription["isArray"] and arrayAlreadyUnraveled else dottedPrefixOrBlank+variableName
		PRINT("Executing unraveledSupplied.append([level=",level, "prefixedVariableName =",prefixedVariableName,"variableDescription, offset =",offset, ", offset+size =",offset+size,"]")
		unraveledSupplied.append([level, prefixedVariableName,variableDescription, offset, offset+size])

	# Address Sanity check
	if unraveledSupplied[-1][3]>unraveledSupplied[-1][4]:
		OUTPUT("\n\nThe last record of unraveledSupplied =\n", unraveledSupplied[-1])
		EXIT ("\nERROR in addVariableToUnraveled() - for variableName = "+variableName+" (variableId = "+STR(variableId)+"), somehow the start data offset is greater than the end data offset")
		
	# If there is new data to be mapped, add it
	minOrMaxValueInColumnResult = minOrMaxValueInColumn(unraveledSupplied, 3, "min")	# The Addr start (inclusive) is the column #3 in unraveled
	if minOrMaxValueInColumnResult[0] != True:
		errorMessage = "ERROR in addVariableToUnraveled() - while trying to calculate the min start address (in order to update the dataBlock)"
		errorRoutine(errorMessage)
		return False
	else:
		minStartOffsetInclusive = minOrMaxValueInColumnResult[1]
		
	minOrMaxValueInColumnResult = minOrMaxValueInColumn(unraveledSupplied, 4, "max")	# The Addr end (exclusive) is the column #4 in unraveled
	if minOrMaxValueInColumnResult[0] != True:
		errorMessage = "ERROR in addVariableToUnraveled() - while trying to calculate the max end address (in order to update the dataBlock)"
		errorRoutine(errorMessage)
		return False
	else:
		maxEndOffsetExclusive = minOrMaxValueInColumnResult[1]

			
	unraveledDataBlockSize = maxEndOffsetExclusive - minStartOffsetInclusive
	additionalDataBlockBytesToBeFetched = unraveledDataBlockSize - len(dataBlock)
	PRINT("\nAfter processing",variableName,", previous dataBlock size = ",len(dataBlock), ", new-to-be dataBlock size =",unraveledDataBlockSize,", additionalDataBlockBytesToBeFetched =",additionalDataBlockBytesToBeFetched)
	
	##########################################################################
	# Till now we have only added start and end addresses. Now add the value
	##########################################################################
	
	PRINT("\nNow going to add value for the variableName",variableName,"to the unraveled")

	if variableDatatype in getDictKeyList(suDict):
		pass	# Blank values have already been added
	elif variableDescription["isArray"] and not arrayAlreadyUnraveled:
		pass	# Blank values have already been added
	elif variableDatatype.startswith("function"):
		unraveledSupplied[-1].extend(["","","",ancestry+[variableId]])
	else:
		if variableDescription["isBitField"]:
	
			datatype = variableDescription["datatype"]
			# It is guaranteed that a bitfield width cannot be larger than its container type, hence we can trust numBytesToRead
			numBytesToRead = primitiveDatatypeLength[datatype]
			# The problem is that, there is no guarantee that this bitfield would not cross the alignment boundary (it might have been packed)
			# For example, a 10-byte bitfield <short i1:20;> may be spread over two shorts like this: 
			#
			#  MSb ............................LSb
			#  00000000 00011111 11111000 00000000
			#  <-- short # 1 --> <-- short # 0 -->
			#
			# So, we need to find out exactly which byte it starts from and ends at
			bitIndexStart = bitOffsetWithinStruct - offsetWithinStruct*BITS_IN_BYTE
			bitIndexEndInclusive = bitIndexStart + bitFieldWidth - 1
			
			# We take the following strategy. If the bitIndexStart and bitIndexEndInclusive both fall within the alignment of a single datatype,
			# We read just one alignment worth of data. However, if it spills over two, we double the numBytesToRead
			if integerDivision(bitIndexStart, numBytesToRead*BITS_IN_BYTE) < integerDivision(bitIndexEndInclusive, numBytesToRead*BITS_IN_BYTE):
				numBytesToRead *= 2
			# Find the parent struct
			parentNotFound = True
			n = len(unraveledSupplied)-2
			while (parentNotFound and n >= 0):
#				if unraveledSupplied[n][-1]=="" and unraveledSupplied[n][-2]=="" and unraveledSupplied[n][-3]=="" and " is of type " in unraveledSupplied[n][1]:
				if unraveledSupplied[n][-2]=="" and unraveledSupplied[n][-3]=="" and unraveledSupplied[n][-4]=="" and " is of type " in unraveledSupplied[n][1]:
					wordWithParentStructName = unraveledSupplied[n][1]
					parentName = unraveledSupplied[n][2]
					parentNotFound = False
					PRINT("\nFor variableName =",variableName, ", parentName =",parentName,"\n")
				n -= 1
			if parentNotFound:
				PRINT("\nFor variableName =",variableName, "no parent was found")
			
			PRINT("Performing sanity check for struct parentName =",parentName,", variableName=",variableName)
			if bitFieldWidth != bitIndexEndInclusive - bitIndexStart + 1:
				PRINT ("Mismatching bitwidth for N = ",len(unraveledSupplied))
				sys.exit()
		else: #Not bitfield
			bitFieldWidth = 0
			bitIndexStart = 0
			datatype = variableDescription["datatype"]
			numBytesToRead = primitiveDatatypeLength[datatype]

		# From this part, it is the same for bitfield or non-bitfield
		
		variableStartOffset = unraveledSupplied[-1][3]
		valueBytes = readBytesFromFile(variableStartOffset,numBytesToRead)
		
		
		prefixedVariableName = prefix if variableDescription["isArray"] and arrayAlreadyUnraveled else dottedPrefixOrBlank+variableName
		PRINT("\n\nNow adding value for",prefixedVariableName,"\n")
		if len(valueBytes) == numBytesToRead:	# Full data is there
			signedOrUnsigned = unraveledSupplied[-1][2]["signedOrUnsigned"]
			PRINT ("Calling internalValueLittleEndian()/internalValueBigEndian() for variable ",unraveledSupplied[-1][0],"datatype =",datatype, "bitFieldWidth =",bitFieldWidth,"bitIndexStart =",bitIndexStart)
			valueLE = calculateInternalValue(valueBytes, LITTLE_ENDIAN, datatype, signedOrUnsigned,bitFieldWidth,bitIndexStart)
			valueBE = calculateInternalValue(valueBytes, BIG_ENDIAN, datatype, signedOrUnsigned,bitFieldWidth,bitIndexStart)
			unraveledSupplied[-1].extend([printHexStringWord(valueBytes),valueLE,valueBE,ancestry+[variableId]])
			# There is a subtle difference by which struct and array variables are initialized.
			#
			# For a struct, individual members can be initialized in 3 ways (the first two ways are similar, the last one is extra for struct for obvious reason):
			#
			# 1. struct S { int i,j,k;} var={1,2,3};	// Auto-positional initization
			# 2. struct S { int i,j,k;} var={.j=2};		// named initization
			# 3. struct S { int i,j=1,k;} var;			// Memeber variable-level initization, not possible to do it in array (obviously)
			#
			# For an array, it is always positional, but even within that it can be initialized two ways:
			#
			# 1. int i[5] = {1,2,3,4,5}; 		// via auto-positional initialization
			# 2. int i[5] = {[3]=4};			// via explicit-positional initialization
			#
			# For both struct and array variables, when you mix named and auto-positional initializations, the named one sets the auto-positional one from there.

			if not variableDescription["isArray"] and variableDeclarations[variableId][4]["isInitialized"]:
				PRINT("\nFrom addVariableToUnraveled(), calling verifyInitialization() for non-array variable",variableName)
				verifyInitializationResult = verifyInitialization(unraveledSupplied, len(unraveledSupplied)-1, silent)
				if verifyInitializationResult[0] == False:
					errorMessage = "ERROR in addVariableToUnraveled(): For "+variableDatatype+" non-array variable "+variableName+", error occurred after trying to check initialization via calling verifyInitialization()"
					errorRoutine(errorMessage)
					return False
				elif verifyInitializationResult[1] == False:
					warningMessage = "Warning in addVariableToUnraveled(): For "+variableDatatype+" non-array variable "+variableName+", initialization check failed after calling verifyInitialization()"
					if not silent and gVerificationWarningCount < VERIFICATION_WARNING_COUNT_MAX:
						warningRoutine(warningMessage)
					PRINT(warningMessage)
				elif verifyInitializationResult[1] == True:
					PRINT("Success in addVariableToUnraveled(): For "+variableDatatype+" non-array variable "+variableName+", initialization check succeeded after calling verifyInitialization()")
				else:
					OUTPUT("Coding bug in addVariableToUnraveled(): Exiting")
					sys.exit()
				initResult = False if initResult == False else verifyInitializationResult[1] if verifyInitializationResult[1] in (True, False) else initResult
		elif 0 < len(valueBytes) < numBytesToRead:	# Partial data is there
			PRINT("\nFor variable ",variableName," (variableId =",variableId,"), variableStartOffset =",variableStartOffset,"dataLocationOffset =",dataLocationOffset,", we have partial data of",len(valueBytes), "bytes instead of the intended", numBytesToRead,"bytes")
			unraveledSupplied[-1].extend([printHexStringWord(valueBytes),"Incomplete","Incomplete",ancestry+[variableId]])
		else:
			PRINT("\nFor variable ",variableName," (variableId =",variableId,"), variableStartOffset =",variableStartOffset,"dataLocationOffset =",dataLocationOffset,", we have no data")
			unraveledSupplied[-1].extend(["No data","Unknown","Unknown",ancestry+[variableId]])
		
		
		
	PRINT("\n\n","--"*100,"\nreturning the following unraveledSupplied from addVariableToUnraveled(level=",level,", variableId=",variableId," (",variableName,")...)\n","--"*100)
	for row in unraveledSupplied:
		PRINT(row)
	PRINT("\nReturning from addVariableToUnraveled(level=",level,", variableId=",variableId," (",variableName,"), initResult =","True" if initResult else "False" if initResult == False else "None" if initResult == None else "Garbage")
	return [unraveledSupplied, initResult]


###############################################################################################################
# This function takes in two things: A token index, and a token information triad (output of tokenizeLines())
# The main reason we have this routine is because preprocessing statements like macros do not necessarily have 
# a semicolon at their end. So, if you take a token that is part of a preprocessing statements and then try to
# figure out which token is the last one for the preprocessing statement, you cannot do that purely from the
# tokenstream alone (C does not care if a statement overlaps multiple lines). So, you need to know originally
# on which line each token was.
###############################################################################################################
def firstAndLastTokenIndicesOnSameLineForTokenNumber(tokenIndex, tokenListInformation):

	PRINT("\nTrying to look for the first and last token indices on the same line as the given token index",tokenIndex)
	
	if isinstance(tokenListInformation,list) and (len(tokenListInformation) != 3):
		errorMessage = "ERROR in firstAndLastTokenIndicesOnSameLineForTokenNumber() - supplied tokenListInformation is not a valid list - hence exiting"
		errorRoutine(errorMessage)
		return False
	elif not checkIfIntegral(tokenIndex):
		errorMessage = "ERROR in firstAndLastTokenIndicesOnSameLineForTokenNumber() - supplied tokenIndex"+STR(tokenIndex)+"is not a valid integer - hence exiting"
		errorRoutine(errorMessage)
		return False
	elif tokenIndex <0 or tokenIndex >= len(tokenListInformation[0]):
		errorMessage = "ERROR in firstAndLastTokenIndicesOnSameLineForTokenNumber() - supplied tokenIndex"+STR(tokenIndex)+"is not a valid index - the valid range is <0,"+STR(len(tokenListInformation[0])-1)+">"
		errorRoutine(errorMessage)
		return False
		
	lineStart = tokenListInformation[1][tokenIndex][2][0][0]
	lineEnd   = tokenListInformation[1][tokenIndex][2][-1][0]
	
	PRINT("\nThe token#",tokenIndex,"(",tokenListInformation[0][tokenIndex],") starts on line #",lineStart,"and ends on line #",lineEnd)
	
	firstTokenIndexOnlineStart = tokenListInformation[2][lineStart][0][1]
	lastTokenIndexOnlineEnd    = tokenListInformation[2][lineEnd][-1][1]

	if not checkIfIntegral(firstTokenIndexOnlineStart) or not checkIfIntegral(lastTokenIndexOnlineEnd):
		errorMessage = "ERROR in firstAndLastTokenIndicesOnSameLineForTokenNumber() - the calculated firstTokenIndexOnlineStart ("+STR(firstTokenIndexOnlineStart)+") or lastTokenIndexOnlineEnd ("+STR(lastTokenIndexOnlineEnd)+") is not integral"
		errorRoutine(errorMessage)
		return False
	elif not ( 0<= firstTokenIndexOnlineStart < len(tokenListInformation[0])) or not ( 0<= lastTokenIndexOnlineEnd < len(tokenListInformation[0])):
		errorMessage = "ERROR in firstAndLastTokenIndicesOnSameLineForTokenNumber() - the calculated firstTokenIndexOnlineStart ("+STR(firstTokenIndexOnlineStart)+") or lastTokenIndexOnlineEnd ("+STR(lastTokenIndexOnlineEnd)+") is not valid"
		errorRoutine(errorMessage)
		return False
	else:	
		PRINT("The first token on line #",lineStart,"has token index of",firstTokenIndexOnlineStart,", and it is <",tokenListInformation[0][firstTokenIndexOnlineStart],">")
		PRINT("The last  token on line #",lineEnd,  "has token index of",lastTokenIndexOnlineEnd,   ", and it is <",tokenListInformation[0][lastTokenIndexOnlineEnd   ],">")
	
	return [firstTokenIndexOnlineStart,lastTokenIndexOnlineEnd]

################################################################################################################
# Non-Declaration code. Returns the [status,token index of where the next "statement" ends (inclusive).]
# The reason we return two things is because 0 is also a valid index, and 0 often equates to False.
################################################################################################################

def parseRegularNonDeclarationCode(tokenList):
	global funcName
	funcName = "parseRegularNonDeclarationCode"
	
	i = 0
	##################    WHILE  / FOR LOOP  / SWITCH  #########################
	if tokenList[i] in ("while", "for", "switch"):
		PRINT(tokenList[i],"found")
	
		loopType = tokenList[i]
	
		if i==len(tokenList)-1 or tokenList[i+1] != "(":
			errorMessage = "ERROR in parseRegularNonDeclarationCode() - " + loopType + " loop must have a ( to start with"
			errorRoutine(errorMessage)
			return [False, None]
		elif i+1 == len(tokenList)-1 or ")" not in tokenList[i+2:]:
			errorMessage = "ERROR in parseRegularNonDeclarationCode() - " + loopType + " loop must have a ) to close the condition"
			errorRoutine(errorMessage)
			return [False, None]
		elif matchingBraceDistance(tokenList[i+1:]) < 1:
			errorMessage = "ERROR in parseRegularNonDeclarationCode() - " + loopType + " loop must have a matching ) to close the condition"
			errorRoutine(errorMessage)
			return [False, None]
		
		conditionEndBraceIndex = i+1 + matchingBraceDistance(tokenList[i+1:])
		PRINT("conditionEndBraceIndex =",conditionEndBraceIndex, "which means the whole expression is", tokenList[i+1:conditionEndBraceIndex+1])
		
		if conditionEndBraceIndex == len(tokenList)-1:
			errorMessage = "ERROR in parseRegularNonDeclarationCode() - " + loopType + " must have either a semicolon or matching {} after the while(condition)"
			errorRoutine(errorMessage)
			return [False, None]
		elif tokenList[conditionEndBraceIndex+1] == "{":
			if "}" not in tokenList[conditionEndBraceIndex+1:]:
				errorMessage = "ERROR in parseRegularNonDeclarationCode() - no matching {} after the" + loopType + "(condition)"
				errorRoutine(errorMessage)
				return [False, None]
			elif matchingBraceDistance(tokenList[conditionEndBraceIndex+1:])<1:
				errorMessage = "ERROR in parseRegularNonDeclarationCode() - " + loopType + " body must have a matching } to close the body"
				errorRoutine(errorMessage)
				return [False, None]
			else:
				curlyBraceEndIndex = conditionEndBraceIndex+1 + matchingBraceDistance(tokenList[conditionEndBraceIndex+1:])
				PRINT("Returning curlyBraceEndIndex =",curlyBraceEndIndex, "which means the whole expression is", tokenList[i:curlyBraceEndIndex+1])
				return [True, curlyBraceEndIndex]
		elif tokenList[i] == "switch":
			errorMessage = "ERROR in parseRegularNonDeclarationCode() - " + loopType + " must have a pair of curly braces to designate the body"
			errorRoutine(errorMessage)
			return [False, None]
		elif ";" not in tokenList[conditionEndBraceIndex+1:]:
			errorMessage = "ERROR in parseRegularNonDeclarationCode() - " + loopType + " body must have a semicolon to close the body"
			errorRoutine(errorMessage)
			return [False, None]
		else:
			singleStatementEndIndex = conditionEndBraceIndex+1 + tokenList[conditionEndBraceIndex+1:].index(";") 
			return [True,singleStatementEndIndex]
		
		if loopType in ("for","while") and ";" not in tokenList[conditionEndBraceIndex+1:] and ( tokenList[conditionEndBraceIndex+1] != "{" or "}" not in tokenList[conditionEndBraceIndex+1:]):
			errorMessage = "ERROR in parseRegularNonDeclarationCode() - " + loopType + " loop body must have either a semicolon or matching {} after the while(condition)"
			errorRoutine(errorMessage)
			return [False, None]
		elif loopType in ("switch") and (tokenList[conditionEndBraceIndex+1] != "{" or "}" not in tokenList[conditionEndBraceIndex+1:]):
			errorMessage = "ERROR in parseRegularNonDeclarationCode() - " + loopType + " body must have either a semicolon or matching {} after the while(condition)"
			errorRoutine(errorMessage)
			return [False, None]
		elif tokenList[conditionEndBraceIndex+1] == "{": 
			if matchingBraceDistance(tokenList[conditionEndBraceIndex+1:])<1:
				errorMessage = "ERROR in parseRegularNonDeclarationCode() - " + loopType + " body must have a matching } to close the body"
				errorRoutine(errorMessage)
				return [False, None]
			else:
				whileLoopBodyCurlyBraceEndIndex = conditionEndBraceIndex+1 + matchingBraceDistance(tokenList[conditionEndBraceIndex+1:])
				return whileLoopBodyCurlyBraceEndIndex
		result = parseRegularNonDeclarationCode(tokenList[conditionEndBraceIndex+1:])
		if result[0] == False:
			errorMessage = "ERROR in parseRegularNonDeclarationCode() - cannot parse the body for the" + loopType 
			errorRoutine(errorMessage)
			return [False, None]
		else:
			singleStatementEndIndex = conditionEndBraceIndex+1 + result[1] 
			return [True,singleStatementEndIndex]
			

	##################    DO- WHILE  LOOP    #########################
	elif tokenList[i] == "do":		

		if i==len(tokenList)-1 or tokenList[i+1] != "(" and ";" not in tokenList[i+1:] :
			errorMessage = "ERROR in parseRegularNonDeclarationCode() - do-while loop must have a { to start with"
			errorRoutine(errorMessage)
			return [False, None]
		elif tokenList[i+1]=="{":
			if i+1 == len(tokenList)-1 or "}" not in tokenList[i+2:]:
				errorMessage = "ERROR in parseRegularNonDeclarationCode() - while loop must have a ) to close the condition"
				errorRoutine(errorMessage)
				return [False, None]
			elif matchingBraceDistance(tokenList[i+1:]) < 1:
				errorMessage = "ERROR in parseRegularNonDeclarationCode() - while loop must have a matching ) to close the condition"
				errorRoutine(errorMessage)
				return [False, None]
			doLoopBodyEndIndex = i+1+matchingBraceDistance(tokenList[i+1:])
		else:
			result = parseRegularNonDeclarationCode(tokenList[i+1:])
			if result[0] == False:
				errorMessage = "ERROR in parseRegularNonDeclarationCode() - do{body}while(condition); loop must have a proper body"
				errorRoutine(errorMessage)
				return [False, None]
			else:
				doLoopBodyEndIndex = i+1 + result[1]
		
		if doLoopBodyEndIndex >= len(tokenList)-1 or tokenList[doLoopBodyEndIndex+1] != "while":
			errorMessage = "ERROR in parseRegularNonDeclarationCode() - do-while loop must have a while"
			errorRoutine(errorMessage)
			return [False, None]
		elif tokenList[doLoopBodyEndIndex+2]!="(" or ")" not in tokenList[doLoopBodyEndIndex+2:]:
			errorMessage = "ERROR in parseRegularNonDeclarationCode() - do-while loop must have a condition after the while keyword"
			errorRoutine(errorMessage)
			return [False, None]
		elif matchingBraceDistance(tokenList[doLoopBodyEndIndex+2:])<0:
			errorMessage = "ERROR in parseRegularNonDeclarationCode() - the while() condition in the do-while loop does not have a matching )"
			errorRoutine(errorMessage)
			return [False, None]
		
		doWhileLoopWhileConditionBraceEndIndex = doLoopBodyEndIndex+2 + matchingBraceDistance(tokenList[doLoopBodyEndIndex+2:])
		
		if doWhileLoopWhileConditionBraceEndIndex >= len(tokenList)-1 or tokenList[doWhileLoopWhileConditionBraceEndIndex+1] != ";":
			errorMessage = "ERROR in parseRegularNonDeclarationCode() - the while() condition in the do-while loop does not have a semicolon after that"
			errorRoutine(errorMessage)
			return [False, None]
		else:
			return [True, doWhileLoopWhileConditionBraceEndIndex+1]
		
			
	##################    IF / THEN / ELSE    #########################
	elif tokenList[i] == "if":
	
		ifBodyEndIndex = LARGE_NEGATIVE_NUMBER
		
		if i ==len(tokenList)-1 or tokenList[i+1] != "(" or ")" not in tokenList[i+1:]:
			errorMessage = "ERROR in parseRegularNonDeclarationCode() - it does not have proper () after if/else keyword"
			errorRoutine(errorMessage)
			return [False, None]
		elif matchingBraceDistance(tokenList[i+1:])<0:
			errorMessage = "ERROR in parseRegularNonDeclarationCode() - it does not have proper matching ) after if/elseif ("
			errorRoutine(errorMessage)
			return [False, None]
			
		conditionEndBraceIndex = i+1+matchingBraceDistance(tokenList[i+1:])
		
		if conditionEndBraceIndex == len(tokenList)-1:
			errorMessage = "ERROR in parseRegularNonDeclarationCode() -  must have either a semicolon or matching {} after the if(condition)"
			errorRoutine(errorMessage)
			return [False, None]
		elif tokenList[conditionEndBraceIndex+1]=="{":
			if conditionEndBraceIndex+1 == len(tokenList)-1 or "}" not in tokenList[conditionEndBraceIndex+2:]:
				errorMessage = "ERROR in parseRegularNonDeclarationCode() - if must have a ) to close the condition"
				errorRoutine(errorMessage)
				return [False, None]
			elif matchingBraceDistance(tokenList[conditionEndBraceIndex+1:]) < 1:
				errorMessage = "ERROR in parseRegularNonDeclarationCode() - if must have a matching ) to close the condition"
				errorRoutine(errorMessage)
				return [False, None]
			ifBodyEndIndex = conditionEndBraceIndex+1 + matchingBraceDistance(tokenList[conditionEndBraceIndex+1:])
		else:
			result = parseRegularNonDeclarationCode(tokenList[conditionEndBraceIndex+1:])
			if result[0] == False:
				errorMessage = "ERROR in parseRegularNonDeclarationCode() - if(condition); must have a proper body"
				errorRoutine(errorMessage)
				return [False, None]
			else:
				ifBodyEndIndex = conditionEndBraceIndex+1 + result[1]
		
		if ifBodyEndIndex == LARGE_NEGATIVE_NUMBER:
			OUTPUT("Coding error in parseRegularNonDeclarationCode() for parsing if")
			sys.exit()
			
		if ifBodyEndIndex == len(tokenList)-1 or tokenList[ifBodyEndIndex+1] != "else":
			return [True, ifBodyEndIndex]
		elif ifBodyEndIndex+2 <= len(tokenList)-1 and tokenList[ifBodyEndIndex+2] == '{':
			if '}' not in tokenList[ifBodyEndIndex+3:]:
				errorMessage = "ERROR in parseRegularNonDeclarationCode() - if(condition); else lacks the ending }"
				errorRoutine(errorMessage)
				return [False, None]
			result = matchingBraceDistance(tokenList[ifBodyEndIndex+2:])
			if result < 1:
				errorMessage = "ERROR in parseRegularNonDeclarationCode() - if(condition)else must have a matching ) to close the else {"
				errorRoutine(errorMessage)
				return [False, None]
			else:
				elseBodyEndIndex = ifBodyEndIndex+2+result
				return [True, elseBodyEndIndex]
		else:
			PRINT("Calling parseRegularNonDeclarationCode() for",STR(tokenList[ifBodyEndIndex+2:]))
			result = parseRegularNonDeclarationCode(tokenList[ifBodyEndIndex+2:])
			PRINT("Result is",result)
			if result[0] == False:
				PRINT("Result is",result,"!")
				errorMessage = "ERROR in parseRegularNonDeclarationCode() - if(condition) else must have a proper body"
				errorRoutine(errorMessage)
				return [False, None]
			else:
				elseBodyEndIndex = ifBodyEndIndex+2 + result[1]
				return [True, elseBodyEndIndex]
				
	else:
	
		# Check for assignments. Make sure that it is at the "open", i.e. not enclosed by any parentthesis, like func1(int i=0){}, which is NOT an assignment
		if ';' in tokenList[i:] and '=' in tokenList[i:] and tokenList[i:].index("=") < tokenList[i:].index(";"):
			# make a temporary copy of the tokenList upto the semicolon
			list1 = tokenList[i:tokenList[i:].index(";")+1]
			list2 = list1
			numItemsDeleted = 0
			j = 0
			while j<len(list1):
				if list1[j] in ('(','{','['):
					d = matchingBraceDistance(list1[j])
					if d<0:
						errorMessage = "ERROR in parseRegularNonDeclarationCode() - unmatched "+list1[j]+" in assignment"
						errorRoutine(errorMessage)
						return [False, None]
					else:
						del list2[j-numItemsDeleted:j+d+1-numItemsDeleted]
						numItemsDeleted += d+1
						j = j + d
				j += 1
			if '=' in list2:
				PRINT("Found assigment")
				return [True, i + tokenList[i:].index(";")]
				
		# Check for function definitions
		if '(' in tokenList[i:] and ')' in tokenList[i:] and '{' in tokenList[i:] and '}' in tokenList[i:]:
			j = i+tokenList[i:].index("(")
			if j>0 and tokenList[j-1] not in illegalVariableNames and matchingBraceDistance(tokenList[j:]) > 0 and tokenList[j+matchingBraceDistance(tokenList[j:])+1]=='{' and '}' in tokenList[j+matchingBraceDistance(tokenList[j:])+2:]:
			   return [True, j+matchingBraceDistance(tokenList[j:])+1+matchingBraceDistance(tokenList[j+matchingBraceDistance(tokenList[j:])+1:])]
			   
		# Any other statement ending with a semicolon
		if ';' not in tokenList[i:]:
			errorMessage = "ERROR in parseRegularNonDeclarationCode() - unknown tokenstream" + STR(tokenList[i:])
			errorRoutine(errorMessage)
			return [False, None]
		else:
			PRINT("Returning",i+tokenList[i:].index(";"))
			return [True, i+tokenList[i:].index(";")]
		
###########################################################################################################
# This function takes in a tokenList and parses it	
# parseCodeSnippet() is called from mainWork(), after calling preProcess() and tokenizeLines(lines)
# All #define macro invokations have already been done by preProcess(). So, just ignore any such statement
###########################################################################################################
def parseCodeSnippet(tokenListInformation, rootNode):
	global pragmaPackStack, pragmaPackCurrentValue, typedefs, enums, lines, structuresAndUnions, suDict, primitiveDatatypeLength, variableDeclarations, dummyVariableCount, totalVariableCount, variableIdsInGlobalScope, runtimeStatementLocationsInGlobalScope, globalScopedBuddies, globalScopedRuntimeBlocks, runtimeStatementOrGlobalScopedVariableIdOrStructId, blankArraysAndTerminationInfo
	# This list contains the different variables that were declared as part of the supplied tokenList
	variableDeclarations = []
	PRINT ("inside parseCodeSnippet" )
	# There could be mixing of #defines and structure/union declarations, and simple variable declaration

	declarationKeywords = ['void','char','short','int','long','long long', 'float','double','signed','unsigned', 'auto','register','static','extern','typedef','const','volatile']
	
	# There are 3 things we get from the input tokenListInformation
	# 1. The simple array of tokens - tokenList
	# 2. Token-wise token information (from which line/char it starts and ends)
	# 3. Line-wise token information (which all tokens are there on that line, and from which line/char each such token starts and ends)
	tokenList = tokenListInformation[0]
	
	# Just to check
	for ti in range(len(tokenList)):
		temp = firstAndLastTokenIndicesOnSameLineForTokenNumber(ti, tokenListInformation)
	
	i = 0;
	while i < len(tokenList):
		PRINT ("Processing tokenList[",i,"] = <%s>"%tokenList[i] )
		if ";" in tokenList[i:]:
			nextSemicolonIndex = i+1 + tokenList[i+1:].index(";")
		elif tokenList[i] == preProcessorSymbol and i+1 < len(tokenList) and tokenList[i+1] in runtimeDirectives:
			# A Runtime directive does not necessarily end with a semicolon
			PRINT("Runtime statement starting with",tokenList[i+1],"may not end with a semicolon")
			pass
		elif tokenList[i] == preProcessorSymbol and i+1 < len(tokenList) and tokenList[i+1] in preprocessingDirectives and tokenList[i+1] not in ('line', 'error', 'pragma'):
			errorMessage = "ERROR in parseCodeSnippet() - preProcessing statements in the current segment <%s> should not have been printed"%(STR(list2string(tokenList[i:])))
			errorRoutine(errorMessage)
			return False
		elif tokenList[i] == preProcessorSymbol and i+1 < len(tokenList) and tokenList[i+1] in ('line', 'error', 'pragma'):
			# A Compiler directive like #define statement does not necessarily end with a semicolon
			PRINT("Preprocessing statement starting with",tokenList[i+1],"does not end with a semicolon")
			pass
		elif tokenList[i] == 'pragma':
			PRINT("Covering the case that the last code statement is a #pragma pack(). Which makes no sense, but don't want the \"No semicolon\" error")
			pass
		elif checkIfFunctionDefinition(tokenList[i:])[0] == True:
			PRINT("Functions starting with",tokenList[i],"does not end with a semicolon")
			pass
		else:
			errorMessage = "ERROR in parseCodeSnippet() - every non-preprocessor C variable declaration must end with a semicolon - the current segment <%s> doesn't - hence exiting"%(STR(list2string(tokenList[i:])))
			errorRoutine(errorMessage)
			PRINT ("ERROR in parseCodeSnippet()" )
			return False
#			sys.exit()
			
		# The first token in evey declaration segment must be an enum (definition/declaration), a struct ir union, a typedef, or another typedeffed struct/union
		# Actually, one quark of C is that typedef can be anywhere. For example, this is a valid declaration: long unsigned typedef int long ullong; 
		
		# Let's try some conversions:
		
		# typedef int * prtArrayInt[5][6];	prtArrayInt (*funcPtr)(int, char);	==>	int * ((*funcPtr)(int, char))[5][6]
		
		#################################
		####     T Y P E D E F       ####
		#################################
		
		if tokenList[i] == "typedef":
			PRINT ("Found typedef" )
			# There must be at least two token before the semi-colon
			if nextSemicolonIndex <= i + 2:
				errorMessage = "ERROR - Illegal statement formation (semicolon without adequate typedef variable type and name) - exiting"
				errorRoutine(errorMessage)
				PRINT ("ERROR in parseCodeSnippet() - nextSemicolonIndex =",nextSemicolonIndex,"tokenList[i:] = tokenList[",i,":]=",tokenList[i:] )
				return False
				sys.exit()
				
			# There are two kinds of typedef - typedef on a struct/union/enum, and another on regular variables.
			if tokenList[i+1] == "struct" or tokenList[i+1] == "union" or tokenList[i+1] == "enum":
				i = i + 1	# We still need to process the struct
				continue # Go to the next iteration of the while loop so that we can take care of the struct/union/enum
			else:	# Regular typedef
				# This works only for very simple #define-like typedefs
				newDatatypeName = tokenList[nextSemicolonIndex-1]
				newDatatypeMeaning = tokenList[i+1:nextSemicolonIndex-1]
				if newDatatypeName in getDictKeyList(typedefs):
					PRINT ("ERROR in parseCodeSnippet()" )
					errorMessage = "typedef %s already exists!"%(newDatatypeName)
					errorRoutine(errorMessage)
					return False
					sys.exit()
				else:
					PRINT ("Will add in future", newDatatypeName, "which means <", newDatatypeMeaning, "> to the typedefs dictionary" )
					# We are now doing typedef as part of regular variable declaration resolution later - so commenting here
#					typedefs[newDatatypeName] = newDatatypeMeaning
					PRINT ("After non-addition, typedefs dictionary = ",typedefs )
					i = i + 1	# We still need to process the regular variable declaration
					continue # Go to the next iteration of the while loop so that we can take care of the variable declaration
				
			# Think right now this is redundant ....
			i = nextSemicolonIndex+1
			continue
		
		
		#################################
		####     __attribute__       ####
		#################################
		elif tokenList[i] == ATTRIBUTE_STRING:
			parseAttributeResult = parseAttribute(tokenList[i:])
			if parseAttributeResult[0] != True:
				errorMessage = "ERROR in parseCodeSnippet() after calling parseAttribute()"
				errorRoutine(errorMessage)
				return False
			else:
				d = parseAttributeResult[1]["distance"]
				i = i+1+d+1
		
		
		###########################
		####   P R A G M A     ####
		###########################
		
		# This is a kludge. When I separated the '#' as a separate token from all the #define, #include etc., I forgot to split '#pragma'.
		# Hence, here I am just advancing the pointer by 1 so that it gets picked up by the next round
		elif tokenList[i] == preProcessorSymbol and i<len(tokenList)-1 and tokenList[i+1] == "pragma":
			i = i + 1

		# Currently it only supports #prgama(push), #prgama(pop), and #prgama(some value)
#		elif tokenList[i] == "#pragma":
		elif tokenList[i] == "pragma":
		
			if i==0 or tokenList[i-1] != preProcessorSymbol:
				OUTPUT("Possible error handling #pragma")
				
			if tokenList[i+1] != "pack":
				resultPair = firstAndLastTokenIndicesOnSameLineForTokenNumber(i, tokenListInformation)
				if resultPair == False:
					errorMessage = "ERROR in parseCodeSnippet() after trying to find the first and last tokens for tokenList["+STR(i)+"] = "+tokenList[i]
					errorRoutine(errorMessage)
					return False
				else:
					pragmaDirectiveEndTokenIndex = resultPair[1]
					# Sanity check - the first token in that line must be the preprocessor symbol #
					if tokenList[resultPair[0]] != preProcessorSymbol:
						EXIT("ERROR in parseCodeSnippet() - BAD coding - Something wrong!!")

					OUTPUT("Ignoring #pragma directive", STR(tokenList[i:pragmaDirectiveEndTokenIndex+1]))
					i = pragmaDirectiveEndTokenIndex + 1	# Move the pointer
					continue
				
			else:
				if tokenList[i+2] == "()":	# If we are tokenizing () as "()" instead of "(" followed by ")", then handle that case directly
					pragmaPackCurrentValue = pragmaPackDefaultValue		#pragma pack()     /* restore compiler's default alignment setting */
					i = i + 3
				elif tokenList[i+2] != "(":
					errorMessage = "ERROR in parseCodeSnippet() - must supply the parenthesized alignment value after a #pragma pack statement - no beginning parenthesis - instead got "+tokenList[i+2]
					errorRoutine(errorMessage)
					return False
				elif ")" not in tokenList[i+3:]:
					errorMessage = "ERROR in parseCodeSnippet() - must supply the parenthesized alignment value after a #pragma pack statement - no ending parenthesis"
					errorRoutine(errorMessage)
					return False
				else:
					nextFirstBraceBeginIndex = i+2
					nextFirstBraceEndIndex = nextFirstBraceBeginIndex + matchingBraceDistance(tokenList[nextFirstBraceBeginIndex:])
					if nextFirstBraceEndIndex == nextFirstBraceBeginIndex + 1:		#pragma pack()     /* restore compiler's default alignment setting */
						pragmaPackCurrentValue = pragmaPackDefaultValue
						i = nextFirstBraceEndIndex + 1
					else:
						parseArgumentListResult = parseArgumentList(tokenList[nextFirstBraceBeginIndex:nextFirstBraceEndIndex+1])
						if parseArgumentListResult == False:
							errorMessage = "ERROR in parseCodeSnippet() - error calling parseArgumentList(%s)"%STR(tokenList[nextFirstBraceBeginIndex:nextFirstBraceEndIndex+1])
							errorRoutine(errorMessage)
							return False
						else:
							for item in parseArgumentListResult:
								PRINT("Currently handling #pragma pack(",item,")")
								if item == "push":
									if pragmaPackCurrentValue != None:
										pragmaPackStack.append(pragmaPackCurrentValue)
								elif item == "pop":
									if not pragmaPackStack:
										errorMessage = "ERROR in parseCodeSnippet() - cannot pop from the #pragma stack since it is empty"
										errorRoutine(errorMessage)
										return False
									else:
										pragmaPackCurrentValue = pragmaPackStack.pop()
								else:
									parseArithmeticExpressionResult = parseArithmeticExpression(item)
									if parseArithmeticExpressionResult == False:
										errorMessage = "ERROR in parseCodeSnippet() - error calling parseArithmeticExpression(parenthesized alignment value of = <%s> after a #pragma pack (%s) statement - no beginning parenthesis"%(STR(item), STR(parseArithmeticExpressionResult))
										errorRoutine(errorMessage)
										return False
									else:
										evaluateArithmeticExpressionResult = evaluateArithmeticExpression(parseArithmeticExpressionResult)
										if evaluateArithmeticExpressionResult[0] != True:
											errorMessage = "ERROR in parseCodeSnippet() - error calling evaluateArithmeticExpression(AST = <%s>) after a #pragma pack statement"%(STR(parseArithmeticExpressionResult))
											errorRoutine(errorMessage)
											return False
										else:
											result = evaluateArithmeticExpressionResult[1]
											if not checkIfIntegral(result):
												errorMessage = "ERROR in parseCodeSnippet() - output (%s) from evaluateArithmeticExpression() after a #pragma pack statement is not integral"%(STR(result))
												errorRoutine(errorMessage)
												return False
											elif result < 1:
												errorMessage = "ERROR in parseCodeSnippet() - output (%s) from evaluateArithmeticExpression() after a #pragma pack statement must be at least 1"%(STR(result))
												errorRoutine(errorMessage)
												return False
											elif result not in (1,2,4,8, 16):
												errorMessage = "ERROR in parseCodeSnippet() - output (%s) from evaluateArithmeticExpression() after a #pragma pack statement must be 1,2 4 8 or 16"%(STR(result))
												errorRoutine(errorMessage)
												return False
											else:
												pragmaPackCurrentValue = result
												PRINT("Assigned the result =",result,"to the pragmaPackCurrentValue, while the content of current pragmaPackStack is",pragmaPackStack)
											i = nextFirstBraceEndIndex+1
		
		###########################
		####     E N U M       ####
		###########################
		
		elif tokenList[i] == "enum":
			parseEnumResult = parseEnum(tokenList, i)
			if parseEnumResult == None:
				errorMessage = "Error coding parseEnum() - return value is None"
				errorRoutine(errorMessage)
				return False
			elif parseEnumResult == False:
				errorMessage = "Error calling parseEnum()"
				errorRoutine(errorMessage)
				return False
			else:
				i = parseEnumResult
		
		
			
				
				
		###########################################
		####     P R E P R O C E S S O R       ####
		###########################################

		#	preProcessorSymbol = '#'
		#	runtimeDirectives = ('if','elif','else','endif','loop','endloop')
		#	preprocessingDirectives = ('include', 'if', 'ifdef', 'ifndef', 'else', 'elif', 'endif', 'define', 'undef', 'line', 'error', 'pragma', '...', '__VA_ARGS__', '__VA_OPT__', runtimeDirective)
		
		# Recall that all #define macro invokations have already been done by preProcess(). However, there might still be other preprocessing directives 
		# that this tool doesn't yet support, so just ignore them.
		
		# Recall that  #RUNTIME statements can occur INSIDE a struct definition, or outside in the open (in Global scope).
		# When they occur inside the Structure definition, we have ways to treat them. However, when they happen outside, we have to capture them.
		# runtimeStatementLocationsInGlobalScope[] is the global list that captures this information. Its format is:
		# each row: [runTimeLineNumStart, runtime statement token global index start, runtime statement token global index end, [runtime statement token list]]
		
#		elif tokenList[i] in preprocessingDirectives or (tokenList[i]==preProcessorSymbol and i+1<len(tokenList) and tokenList[i+1] == runtimeDirective):

		elif ((tokenList[i]==preProcessorSymbol and i+1<len(tokenList) and tokenList[i+1] in preprocessingDirectives) or 
		      (tokenList[i]==preProcessorSymbol and i+1<len(tokenList) and tokenList[i+1] in runtimeDirectives)):
		
			PRINT("Inside parseCodeSnippet() found preprocessing or runtime directive.\n")
			
			
			resultPair = firstAndLastTokenIndicesOnSameLineForTokenNumber(i, tokenListInformation)
			if resultPair == False:
				errorMessage = "ERROR in parseCodeSnippet() after trying to find the first and last tokens for tokenList["+STR(i)+"] = "+tokenList[i]
				errorRoutine(errorMessage)
				return False
			else:
				# Sanity check - the first token in that line must be the preprocessor symbol #
				if tokenList[resultPair[0]] != preProcessorSymbol:
					OUTPUT("ERROR in parseCodeSnippet() - BAD coding - Something wrong!!")
					sys.exit()

				if tokenList[i]==preProcessorSymbol and i+1<len(tokenList) and tokenList[i+1] in runtimeDirectives:
					runTimeLineNumStart = tokenListInformation[1][resultPair[0]][2][0][0]
					runTimeLineNumEnd 	= tokenListInformation[1][resultPair[1]][2][0][0]
					if runTimeLineNumStart != runTimeLineNumEnd:
						errorMessage = "ERROR in parseCodeSnippet() - the whole #RUNTIME statement should be on a single line"
						errorRoutine(errorMessage)
						return False
					else:
						runtimeStatementLocationsInGlobalScope.append([runTimeLineNumStart, resultPair[0], resultPair[1], tokenList[resultPair[0]:resultPair[1]+1]])
				else:
					runTimeLineNumStart = tokenListInformation[1][resultPair[0]][2][0][0]
					runTimeLineNumEnd 	= tokenListInformation[1][resultPair[1]][2][0][0]
					if tokenList[i]==preProcessorSymbol and i+1<len(tokenList) and tokenList[i+1] in preprocessingDirectives:
						OUTPUT("Forgot to include this boundary condition here, runTimeLineNumStart=",runTimeLineNumStart,", runTimeLineNumEnd =",runTimeLineNumEnd)
						OUTPUT("lines[runTimeLineNumStart]=",lines[runTimeLineNumStart])
						OUTPUT("lines[runTimeLineNumEnd]=",lines[runTimeLineNumEnd])
					OUTPUT("ERROR in parseCodeSnippet() - really BAD coding - Something wrong!!")
					sys.exit()
				i = resultPair[1] + 1	# Move the pointer
				continue


		#################################################################
		####     S T R U C T / U N I O N   DEFINTION / DECLARATION	 ####
		#################################################################

		elif (tokenList[i] in ("struct","union")):
			structOrUnionType = tokenList[i]
			usingDummyVariable = False
			memberDeclarationStatementStartIndex = None
			typedefStatement = False
			structDefinitionStartIndex = i
			if ';' not in tokenList[i+1:]:
				errorMessage = "ERROR in parseCodeSnippet(): No semicolon at the end"
				errorRoutine(errorMessage)
				return False
			else:
				nextSemicolonIndex = i+1 + tokenList[i+1:].index(";")
				
				variableDeclarationStartIndex = i
				while (variableDeclarationStartIndex > 0):
					if tokenList[variableDeclarationStartIndex-1] in [ 'auto','register','static','extern', 'const','volatile', 'typedef']:
						if tokenList[variableDeclarationStartIndex-1] == 'typedef':
							typedefStatement = True
						variableDeclarationStartIndex = variableDeclarationStartIndex - 1
					else:
						break

				structDefinedHere = False
				
				# Struct Definition (and optionally declaration too, if there are variables there)
				if '{' in tokenList[i+1:nextSemicolonIndex]:
					curlyBraceStartIndex = i+1 + tokenList[i+1:].index("{")
					if '}' in tokenList[curlyBraceStartIndex+1:]:
						matchingBraceDistanceResult = matchingBraceDistance(tokenList[curlyBraceStartIndex:])
						if matchingBraceDistanceResult <= 0:
							errorMessage = "ERROR in parseCodeSnippet(): The supplied tokenList has an illegal matchingBraceDistanceResult =" + STR(matchingBraceDistanceResult)
							errorRoutine(errorMessage)
							return False
						else:
							structDefinedHere = True
							# A struct will have a lexical scope of variables in it. This is the first 
							scopeStartVariableId = totalVariableCount
							curlyBraceEndIndex = curlyBraceStartIndex + matchingBraceDistance(tokenList[curlyBraceStartIndex:])
							if ';' in tokenList[curlyBraceEndIndex+1:]:
								nextSemicolonIndex = curlyBraceEndIndex+1 + tokenList[curlyBraceEndIndex+1:].index(";")
							else:
								errorMessage = "Error coding parseStructureDefinition() - Missing semicolon at the end after }"
								errorRoutine(errorMessage)
								return False
							# The result is actually the structure name (comes handy for anonymous structures)
							level = 0
							
							parseStructureDefinitionResult = parseStructureDefinition(tokenListInformation, curlyBraceStartIndex,"--Global--", level)
							
							if parseStructureDefinitionResult == None:
								errorMessage = "Error coding parseStructureDefinition() - return value is None"
								errorRoutine(errorMessage)
								return False
							elif parseStructureDefinitionResult == False:
								errorMessage = "Error calling parseStructureDefinition() from parseCodeSnippet() - return Value is False"
								errorRoutine(errorMessage)
								return False
							else:
								PRINT("Invoking parseStructureDefinition() from parseCodeSnippet() succeeded")
								PRINT("Now going to invoke calculateStructureLength() from parseCodeSnippet().")
								structName = parseStructureDefinitionResult
								calculateStructureLengthResult = calculateStructureLength(structName)
								if calculateStructureLengthResult == False:
									errorMessage = "Error calling calculateStructureLength() from parseCodeSnippet() - return Value is False"
									errorRoutine(errorMessage)
									return False
								else:
									PRINT("Invoking calculateStructureLength() from parseCodeSnippet() succeeded")
									PRINT("calculateStructureLengthResult = ",calculateStructureLengthResult)
								
							# There might be __attribute__(( ... )) statements after this
							
							lastItemConsumedIndex = curlyBraceEndIndex
							while tokenList[lastItemConsumedIndex+1] == ATTRIBUTE_STRING:
								parseAttributeResult = parseAttribute(tokenList[lastItemConsumedIndex+1:])
								if parseAttributeResult[0] != True:
									errorMessage = "ERROR in parseCodeSnippet() after calling parseAttribute() post struct definition handling"
									errorRoutine(errorMessage)
									return False
								else:
									d = parseAttributeResult[1]["distance"]
									lastItemConsumedIndex = lastItemConsumedIndex+2+d
								
							
							# A struct will have a lexical scope of variables in it.
							scopeEndVariableId = totalVariableCount - 1
							
							if tokenList[lastItemConsumedIndex+1] == ';':	# Only defnition, no declaration
#							if tokenList[curlyBraceEndIndex+1] == ';':	# Only defnition, no declaration
								structName = parseStructureDefinitionResult
								PRINT ("Processed struct/union ",parseStructureDefinitionResult,"(only definition, no declared struct/union variables). Nothing more to do" )
								numFakeEntries = i - variableDeclarationStartIndex
								memberDeclarationStatementStartIndex = variableDeclarationStartIndex
								memberDeclarationStatement = tokenList[variableDeclarationStartIndex:curlyBraceStartIndex]
								if memberDeclarationStatement[-1] != structName:	# Append the structure name for Anonymous structures
									memberDeclarationStatement.append(structName)
								usingDummyVariable = True
								dummyVariableCount += 1
								dummyVariableName = dummyVariableNamePrefix + STR(dummyVariableCount)
								memberDeclarationStatement.append(dummyVariableName)
								memberDeclarationStatement.append(';')	# Put back the semicolon
#								i = curlyBraceEndIndex+2
								i = lastItemConsumedIndex+2
#								continue
							else:	# Some variable(s) declared after the struct definition
								structName = parseStructureDefinitionResult
								# Now process declarations. Create a fake declaration statement as if
#								if structDefinitionStartIndex>0 and tokenList[structDefinitionStartIndex-1] == "typedef":
								if structDefinitionStartIndex != variableDeclarationStartIndex:
#									memberDeclarationStatement = [tokenList[structDefinitionStartIndex-1],tokenList[structDefinitionStartIndex], structName]
									memberDeclarationStatement = tokenList[variableDeclarationStartIndex: structDefinitionStartIndex+1] +[structName]
									numFakeEntries = structDefinitionStartIndex-variableDeclarationStartIndex + 1
#									memberDeclarationStatementStartIndex = structDefinitionStartIndex-1
									memberDeclarationStatementStartIndex = variableDeclarationStartIndex
								else:
									memberDeclarationStatement = [tokenList[structDefinitionStartIndex], structName]
									numFakeEntries = 1
									memberDeclarationStatementStartIndex = structDefinitionStartIndex
#								memberDeclarationStatement.extend(tokenList[curlyBraceEndIndex+1:nextSemicolonIndex+1])
								memberDeclarationStatement.extend(tokenList[lastItemConsumedIndex+1:nextSemicolonIndex+1])
#								i = curlyBraceEndIndex	# Now i points to the just before actual structure variables that are declared
								i = lastItemConsumedIndex	# Now i points to the just before actual structure variables that are declared
								PRINT("memberDeclarationStatement = ",memberDeclarationStatement)
								
					else:
						errorMessage = "ERROR in parseCodeSnippet(): No matching }"
						errorRoutine(errorMessage)
						return False
						
				else:	# Regular struct declaration (no definition)
					PRINT ("Regular struct declaration (no definition), i=",i)
					if structDefinitionStartIndex>0 and tokenList[structDefinitionStartIndex-1]=="typedef":
						memberDeclarationStatementStartIndex = structDefinitionStartIndex - 1
					else:
						memberDeclarationStatementStartIndex = structDefinitionStartIndex
					structName = tokenList[structDefinitionStartIndex+1]
					
					
					memberDeclarationStatement = tokenList[memberDeclarationStatementStartIndex:nextSemicolonIndex+1]
					numFakeEntries = 0
#					i = structDefinitionStartIndex	# It assumes that this statement will be this format: struct structName variables;
					i = memberDeclarationStatementStartIndex	# It assumes that this statement will be this format: [typedef] struct structName variables;
					
				# Now parse all the member variables individually
				PRINT ("Going to parse from tokenList[memberDeclarationStatementStartIndex=",memberDeclarationStatementStartIndex,"through nextSemicolonIndex=",nextSemicolonIndex,"] (both indices included, possibly also typedef) = ",memberDeclarationStatement )
				parsed5tupleList = parseVariableDeclaration(memberDeclarationStatement)
				if parsed5tupleList == False:
					errorMessage = "ERROR in parseCodeSnippet() for struct after calling parseVariableDeclaration(memberDeclarationStatement) for memberDeclarationStatement ="+ STR(memberDeclarationStatement) 
					errorRoutine(errorMessage)
					return False
				PRINT ("struct declaration",parsed5tupleList, "parsed" )
				
				variableFoundWithDataOverlapWithStructMembers = False
				
				for item in parsed5tupleList:
					PRINT ("struct ",structName,"has the following declarations after it" )
					PRINT ("Main variable name is ",item[0],"of size",item[1],"and it is located at relative index of ",item[3],"inside the variable declaration statement",item[2] )
					# Each member of the list follows exactly the same format as the parsed5tupleList, with one key addition - the 6th item.
					# This 6th member now represents the absolute index (within the tokenList) of the variable name.
					if not structDefinedHere and not usingDummyVariable and tokenList[i+item[3]-numFakeEntries]!=item[0]:
						OUTPUT ("ERROR in parseCodeSnippet() - for i=",i,"tokenList[i+item[3]-numFakeEntries] = tokenList[",i,"+",item[3],"-",numFakeEntries,"] =",tokenList[i+item[3]-numFakeEntries],"!=item[0]=",item[0] )
						errorMessage = "ERROR in parseCodeSnippet() for struct as location of struct variable does not match for i="+STR(i)+" and tokenList[i]=<"+STR(tokenList[i])+">, memberDeclarationStatement="+ STR(memberDeclarationStatement) 
						errorRoutine(errorMessage)
						return False
					else:
						if not structDefinedHere and not usingDummyVariable:
							PRINT ("In parseCodeSnippet(), - for i=",i,"tokenList[i+item[3]-numFakeEntries] = tokenList[",i,"+",item[3],"-",numFakeEntries,"] =",tokenList[i+item[3]-numFakeEntries],"matches item[0]=",item[0] )
						globalTokenListIndex = i+item[3]-numFakeEntries if not usingDummyVariable else curlyBraceEndIndex+1
						variableName = item[0]
						variableSize = item[1]
						variableId = totalVariableCount
						variableDeclarationStatement = item[2]
						variableNameIndex = item[3]
						variableDescriptionExtended = item[4]
						variableDescriptionExtended["globalTokenListIndex"] = globalTokenListIndex
						variableDescriptionExtended["level"] = 0
						variableDescriptionExtended["variableId"] = variableId
						variableDescriptionExtended["DataOverlapWithStructMembers"] = True if not variableFoundWithDataOverlapWithStructMembers and structDefinedHere and variableDescriptionExtended["datatype"] == structName else False
						item2add = [variableName,variableSize,variableDeclarationStatement,variableNameIndex,variableDescriptionExtended]
						variableDeclarations.append(item2add) 
						totalVariableCount += 1

					if structDefinedHere and variableDescriptionExtended["datatype"] == structName and variableFoundWithDataOverlapWithStructMembers == False:
						variableFoundWithDataOverlapWithStructMembers = True
						variableIdsInGlobalScope.append([variableId, scopeStartVariableId, scopeEndVariableId])
					else:
						variableIdsInGlobalScope.append([variableId, variableId, variableId])

					if memberDeclarationStatementStartIndex == None:
						errorMessage = "ERROR in parseCodeSnippet() memberDeclarationStatementStartIndex not populated for i="+STR(i)+" and tokenList[i]=<"+STR(tokenList[i])+">, memberDeclarationStatement="+ STR(memberDeclarationStatement) 
						errorRoutine(errorMessage)
						return False
						
				i = nextSemicolonIndex+1



		elif tokenList[i] in [ 'auto','register','static','extern', 'const','volatile']:
			#	storageClassSpecifier = [ 'auto','register','static','extern','typedef']
			#	typeQualifier = ['const','volatile']
			i = i+1
				
		###############################################################################################################################
		####     D E R I V E D  ( T Y P E D E F)   T Y P E   A N D    O T H E R    V A R I A B L E     D E C L A R A T I O N S     ####
		###############################################################################################################################
				

		# regular declaration statements without any enclosing structures
		elif (tokenList[i] in declarationKeywords) or (tokenList[i] in getDictKeyList(typedefs)) or (tokenList[i] in getDictKeyList(typedefsBuiltin)):
			caseOfUndefinedBuiltinTypedef = False 	# Default value
			functionCheckResult = checkIfFunctionDefinition(tokenList[i:])
			if functionCheckResult[0]==False and ";" not in tokenList[i:]:
				PRINT ("No semicolon in tokenList[i:] = tokenList[",i,":] = ",tokenList[i:] )
				errorMessage = "ERROR in parseCodeSnippet() while checking for derived types - every variable declaration must end with a semicolon - exiting"
				errorRoutine(errorMessage)
				return False
#				sys.exit()
			declarationEndIndex = len(tokenList[i:])
			if ';' in tokenList[i:]:
				nextSemicolonIndex = i+1 + tokenList[i+1:].index(";")
				declarationEndIndex = nextSemicolonIndex
			if functionCheckResult[0]==True:
				functionDeclarationEndIndex = functionCheckResult[1]
				declarationEndIndex = functionDeclarationEndIndex if functionDeclarationEndIndex < declarationEndIndex else declarationEndIndex
				
			PRINT ("Current tokenList = ",tokenList,"i=",i )
			typedefStatement = False
			variableDeclarationStartIndex = i
			while (variableDeclarationStartIndex > 0):
				if tokenList[variableDeclarationStartIndex-1] in [ 'auto','register','static','extern', 'const','volatile', 'typedef']:
					if tokenList[variableDeclarationStartIndex-1] == 'typedef':
						typedefStatement = True
					variableDeclarationStartIndex = variableDeclarationStartIndex - 1
				else:
					break
			
#			variableDeclarationStartIndex = i-1 if (i>0 and tokenList[i-1]=="typedef") else i
			memberDeclarationStatement = tokenList[variableDeclarationStartIndex:declarationEndIndex+1]
			PRINT ("Going to parse from  tokenList[",variableDeclarationStartIndex,"through",declarationEndIndex,"] (both indices included) = ",memberDeclarationStatement )

			# The user forgot to explicitly declare the typedef
			if (tokenList[i] in getDictKeyList(typedefsBuiltin)) and (tokenList[i] not in getDictKeyList(typedefs)):
				caseOfUndefinedBuiltinTypedef = True
				list2parse = typedefsBuiltin[tokenList[i]]
				PRINT ("Going to add",tokenList[i],"to the typedefs, whose type definition would be", list2parse)
				parsed5tupleList = parseVariableDeclaration(list2parse)
			
			elif tokenList[i] not in getDictKeyList(typedefs):
				list2parse = memberDeclarationStatement
				parsed5tupleList = parseVariableDeclaration(list2parse)
			else:
			
				list2parse = convertDerivedTypeDeclarationIntoBaseTypeDeclaration(tokenList,i)
				if list2parse == False:
					errorMessage = "ERROR in parseCodeSnippet() - error encountered in convertDerivedTypeDeclarationIntoBaseTypeDeclaration() while trying to convert the Derived type"
					errorRoutine(errorMessage)
					return False
				else:
					parsed5tupleList = parseVariableDeclaration(list2parse)			
				
				
			if parsed5tupleList == False:
				errorMessage = "ERROR in parseCodeSnippet() after calling parseVariableDeclaration(list2parse) for list2parse = "+ STR(list2parse)
				errorRoutine(errorMessage)
				return False
			
			PRINT ("Non-struct declaration",parsed5tupleList, "parsed" )
			for item in parsed5tupleList:
				typeSpecifierEndIndex = item[4]["typeSpecifierEndIndex"]
				variableDeclarationStatement = item[2]
				PRINT ("Main variable name is ",item[0],"of size",item[1],"and it is located at relative index of ",item[3],"inside the variable declaration statement",item[2],", where the base type specifier ends at index =", )
				if tokenList[i] in getDictKeyList(typedefs):
					PRINT ("We modified the declaration statement, so we know that position index of the declared variable", item[0],"would not match (hence not checking it)" )
					variableNameIndex = memberDeclarationStatement.index(item[0])
				elif tokenList[variableDeclarationStartIndex+item[3]]!=item[0]:
					errorMessage = "ERROR in parseCodeSnippet() - for variableDeclarationStartIndex = "+ STR(variableDeclarationStartIndex) + " tokenList[variableDeclarationStartIndex+item[3]] = " + STR(tokenList[variableDeclarationStartIndex+item[3]]) + " !=item[0]=" + STR(item[0])
					errorRoutine(errorMessage)
					return False
				else:
					variableNameIndex = item[3]
				
				# If this is a function definition (not declaration), do not add it to the variableDeclarations or variableIdsInGlobalScope
				if item[4]["datatype"].startswith("function") and item[4]['isInitialized']== True:
					PRINT("Omitting function",item[0],"since it is a function defintion, not a declaration")
					continue
					
				variableId = totalVariableCount
				globalTokenListIndex = variableDeclarationStartIndex+variableNameIndex
				variableDescriptionExtended = item[4]
				variableDescriptionExtended["globalTokenListIndex"]=globalTokenListIndex if not caseOfUndefinedBuiltinTypedef else LARGE_NEGATIVE_NUMBER
				variableDescriptionExtended["level"] = 0
				variableDescriptionExtended["variableId"] = variableId
				variableDescriptionExtended["DataOverlapWithStructMembers"] = False
				totalVariableCount += 1
				variableDeclarations.append([item[0],item[1],item[2],variableNameIndex,variableDescriptionExtended])
				
				variableIdsInGlobalScope.append([variableId, variableId, variableId])
				
				# Handle the Typedefs
				if i>0 and tokenList[i-1]=="typedef" and "typedef" not in variableDeclarationStatement[:typeSpecifierEndIndex+1]:
					errorMessage = "CODING ERROR: no \"typedef\" in variableDeclarationStatement[:typeSpecifierEndIndex+1] =" + STR(variableDeclarationStatement[:typeSpecifierEndIndex+1])
					errorRoutine(errorMessage)
					sys.exit()

			if caseOfUndefinedBuiltinTypedef:
				# In this cycle we will just add the builtin typedef to typedef and update variableDeclarations accordingly. In the next cycle, we will reprocess this.
				continue
			else:
				i = declarationEndIndex + 1


		##########################################################
		####     N O N - D E C L A R A T I O N    C O D E     ####
		##########################################################
						
		# This is the place where all non-declaration or non-defintion code should come
		else:
			PRINT("We have encoutered non-declared code",tokenList[i:])
			result = parseRegularNonDeclarationCode(tokenList[i:])
			PRINT("result =",result)
			if result[0] == False:
				errorMessage = "ERROR in parseCodeSnippet() - cannot parse tokenList" + STR(tokenList[i:])
				errorRoutine(errorMessage)
				return False
			else:
				i = i+result[1]+1	# Recall that parseRegularNonDeclarationCode is relative to the first item index, starting from 0
				
	
		continue

	# END-WHILE =======================================================================================================================

	# All looping has been done, now let's work on some collective stuff

	# We go by the assumption that if a single global-scope variable got selected that comes under a #RUNTIME statement block somewhere, ALL the global-scope variables
	# under the whole #RUNTIME if-elif-else-endif block MUST be selected. That's because we never know which of the sub-blocks within the #RUNTIME if-elif-else-endif block 
	# will get executed. However, in order to do that, we must know which all Global variables fall under each #RUNTIME if-elif-else-endif block.
	# And if there are nested #RUNTIME statements, we have to include ALL of the global variables (basically, under the scope of the OUTERMOST #RUNTIME if-elif-else-endif,
	# the "OUTERMOST" being the keyword here.
	
	# Now, recall that runtimeStatementLocationsInGlobalScope[] is the list of the runtime statements that are OUTSIDE any struct definition. 
	# They may or may not be nested, but they are not INSIDE any struct definition.
	# Every row of runtimeStatementLocationsInGlobalScope[] = [line#, globalTokenNumberStart, globalTokenNumberEnd, [runtime token list] ]

	# Recall that each row in variableIdsInGlobalScope is of the format = [variableId, scopeStartVariableId, scopeEndVariableId]
	
	# First, verify that the order of the variableId of the variables in variableIdsInGlobalScope follow the lexical order.
	
	setOfVariableIdsThatAreInGlobalScope = [x[0] for x in variableIdsInGlobalScope]
	PRINT("setOfVariableIdsThatAreInGlobalScope =", setOfVariableIdsThatAreInGlobalScope)
	
	if setOfVariableIdsThatAreInGlobalScope != sorted(setOfVariableIdsThatAreInGlobalScope):
		errorMessage = "ERROR in parseCodeSnippet() - the list of global-scoped variable ids are NOT sorted: " + STR(setOfVariableIdsThatAreInGlobalScope)
		errorRoutine(errorMessage)
		return False
	else:
		PRINT("The list of global-scoped variable ids are indeed sorted by variableId:", setOfVariableIdsThatAreInGlobalScope)
	
	varLineNumId = []	# For every global-scoped variable, get its line number. So, every row is of the format = [varlineNum, varId]
	for varId in setOfVariableIdsThatAreInGlobalScope:
		varlineNum = tokenListInformation[1][ variableDeclarations[varId][4]["globalTokenListIndex"] ][2][0][0]
		varLineNumId.append([varlineNum, varId])

	'''
	structLineNumId = []	# For every global-scoped structure/union, get its line number (where it is defined). So, every row is of the format = [structlineNum, structId]
	for structId in range(len(structuresAndUnions)):
		structlineNum = tokenListInformation[1][ variableDeclarations[varId][4]["globalTokenListIndex"] ][2][0][0]
		varLineNumId.append([varlineNum, varId])
	'''
	# Verify that line numbers for these global-scoped variables are also sorted 
	onlyLineNumbers = [ x[1] for x in varLineNumId ]
	if onlyLineNumbers != sorted(onlyLineNumbers):
		errorMessage = "ERROR in parseCodeSnippet() - the list of global-scoped variable ids are NOT sorted by their line #: " + STR(varLineNumId)
		errorRoutine(errorMessage)
		return False
	else:
		PRINT("The list of global-scoped variable ids are indeed sorted:", varLineNumId)
	
	PRINT("runtimeStatementLocationsInGlobalScope =",runtimeStatementLocationsInGlobalScope)
	PRINT("varLineNumId =",varLineNumId)
	PRINT("Going to merge runtimeStatementLocationsInGlobalScope and varLineNumId")
	# Create a list that combines the two lists. We have established that both lists are sorted by their first element (the lineNum).
	# So, we just create two pointers and advance them forward one at a time.
	# Each row in runtimeStatementOrGlobalScopedVariableId[] 		   is either [lineNum, variableId], or [lineNum, [Runtime tokens]]]
	# Each row in runtimeStatementOrGlobalScopedVariableIdOrStructId[] is either [lineNum, variableId], or [lineNum, [Runtime tokens]], or [lineNum, ['struct'/'union', structId]]
	runtimeStatementOrGlobalScopedVariableId = []
	ptrRuntimeStatements = 0
	ptrVarLineNumId = 0
	while True:
		if ptrRuntimeStatements >= len(runtimeStatementLocationsInGlobalScope) and ptrVarLineNumId >= len(varLineNumId):
			break
		elif ptrRuntimeStatements < len(runtimeStatementLocationsInGlobalScope) and ptrVarLineNumId >= len(varLineNumId):
			runtimeStatementOrGlobalScopedVariableId.append([runtimeStatementLocationsInGlobalScope[ptrRuntimeStatements][0], runtimeStatementLocationsInGlobalScope[ptrRuntimeStatements][3]])
			ptrRuntimeStatements += 1
		elif ptrRuntimeStatements >= len(runtimeStatementLocationsInGlobalScope) and ptrVarLineNumId < len(varLineNumId):
			runtimeStatementOrGlobalScopedVariableId.append([varLineNumId[ptrVarLineNumId][0], varLineNumId[ptrVarLineNumId][1]])
			ptrVarLineNumId += 1
		elif runtimeStatementLocationsInGlobalScope[ptrRuntimeStatements][0] < varLineNumId[ptrVarLineNumId][0]:
			runtimeStatementOrGlobalScopedVariableId.append([runtimeStatementLocationsInGlobalScope[ptrRuntimeStatements][0], runtimeStatementLocationsInGlobalScope[ptrRuntimeStatements][3]])
			ptrRuntimeStatements += 1
		elif runtimeStatementLocationsInGlobalScope[ptrRuntimeStatements][0] > varLineNumId[ptrVarLineNumId][0]:
			runtimeStatementOrGlobalScopedVariableId.append([varLineNumId[ptrVarLineNumId][0], varLineNumId[ptrVarLineNumId][1]])
			ptrVarLineNumId += 1
		elif runtimeStatementLocationsInGlobalScope[ptrRuntimeStatements][0] == varLineNumId[ptrVarLineNumId][0]:
			errorMessage = "ERROR in parseCodeSnippet() - somehow the #RUNTIME statement " + STR(runtimeStatementLocationsInGlobalScope[ptrRuntimeStatements][3]) + " and global=scoped variableId "+ STR(varLineNumId[ptrVarLineNumId][1]) + " both occur on line # " + STR(varLineNumId[ptrVarLineNumId][0])
			errorRoutine(errorMessage)
			return False
		
	PRINT("\nEvery row is line number followed by either a #RUNTIME statement, or a global-scoped variableId:")
	for row in runtimeStatementOrGlobalScopedVariableId:
		PRINT(row)
		
	# Make a list of where each Global struct is declared.
	structDeclarationLocations = []	# Each entry is [line#, struct/union, structIndex]
	for structIndex in range(len(structuresAndUnions)):
		structOrUnionType = structuresAndUnions[structIndex]["type"]
		structDefinitionStartLineNum = structuresAndUnions[structIndex]["structDefinitionStartLineNum"]
		structDeclarationLocations.append([structDefinitionStartLineNum,[structOrUnionType,structIndex]])
		# Find the corresponding name from suDict (not really necessary, just for the PRINT statement)
		for key in getDictKeyList(suDict):
			if structIndex in suDict[key]:
				structName = key
				break
		PRINT("Adding [structDefinitionStartLineNum =",structDefinitionStartLineNum,", [structOrUnionType =",structOrUnionType,", structIndex =",structIndex,"(",structName,")]]")
	# It should be sorted by default, but you never know	
	structDeclarationLocations.sort(key=lambda list1stItem: list1stItem[0])
	PRINT("structDeclarationLocations =",structDeclarationLocations)
	PRINT("runtimeStatementOrGlobalScopedVariableId =", runtimeStatementOrGlobalScopedVariableId)
	PRINT("Now going to merge structDeclarationLocations and runtimeStatementOrGlobalScopedVariableId")
	# This is the place we insert the stuct definitions also
	ptrStruct = 0
	ptrRuntimeOrVarId = 0
	runtimeStatementOrGlobalScopedVariableIdOrStructId = [] # Every entry is a line# followed by one of 3: A #RUNTIME statement, a struct definition, or a global variable declaration
	while True:
		if ptrStruct >= len(structDeclarationLocations) and ptrRuntimeOrVarId >= len(runtimeStatementOrGlobalScopedVariableId):
			break
		elif ptrRuntimeOrVarId >= len(runtimeStatementOrGlobalScopedVariableId):
			runtimeStatementOrGlobalScopedVariableIdOrStructId.append(structDeclarationLocations[ptrStruct])
			ptrStruct += 1
		elif ptrStruct >= len(structDeclarationLocations):
			runtimeStatementOrGlobalScopedVariableIdOrStructId.append(runtimeStatementOrGlobalScopedVariableId[ptrRuntimeOrVarId])
			ptrRuntimeOrVarId += 1
		elif structDeclarationLocations[ptrStruct][0] <= runtimeStatementOrGlobalScopedVariableId[ptrRuntimeOrVarId][0]:
			runtimeStatementOrGlobalScopedVariableIdOrStructId.append(structDeclarationLocations[ptrStruct])
			ptrStruct += 1
		elif structDeclarationLocations[ptrStruct][0] > runtimeStatementOrGlobalScopedVariableId[ptrRuntimeOrVarId][0]:
			runtimeStatementOrGlobalScopedVariableIdOrStructId.append(runtimeStatementOrGlobalScopedVariableId[ptrRuntimeOrVarId])
			ptrRuntimeOrVarId += 1
		else:
			OUTPUT("Bad coding in parseCodeSnippet() while trying to merge the struct definitions with the Runtime/variableId")
			sys.exit()
	PRINT("runtimeStatementOrGlobalScopedVariableIdOrStructId =")
	for row in runtimeStatementOrGlobalScopedVariableIdOrStructId:
		PRINT(row)

	 

	globalScopedBuddies = []	# The list of sets of variableId of global scoped variables that must be selected together (if user selects any of them, select ALL of them)
	globalScopedRuntimeBlocks = [] # Each entry in a <start line#, end line#>  the runtimeStatementLocationsInGlobalScope. It goes in sync with globalScopedBuddies.

	# Now, find out which all Global-scoped variables MUST be chosen together.
	# Not only there might be nested runtime statements, but also there might be MULTIPLE highest-level runtime statements (like this below).
	# Here, among the global-scoped variables c, i, j, k and l, there are two sets of variable: [i,j] and [k,l] where for each set, all the variables inside that set
	# must be selected together because one never knows which subblock will evaluate to tbe true. Basically, you cannot choose just i and not j - you must choose both.
	# Similarly, you cannot choose just k or just l or just m - you must choose k, l and m all together.
	#
	# Also note that if the user does not choose the "int c;" line, none of the runtime conditions can be determined. But that is a problem the user can solve very easily,
	# since during the map operation, it will complain that it does not know what c's value is. The user should understand and correct their selection.
	# We do not want to implement the logic where the tool will automatically figure out how far back one must go in order to ensure that all variables are resolved,
	# since that would be a very hard problem to solve programmatically and an extremely easy problem to solve by the user.
	#
	# line #  0.   int c;
	# line #  1.	# if (c>0)			Here, globalScopedBuddies = [ [variableId for i, variableId for j], [variableId for k, variableId for l, variableId for m] ]
	# line #  2.    	int i;													
	# line #  3.	# else						Also, globalScopedRuntimeBlocks = 	[ [1, 5], [7,12] ] 	Basically, every entry is [#start line number, #end line number]
	# line #  4.		int j;										each entry below is	[line#, start token #, end token #, [runtime token list] ]
	# line #  5.	# endif				Finally, runtimeStatementLocationsInGlobalScope = [ [ 1,  3,10, ['#', 'if', '(','c','>','0',')']],
	# line #  6.																			[ 3, 14,16, ['#', 'else']],
	# line #  7.	# if (c>20)																[ 5, 20,22, ['#', 'endif']],
	# line #  8.		int k;																[ 7, 23,30, ['#', 'if', '(', 'c', '>', '20', ')']],
	# line #  9.	# else																	[ 9, 34,36, ['#', 'else']],
	# line # 10.		int l;																[12, 43,45, ['#', 'endif']] ]
	# line # 11.		float m;
	# line # 12.    # endif
	# line # 13.
	#
	# Every row of runtimeStatementLocationsInGlobalScope[] = [line#, globalTokenNumberStart, globalTokenNumberEnd, [runtime token list] ].
	
	ptr = 0
	while ptr<len(runtimeStatementLocationsInGlobalScope):
		firstLineNumInScope = runtimeStatementLocationsInGlobalScope[ptr][0]
		PRINT("From parseCodeSnippet(), calling checkPreprocessingDirectivesInterleaving(lines[firstLineNumInScope:], True)")
		scope = checkPreprocessingDirectivesInterleaving(lines[firstLineNumInScope:], True)
		if scope == False:
			errorMessage = "ERROR in parseCodeSnippet() - somehow after checkPreprocessingDirectivesInterleaving() from line "+ STR(firstLineNumInScope) + " the return (scope) is False!"
			errorRoutine(errorMessage)
			return False
		lastLineNumInScope = firstLineNumInScope + scope[-1][0]	# Recall that the line numbering in scope is relative with the first line assumed to be from 0
		
		PRINT("Scope of the #RUNTIME statements starting from firstLineNumInScope =",firstLineNumInScope," is")
		for row in scope:
			PRINT(row)
		PRINT("Going to find global scoped buddies within < firstLineNumInScope =",firstLineNumInScope,", lastLineNumInScope =",lastLineNumInScope,">")
		
		# The logic below is the following. We iterate through the runtimeStatementOrGlobalScopedVariableIdOrStructId[], where the format of each row is two entries:
		# [ line number, followed by either a #RUNTIME statement, or a global-scoped variableId, or ['struct'/'union', structId]].
		linesInScopeFound = False
		buddies = []
		# each row is [line number followed by either a [#RUNTIME statement], or a global-scoped variableId, or a ['struct'/'union', structId]]
		for row in runtimeStatementOrGlobalScopedVariableIdOrStructId:	
			if linesInScopeFound == False and isinstance(row, list) and row[0] == firstLineNumInScope:
				linesInScopeFound = True
			elif linesInScopeFound == True and isinstance(row, list) and row[0] == lastLineNumInScope:
				linesInScopeFound = False
				globalScopedBuddies.append(buddies)
				globalScopedRuntimeBlocks.append([firstLineNumInScope + scope[0][0], firstLineNumInScope + scope[-1][0]])	# These are actual line numbers
				buddies = []
			elif linesInScopeFound == True and checkIfIntegral(row[1]):
				globalScopedVariableId = row[1]
				buddies.append(globalScopedVariableId)

		PRINT("The global scoped buddies within < firstLineNumInScope =",firstLineNumInScope,", lastLineNumInScope =",lastLineNumInScope,"> are", STR(buddies))
		PRINT("ptr = ", ptr)
		# Advance the pointer to the last line of current scope
		while True:
			ptr += 1
			PRINT("runtimeStatementLocationsInGlobalScope[ptr=",ptr,"] = ",runtimeStatementLocationsInGlobalScope[ptr])
			if runtimeStatementLocationsInGlobalScope[ptr][0] == lastLineNumInScope:
				ptr += 1	# This should push it to the first line of the next stage
				break
	
	PRINT("\n\nglobalScopedBuddies =",globalScopedBuddies)
	PRINT("\n\nglobalScopedRuntimeBlocks =",globalScopedRuntimeBlocks)
	PRINT("\nruntimeStatementOrGlobalScopedVariableIdOrStructId =",runtimeStatementOrGlobalScopedVariableIdOrStructId)
	#First check going from first to last
	namespaceStack = []
	for N in range(len(runtimeStatementOrGlobalScopedVariableIdOrStructId)):
		# Originally, each Originalitem is [line#, variableId]. or [line#, ['struct'/'union', structId]], or [line#, ['#','if/elif/else/endif',.....]]
		Originalitem = runtimeStatementOrGlobalScopedVariableIdOrStructId[N][1]	# Ignore the item[0], which is the line#
		# Make each item as variableId, or ['struct'/'union', structId], or ['#','if/elif/else/endif',.....]
		if checkIfIntegral(Originalitem):
			item = variableDeclarations[Originalitem][0]	# Replace the variableId with the variable name
		elif isinstance(Originalitem,list) and len(Originalitem)==2 and Originalitem[0] in ("struct","union"):
			item = [Originalitem[0], structuresAndUnions[Originalitem[1]]["name"]]	# Replace the structId (second item in the list) by the structure name
		elif isinstance(Originalitem,list) and len(Originalitem)>=2 and Originalitem[0]==preProcessorSymbol:
			item = Originalitem[1]	# Just the #if/elif/else/endif part, ignore other terms
		else:
			OUTPUT("Coding error in parseCodeSnippet() in handling namespaceStack first to last for item # N=",N,"original item = ",Originalitem,", current item =",item)
			sys.exit()
		
		if item in ('elif','else'):	# Go back and delete all the variables up to the if
			while True:
				if namespaceStack[-1] == 'if':
					break
				else:
					del namespaceStack[-1]
		elif item == 'endif':	# Go back and delete all the variables up to the if
			while True:
				if namespaceStack[-1] == 'if':
					del namespaceStack[-1]
					break
				else:
					del namespaceStack[-1]
		if item != 'endif':
			if item not in ('if','elif','else') and item in namespaceStack:
				PRINT("namespaceStack =",namespaceStack, ", item = <"+STR(item)+">")
				if isinstance(item,list):
					errorMessage = "Error in parseCodeSnippet(): "+item[0]+" "+item[1]+" has already been defined within the current scope (cannot be re-defined within the same scope)"
				else:
					errorMessage = "Error in parseCodeSnippet(): variable "+ item + " has already been declared within the current scope (cannot be re-declared within the same scope)"
				errorRoutine(errorMessage)
				return False
			else:
				namespaceStack.append(item)
				PRINT("After appending item",item,", namespaceStack =",namespaceStack)
		PRINT("After processing item #",N,", namespaceStack =",namespaceStack)

	# Next check going from last to first
	namespaceStack = []
	for N in reversed(range(len(runtimeStatementOrGlobalScopedVariableIdOrStructId))):
		# Originally, each Originalitem is [line#, variableId]. or [line#, ['struct'/'union', structId]], or [line#, ['#','if/elif/else/endif',.....]]
		Originalitem = runtimeStatementOrGlobalScopedVariableIdOrStructId[N][1]	# Ignore the item[0], which is the line#
		# Make each item as variableId, or ['struct'/'union', structId], or ['#','if/elif/else/endif',.....]
		if checkIfIntegral(Originalitem):
			item = variableDeclarations[Originalitem][0]	# Replace the variableId with the variable name
		elif isinstance(Originalitem,list) and len(Originalitem)==2 and Originalitem[0] in ("struct","union"):
			item = [Originalitem[0], structuresAndUnions[Originalitem[1]]["name"]]	# Replace the structId (second item in the list) by the structure name
		elif isinstance(Originalitem,list) and len(Originalitem)>=2 and Originalitem[0] == preProcessorSymbol:
			item = Originalitem[1]	# Just the if/elif/else/endif part, ignore other terms
		else:
			OUTPUT("Coding error in parseCodeSnippet() in handling namespaceStack last to first for item # N=",N,"original item = ",Originalitem,", current item =",item)
			sys.exit()

		PRINT("Originalitem =",Originalitem,", item =",item)

		if item in ('else', 'elif'):	# Go back and delete all the variables up to the endif
			while True:
				if namespaceStack[-1] == 'endif':
					break
				else:
					del namespaceStack[-1]
		elif item == 'if':	# Go back and delete all the variables up to the endif
			while True:
				if namespaceStack[-1] == 'endif':
					del namespaceStack[-1]
					break
				else:
					del namespaceStack[-1]
		if item != 'if':
			if item not in ('endif','else','elif') and item in namespaceStack:
				if isinstance(item,list):
					errorMessage = "Error in parseCodeSnippet(): "+item[0]+" "+item[1]+" has already been defined within the current scope (cannot be re-defined within the same scope)"
				else:
					errorMessage = "Error in parseCodeSnippet(): variable "+ item + " has already been declared within the current scope (cannot be re-declared within the same scope)"
				errorRoutine(errorMessage)
				return False
			else:
				namespaceStack.append(item)
		PRINT("After processing item #",N,", namespaceStack =",namespaceStack)

	
	
	PRINT ("\n==============================================\nvariableDeclarations =" )
	blankArraysAndTerminationInfo = {}
	for k in range(len(variableDeclarations)):
		item = variableDeclarations[k]
		PRINT (item)
		if item[4]["isArray"] and item[4]["arrayDimensions"][0]==['TBD']:
			partner = terminalVariableId(k)
			if partner == False:
				warningMessage = "Warning: for blank-dimension array variable "+ item[0] + ", could not find the corresponding terminating initialization condition"
				warningRoutine(warningMessage)
				break
			siblingAncestors = findSiblingAncestors(k)
			if siblingAncestors == False:
				errorMessage = "Error in parseCodeSnippet(): for blank-dimension array variable "+ item[0] + ", could find the partner variable "+variableDeclarations[partner][0]+"(variable id of "+STR(partner)+") corresponding initialization condition, but failed to find their ancestors that are siblings"
				errorRoutine(errorMessage)
				return False
			blankArraysAndTerminationInfo[k]={"blankDimensionArrayVariableId":k, "partnerVariableId":partner, "siblingAncestors":siblingAncestors}
	PRINT("After processing all variableDeclarations entries, blankArraysAndTerminationInfo =",blankArraysAndTerminationInfo)
			
	PRINT ("\n=====================================================\n" )
	PRINT ("typedefs = ",typedefs )
	PRINT("\n\n","runtimeStatementLocationsInGlobalScope =\n","[line#, start token index, end token index, [runtime token list] ]\n")
	for item in runtimeStatementLocationsInGlobalScope:
		PRINT(item)
#	sys.exit()

	mismatch = False
	for i in range(len(structuresAndUnions)):
		for j in range(len(structuresAndUnions[i]["components"])):
			variableId = structuresAndUnions[i]["components"][j][4]["variableId"]
			if variableDeclarations[variableId] != structuresAndUnions[i]["components"][j]:
				mismatch = True
				OUTPUT("\n\nMismatch for struct",structuresAndUnions[i]["name"],": the structuresAndUnions[",i,']["components"][',j,"]=\n",structuresAndUnions[i]["components"][j])
				OUTPUT("\nWhile variableDeclarations[variableId=",variableId,"] =\n",variableDeclarations[variableId])
	if mismatch:
		PRINT("\n\n\n","==="*50,"\n!!!! MISMATCH !!!!\n","==="*50,"\n\n")
		sys.exit()
	else:
		PRINT("\n\n\n","==="*50,"\n!!!! NO MISMATCH !!!!\n","==="*50,"\n\n")
	return True


#str = "3+ -1"
#lst = parseArithmeticExpression(tokenizeLines(str))
#PRINT ("str =",str,"lst =",lst )
#sys.exit()

#str1 = "(int)c"
#parsed = parseArithmeticExpression(tokenizeLines(str1))
#PRINT ("string <",str1,"> parses into", parsed )
#valid = isASTvalid(parsed)
#PRINT ("whose validity = ",valid )
#sys.exit()

			

#######################################################################################
#
# 	The Main Working Module
#
#######################################################################################

def mainWork():	
#	global PRINT_DEBUG_MSG		# MannaManna
	global lines, gTokenLocationLinesChars

	# Pre-process (remove comment etc.)
	
	PRINT ("Before calling preProcess()" )
#	PRINT_DEBUG_MSG = True		# MannaManna
	preProcessResult = preProcess()
	if preProcessResult == False:
		OUTPUT ("ERROR in mainWork after calling preProcess()" )
		return False
	PRINT ("After calling preProcess()" )
#	PRINT_DEBUG_MSG = False		# MannaManna

	nonBlankLines = []
	for n in range(len(lines)):
		if lines[n].strip() != "":
			nonBlankLines.append(lines[n])
	lines = nonBlankLines
	
	# Tokenize and resolve macros
	
	PRINT ("Before calling tokenizeLines(lines)" )
	tokenListResult = tokenizeLines(lines)
	if tokenListResult == False:
		OUTPUT ("ERROR inside mainWork() after calling tokenizeLines(lines) for lines =", lines )
		return False
	else:
		tokenList = tokenListResult[0]
		
	PRINT ("After calling tokenizeLines(lines)" )
	PRINT ("tokenList =",tokenList )
	PRINT ("lines =",lines )
	PRINT ("Before calling tokenLocations(lines, tokenList)" )
	
	# Note down the token locations (not relevant for batch mode)
	
	# Note: tokenLocations() only returns the result of the first occurrence of the tokenList in lines.
	# So, if there is repeated code, only the very first occurrence would be returned.
	# In this case below, it works though, since tokenList is nothing but the tokenized version of the whole lines.
	gTokenLocationLinesChars = tokenLocations(lines, tokenList)
	if gTokenLocationLinesChars == False:
		OUTPUT ("ERROR in mainWork() after calling tokenLocations(lines, tokenList) for lines=",lines," and tokenList =",tokenList )
		return False
	PRINT ("After calling tokenLocations, the starting <line,char> and ending <line,char> for each token is", gTokenLocationLinesChars )
	rootNode = Node(tokenList, "rootNode");
	
	# Parse the Code snippets
	
	PRINT ("Before calling parseCodeSnippet(tokenList, rootNode)" )
	parseCodeSnippetOutput = parseCodeSnippet(tokenListResult, rootNode) 
	if parseCodeSnippetOutput == False:
		OUTPUT ("ERROR after calling parseCodeSnippet(tokenList, rootNode)" )
		return False
	PRINT ("After calling parseCodeSnippet(tokenList, rootNode)" )
	PRINT ("\n\nNow traversing the AST ...\n\n" )
	rootNode.traverse()
	
	return True
	

def checkIfValidRawInput(inputBytes):
	if PYTHON2x and (not isinstance(inputBytes,basestring)):
		PRINT ("ERROR: Inside checkIfValidRawInput(), input byte stream <",inputBytes,"> is not a valid bytestream input - its type is", type(inputBytes),"instead of \"bytes\"")
		return False
	elif PYTHON3x and (not isinstance(inputBytes,(bytes,bytearray))):
		PRINT ("ERROR: Inside checkIfValidRawInput(), input byte stream <",inputBytes,"> is not a valid bytestream input - its type is", type(inputBytes),"instead of \"bytes\"")
		return False
	else:
		return True
		
###################################################################################################################################
# The different data types (like integer, float, double etc.) are stored differently. Here is how to decipher the stored value.
###################################################################################################################################

def printHexStringWord (inputBytes):
	if not checkIfValidRawInput(inputBytes):
		PRINT ("ERROR: Inside printHexStringWord(), input byte stream <",inputBytes,"> is not a valid bytestream input" )
		return False
	else:
		returnString="<"
		for byte in inputBytes:
			returnString += "%02X"%ORD(byte)
		returnString += ">"
		return returnString
	'''
	if len(inputBytes) == 1:
		return "<%02X>" %(ord(inputBytes[0]))
	elif len(inputBytes) == 2:
		return "<%02X %02X>" %(ord(inputBytes[0]),ord(inputBytes[1]))
	elif len(inputBytes) == 4:
		return "<%02X %02X %02X %02X>" %(ord(inputBytes[0]),ord(inputBytes[1]),ord(inputBytes[2]),ord(inputBytes[3]))
	elif len(inputBytes) == 8:
		return "<%02X %02X %02X %02X %02X %02X %02X %02X>" %(ord(inputBytes[0]),ord(inputBytes[1]),ord(inputBytes[2]),ord(inputBytes[3]),
															 ord(inputBytes[4]),ord(inputBytes[5]),ord(inputBytes[6]),ord(inputBytes[7]))
	else:
		return False
	'''


def calculateInternalValue(inputBytes, littleEndianOrBigEndian=LITTLE_ENDIAN, datatype="int", signedOrUnsigned="signed", bitFieldSize=0, bitStartPosition=0):
#	PRINT=OUTPUT
	if littleEndianOrBigEndian not in (LITTLE_ENDIAN, BIG_ENDIAN):
		errorMessage = "ERROR: Inside calculateInternalValue(), littleEndianOrBigEndian = <" + STR(littleEndianOrBigEndian) + "> is NOT either Little-Endian or Big-Endian" 
		errorRoutine(errorMessage)
		return False
	elif littleEndianOrBigEndian == LITTLE_ENDIAN:
		inputFormat = "Little-Endian"
	elif littleEndianOrBigEndian == BIG_ENDIAN:
		inputFormat = "Big-Endian"
	else:
		EXIT("Illegal input to calculateInternalValue()")
		

	#
	# When it is about bit-ordering within a single byte, there is no confusion with the convention. It's always MSb on the left, and LSb on the right.
	# It's just like we write numbers. The most significant digit is always on the left, and the least significant digit (the unit place) is on the right.
	#
	# In Little-Endian, the bits are packed from the LSB to MSB. So, if we have four bitfields in an integer, each 8 bits wide, they will be packed like this internally:
	#
	#	   Bit #   LSb  0..........7 8..........15 16........23 24.........31 MSb
	#                   K0........K7 L0.........L7 M0........M7 N0.........N7 
	#
	# However, the problem with this visualization is that we are putting the LSb of a byte on the left and MSb on the right, which is against our normal visualization
	# of a byte. So, if K = 64, its "usual" binary representation (01000000) will be shown above as 00000010, which will confuse the hell out of everyone.
	# Hence, we treat the bit-order within a byte sacrosanct (MSb on the left, LSb on the right), and completely flip the internal representation like this:
	#
	#      Bit #   MSb  31........24 23 ........16 15 ........8 7...........0 LSb
	#                   N7........N0 M7.........M0 L7........L0 K7.........K0
	#
	# However, the above was showing it Right-to-Left. Usually, when we display the memory, we usually display from Left-to-Right. So, we will see it like this:
	#      Byte#   LSB       Byte#0       Byte#1        Byte#2        Byte#3   MSB
	#      Bit #   MSb  7...........0 15 ........8  23 ........16 31........24 LSb
	#                   K7.........K0 L7........L0  M7.........M0 N7........N0 
	#  Observe that byte numbering is going from left to right, but the bit numbering is going from right-to-left.
	#
	# In other words, say the integer value is 0xNMLK (basically N*2^24+M*2^16+L*2^8+K), and we are storing it using Little-Endian method. 
	# Now, if we exmine the memory, we will see the 0xKLMN string. Instead of mapping these four bytes into a single LE integer, if we map it to a char array like c[4],
	# then we will see that c[0]=K, c[1]=L, c[2]=M, c[3]=N. Remember, unlike integer/short/Float, when we have a char array, its bytes will NEVER get reordered.
	# This is different than Big-Endian ordering. Even in BE, the 4 bytes under c[4] will not get reordered. So, for BE, we will see 0xNMLK string in the memory,
	# which will indeed represent the 0xNMLK value. But, when we map these 4 bytes with a char array c[4], we will see c[0]=N, c[1]=M, c[2]=L, c[3]=K.
	# So, in BE ordering, the least-significant byte will not overlap with the least-indexed array element.
	#
	# When our program analyzes the structure, it will come up with the following bitStartPosition values:
	# 
	#   struct {
	#             K : 8;	// bitStartPosition = 0
	#			  L : 8;    // bitStartPosition = 8
	#			  M : 8;    // bitStartPosition = 16
	#			  N : 8;    // bitStartPosition = 24
	#   }
	# But, this is different than the usual way of Little endian packing. For example, if the little-endian unsigned integer had an interanl 0xNMLK value, in the displayed byte
	# it shows as 0xKLMN (the order of the byte gets flipped). Similarly, 
	# In Big-Endian, the bits are packed from the MSB to LSB. So, change the starting position accordingly.
	#
	# Now, suppose we have the following two structs A and B - A is NOT packed, but B is packed:
	#  
	# Example 1:
	#-------------------------------------------------------------------------------------------------
	# struct A {                             |  struct __attribute__((__packed__)) B {               |                                   
	#             unsigned short s1: 8;      |                        unsigned short s1: 8 =   0xEF; |   
	#             unsigned short s2:16;      |                        unsigned short s2:16 = 0xABCD; |     
	#             unsigned short s3: 8;      |                        unsigned short s3: 8 =   0x12; |        
	# };                                     |            } ;                                        |
	#-------------------------------------------------------------------------------------------------
	# struct A will take 6 bytes. But since struct B is packed, it will only take 4 bytes. Now the question is how exactly B will look in the Little-endian vs Big-endian.
	# Suppose the value of S1 is 0xEF (decimal 239), value of s2 is 0xABCD (decimal 43981), and S3 is 0x12 (decimal 34).
	# 
	#___________________________________________________________________________________________________________________________________________
	#     Little-Endian packing (pack from the LSb to MSb)                  |    Big-Endian packing (pack from the MSb to LSb)                  |
	#_______________________________________________________________________|___________________________________________________________________|
	#     <-- short integer #1    -->   <--  short integer #0   -->         |    <-- short integer #1    -->    <-- short integer #0   -->      |
	# MSb 31........24   23........16 	15.........8 	 7........0  LSb 	|   31........24  	23........16 	15.........8 	7........0      |
	#     <--  s3  -->   <----------- s2 ----------->    <-- s1 -->         |   --s2-------->    <-- s3 -->     <--  s1  -->    <---- s2 --     |
	#     <-- 0x12 -->   <-- 0xAB -->    <-- 0xCD -->    <- 0xEF ->       	|   <-- 0xCD -->    <-- 0x12 -->    <-- 0xEF -->    <-- 0xAB -->    |
	# Now, the above was internal represenation, 0xEFCDAB12                 |  Now, the above was internal represenation, 0xCD12EFAB            |
	# Since this is Little-Endian packing, they will packed just like that. | However, since it is Big-endinan packing, when laid out in memory,|
	# So, the byte array would be like this: [0xEF, 0xCD, 0xAB, 0x12]       | the byte order of the short will change: [0xEF, 0xAB, 0xCD, 0x12] |
	# The byte order of the short will NOT change.                          | Observe that the s2 is still in contiguous bytes.
	#
	# Example 2:
	#
	# In the previous example, we found that even if we are storing in the Big-Endian format, the variable that spilled over two adjacent containers 
	# were still in contiguous bits. However, this following example will demonstrate that it was pure luck - when you pack a variable over the container
	# boundary, it cn end up in disjointed places.
	#---------------------------------------------------------
	#   struct __attribute__((__packed__)) B {               |                                   
	#                         unsigned char c1:3 =   0;      |   
	#                         unsigned char c2:8 = 0xFF;     |     
	#                         unsigned char c3:5 =   0;      |        
	#             } ;                                        |
	#---------------------------------------------------------
	#________________________________________________________________________________________________________________________________
	#     Little-Endian packing (pack from the LSb to MSb)       |    Big-Endian packing (pack from the MSb to LSb)                  |
	#____________________________________________________________|___________________________________________________________________|
	#     <-- char1 ->  <--char0-->                              |    <-- char1 ->  <--char0-->                                      |
	#     15.........8 	7........0                               |   15.........8 	7........0                                       |
	#      00000 111    11111  000                               |     111  00000   000  11111                                       |
	#     <-c3-> <---c2 ----> <-c1->                             |    -c2-> <-c3-> <-c1-><--c2                                       |
	#____________________________________________________________|___________________________________________________________________|
	#  The bits occupied by c2 is contiguous                     | The bits occupied by c2 is NOT contiguous.                        |
	#____________________________________________________________|___________________________________________________________________|
	#
	#
	# Example 3:
	#
	#---------------------------------------------------------
	#             struct  B {                                |                                   
	#                         unsigned short c1:6 =   0;     |   
	#                         unsigned short c2:3 = 0x7;     |     
	#                         unsigned short c3:7 =   0;     |        
	#             } ;                                        |
	#---------------------------------------------------------
	#________________________________________________________________________________________________________________________________
	#     Little-Endian packing (pack from the LSb to MSb)       |    Big-Endian packing (pack from the MSb to LSb)                  |
	#____________________________________________________________|___________________________________________________________________|
	# Internal representation of stored number in Little-endian  | Internal representation of stored number in Big-endian            |
	#     <-- char1 ->  <--char0-->                              |    <-- char1 ->  <--char0-->                                      |
	#    15.........8 	7........0                               |   15.........8 	7........0                                       |
	#      0000000 1    11 000000                                |     000000 11    1 0000000                                        |
	#      <- c3-> <- c2-> <-c1->                                |     <-c1-> <- c2-> <- c3->                                        |
	#____________________________________________________________|___________________________________________________________________|
	#    Memory layout in Little-endian (byte order unchanged)   | Memory layout in Big-endian (byte order changed for short)        |
	#     <-- char1 ->  <--char0-->                              |    <-- char1 ->  <--char0-->                                      |
	#    15.........8 	7........0                               |   15.........8 	7........0                                       |
	#      0000000 1    11 000000                                |     1  0000000   000000 11                                        |
	#      <- c3-> <-c2-> <- c1->                                |  -c2-> <- c3 ->  <- c1-> <-c2                                     |
	#____________________________________________________________|___________________________________________________________________|
	#  The bits occupied by c2 is contiguous                     | The bits occupied by c2 is NOT contiguous.                        |
	#____________________________________________________________|___________________________________________________________________|
	#
	# So, the point is, in Big-endian there is no guarantee that overall the variables would appear contiguous in memory.
	#
	if littleEndianOrBigEndian == BIG_ENDIAN:
		origBitStartPosition = bitStartPosition
		bitStartPosition = primitiveDatatypeLength[datatype]*BITS_IN_BYTE - bitFieldSize - bitStartPosition if bitFieldSize > 0 else bitStartPosition
		PRINT ("Inside calculateInternalValue() for inputFormat=",inputFormat, "for datatype of ",datatype,", changed the bitStartPosition from ",origBitStartPosition,"to",bitStartPosition,"for bitFieldSize =",bitFieldSize)
	
	PRINT ("\nInside calculateInternalValue(inputBytes =",printHexStringWord(inputBytes),"inputFormat =",inputFormat, "datatype =",datatype, "signedOrUnsigned =",signedOrUnsigned, "bitFieldSize =",bitFieldSize, "bitStartPosition = ",bitStartPosition)
	
	if datatype not in getDictKeyList(primitiveDatatypeLength):
		errorMessage = "ERROR: Inside calculateInternalValue(), datatype " + datatype+" NOT found in primitiveDatatypeLength.keys()="+STR(getDictKeyList(primitiveDatatypeLength))
		errorRoutine(errorMessage)
		return False
#	elif not checkIfString(inputBytes):
	elif not checkIfValidRawInput(inputBytes):
		errorMessage = "ERROR: Inside calculateInternalValue(), input byte stream "+printHexStringWord(inputBytes)+" is not a valid input" 
		errorRoutine(errorMessage)
		return False
	elif not inputBytes:
		errorMessage = "ERROR: Inside calculateInternalValue(), input byte stream <"+STR(inputBytes)+"> of length "+STR(len(inputBytes))+" Hex "+printHexStringWord(inputBytes)+" is not a valid input (most likely empty)" 
		errorRoutine(errorMessage)
		return False
	elif signedOrUnsigned!="unsigned" and signedOrUnsigned!="signed" :
		errorMessage = "ERROR: Inside calculateInternalValue(), input byte stream "+printHexStringWord(inputBytes)+" is not a valid input - the input "+ signedOrUnsigned+ " value is not either signed or unsigned" 
		errorRoutine(errorMessage)
		return False
	elif bitFieldSize > 0 and bitFieldSize > primitiveDatatypeLength[datatype]*BITS_IN_BYTE:	# It is a bitfield, so the MSBit is dependent on the bit field size
		errorMessage = "ERROR: Inside calculateInternalValue(), Width of bitfield " + STR(bitFieldSize) + " exceeds its type (" + datatype +")" 
		errorRoutine(errorMessage)
		return False
	elif bitFieldSize > 0 and (bitStartPosition <0 or bitStartPosition >= primitiveDatatypeLength[datatype]*BITS_IN_BYTE):
		errorMessage = "ERROR: Inside calculateInternalValue(), For the " + STR(bitFieldSize) + "-bit-wide" + datatype + ", the bitfield starting position "+ STR(bitStartPosition) + " is outside the valid range of <0," + STR(primitiveDatatypeLength[datatype]*BITS_IN_BYTE-1)+">" 
		errorRoutine(errorMessage)
		return False
	elif bitStartPosition !=0 and bitFieldSize <= 0:
		errorMessage = "ERROR: Non-bit fields cannot have a the bitfield starting position "+ STR(bitStartPosition)
		errorRoutine(errorMessage)
		return False
	elif bitFieldSize>0 and bitStartPosition+bitFieldSize > primitiveDatatypeLength[datatype]*BITS_IN_BYTE and len(inputBytes) != 2*primitiveDatatypeLength[datatype]:
		errorMessage = "ERROR: Inside calculateInternalValue(), for field width of "+ STR(bitFieldSize)+" bits of " + datatype +", the bitfield starting position " + STR(bitStartPosition) + " is outside the valid range of <0,"+STR(primitiveDatatypeLength[datatype]*BITS_IN_BYTE-bitFieldSize)+">" 
		errorRoutine(errorMessage)
		return False
	elif bitFieldSize==0 and len(inputBytes) != primitiveDatatypeLength[datatype]:
		errorMessage = "WARNING: Inside calculateInternalValue(), length of inputBytes ("+STR(len(inputBytes))+ ") is not primitiveDatatypeLength["+datatype+"], which is "+STR(primitiveDatatypeLength[datatype])
		errorRoutine(errorMessage)
		return False
	elif ((bitFieldSize==0) or  (bitFieldSize>0 and bitStartPosition+bitFieldSize < primitiveDatatypeLength[datatype]*BITS_IN_BYTE)) and len(inputBytes) not in (1,2,4,8):
		errorMessage = "WARNING: Inside calculateInternalValue(), length of inputBytes is not 1,2, 4 or 8 - Endianness is immaterial"
		errorRoutine(errorMessage)
		return False
	else:
#		PRINT ("="*30,"\nNo obvious input error!\n","="*30 )
		inputStr = ""
		for inputByte in inputBytes:
			inputStr += " "+hex(ORD(inputByte))
		PRINT("The input bytes to calculateInternalValue() are",inputStr)
		
		# This is the value without considering the sign
		IEEEFormatValue = 0
		if littleEndianOrBigEndian == LITTLE_ENDIAN:
			for i in range(len(inputBytes)):
				IEEEFormatValue = IEEEFormatValue + ORD(inputBytes[i])*2**(i*BITS_IN_BYTE)
		elif littleEndianOrBigEndian == BIG_ENDIAN:
			if len(inputBytes) == primitiveDatatypeLength[datatype]:
				for i in range(len(inputBytes)):
					IEEEFormatValue = IEEEFormatValue + ORD(inputBytes[i])*2**((len(inputBytes)-i-1)*BITS_IN_BYTE)
			elif len(inputBytes) == 2*primitiveDatatypeLength[datatype]:
				# The bitfield is spread over two containers
				containerSize = integerDivision(len(inputBytes),2)
				inputBytesFirst  = inputBytes[:containerSize ]
				inputBytesSecond = inputBytes[ containerSize:]
				IEEEFormatValueFirst = 0
				for i in range(containerSize):
					IEEEFormatValueFirst  = IEEEFormatValueFirst  + ORD(inputBytesFirst [i])*2**((containerSize-i-1)*BITS_IN_BYTE)
				IEEEFormatValueSecond = 0
				for i in range(containerSize):
					IEEEFormatValueSecond = IEEEFormatValueSecond + ORD(inputBytesSecond[i])*2**((containerSize-i-1)*BITS_IN_BYTE)
				IEEEFormatValue = IEEEFormatValueFirst * (2**containerSize) + IEEEFormatValueSecond
			else:
				OUTPUT("Coding ERROR in calculateInternalValue() - how did I come here???")
				OUTPUT("For datatype =",datatype,", len(inputBytes) =",len(inputBytes), ", primitiveDatatypeLength[datatype] =", primitiveDatatypeLength[datatype])
				OUTPUT("signedOrUnsigned=",signedOrUnsigned,", bitFieldSize =",bitFieldSize,", bitStartPosition =",bitStartPosition)
				sys.exit()
			
		else:
			sys.exit()
		PRINT ("For inputFormat =",inputFormat,", inputBytes =",printHexStringWord(inputBytes), "the IEEEFormatValue =",IEEEFormatValue,"(basically 0x%x"%(IEEEFormatValue),")" )

		################################################################
		# Pointer
		################################################################
		if datatype == "pointer":
			returnValue = IEEEFormatValue
		
		#######################################################################
		# Float / Double precision (all float/double are automatically signed)
		#######################################################################
		
		elif datatype in ("float","double"):	#For float, 31-st bit is Sign, [30:23] is 8-bit biased Exponent, [22:0] is 23-bit Mantissa
			if (datatype == "float" and len(inputBytes) != 4) or (datatype == "double" and len(inputBytes) != 8) :
				PRINT ("ERROR: Inside calculateInternalValue(), input byte stream ",printHexStringWord(inputBytes)," is not a valid float/double input" )
				return False
			else:
				fieldSize = 32 if datatype == "float" else 64
				exponentSize = 8 if datatype == "float" else 11
				mantissaSize = fieldSize - 1 - exponentSize
				exponentMask = ((1<<exponentSize)-1)<<mantissaSize
				mantissaMask = (1<<mantissaSize)-1
				exponentBias = (1<<(exponentSize-1))-1
				sign =  IEEEFormatValue >> (fieldSize-1)
				biasedExponent = (IEEEFormatValue & exponentMask) >> mantissaSize
				unbiasedExponent = biasedExponent - exponentBias
				mantissa = (IEEEFormatValue & mantissaMask)	# Recall that there is an implicit 1 at the beginning
				implicitLeadingPartOfMantissa = 1.00
				if biasedExponent == 0 or biasedExponent == (2**exponentSize) -1:
					PRINT ("WARNING: Inside calculateInternalValue(), biasedExponent = ",biasedExponent," is reserved for Special numbers" )
				if biasedExponent == 0 and mantissa == 0:
					returnValue = 0.00
				elif biasedExponent == (1<<exponentSize)-1 and mantissa == 0:
					returnValue = "+infinity" if sign == 0 else "-infinity" 
				elif biasedExponent == (1<<exponentSize)-1 and mantissa != 0:
					returnValue = "Not a Number (NaN)"
				else:
					if biasedExponent == 0 and mantissa != 0:
						PRINT ("Denormalized value (no implicit 1 in mantissa)" )
						implicitLeadingPartOfMantissa = 0
						
					mantissaWithImplicitOneincluded = "1.{:023b}".format(mantissa)
					realMantissaInDecimal = implicitLeadingPartOfMantissa + (mantissa * 1.000) / (2**mantissaSize)
					# So, the return value is (implicit.mantissa) * 2^unbiasedExponent
					returnValue = realMantissaInDecimal * (2**unbiasedExponent) * (-1 if sign == 1 else 1)
					
#				PRINT ("For inputBytes=",printHexStringWord(inputBytes),"IEEEFormatValue =",IEEEFormatValue,"sign =",sign,"biasedExponent =",biasedExponent,"exponentBias =",exponentBias,"unbiasedExponent =",unbiasedExponent )
#				PRINT ("mantissa = ",mantissa,"mantissaWithImplicitOneincluded = ",mantissaWithImplicitOneincluded, "realMantissaInDecimal = ",realMantissaInDecimal,"returnValue =",returnValue )

		################################################################
		# Signed Char/Short/Interger/Long
		################################################################
		
		elif signedOrUnsigned=="signed": 
			if datatype not in ("char", "short", "int", "long", "long long"):
				PRINT ("ERROR: Inside calculateInternalValue(), input byte stream <%s> is not a valid Signed input as the datatype = %s"%(printHexStringWord(inputBytes),datatype) )
				errorMessage = "ERROR: input byte stream <%s> is not a valid Signed input as its length = %d is not in (1,2,4 or 8)"%(printHexStringWord(inputBytes),len(inputBytes))
				errorRoutine(errorMessage)
			elif len(inputBytes) not in (1,2,4,8,16):
				PRINT ("ERROR: Inside calculateInternalValue(), input byte stream ",printHexStringWord(inputBytes)," is not a valid Signed input as its length =",len(inputBytes) )
				errorMessage = "ERROR: input byte stream <%s> is not a valid Signed input as its length = %d is not in (1,2,4 or 8)"%(printHexStringWord(inputBytes),len(inputBytes))
				errorRoutine(errorMessage)
				return False
			else:
				fieldWidthInBits = bitFieldSize if bitFieldSize > 0 else len(inputBytes)*8
				MSBitMask = 1 << (fieldWidthInBits-1)	# This assumes the field starts from bit 0. So, for bit-fields, you have to shift it first
				allOnesValue = (1<<fieldWidthInBits)-1		# This the 0xFF for char, or 0xFFFF for short, or 0xFFFFFFFF for int, or 0xFFFFFFFFFFFFFFFF for long
				
				# We only keep the relevant bits, and shift it to as if starting from 0. This is only useful for the bitfields
				IEEEFormatValue = (IEEEFormatValue & (allOnesValue<<bitStartPosition))>>bitStartPosition	
				
				PRINT ("For bitFieldSize=%d, bitStartPosition=%d, fieldWidthInBits=%d, MSBitMask=%x, allOnesValue=%x, IEEEFormatValue=%d" %(bitFieldSize, bitStartPosition,fieldWidthInBits,MSBitMask,allOnesValue,IEEEFormatValue) )
				
				if (IEEEFormatValue & MSBitMask) == MSBitMask: #Negative number
					# Suppose X is a positive or negative number. In two's complement system, to get -X, flip ALL the bits of X, then add one.
					# It works for both kinds of values (positive or negative) of X.
					returnValue = 0 - ((IEEEFormatValue ^ allOnesValue)+1)
				else:
					returnValue = IEEEFormatValue
					
		################################################################
		# Unsigned Char/Short/Integer/Long
		################################################################
		
		elif signedOrUnsigned=="unsigned" and datatype in ("char", "short", "short int", "int", "long", "long int", "long long"):
			if len(inputBytes) not in (1,2,4,8,16):
				errorMessage = "ERROR: Inside calculateInternalValue(), input byte stream "+printHexStringWord(inputBytes)+" is not a valid Signed input"
				errorRoutine(errorMessage)
				return False
			else:
				if bitFieldSize > 0:	# Only keep the relevant bits
					# Little-endian packs from LSB to MSB.   So, layout is MSb|...............|<--bitFieldSize-->|<---bitStartPosition-->| LSb
					IEEEFormatValue = (IEEEFormatValue & (( (1<<bitFieldSize)-1)<<bitStartPosition))>>bitStartPosition	
				returnValue = IEEEFormatValue
			
		################################################################
		# ERROR
		################################################################
		else:
			errorMessage = "ERROR in calculateInternalValue() - datatype <%s> is not supported -- exiting!"%datatype
			errorRoutine(errorMessage)
			return False
		
		PRINT ("datatype =",datatype)
		if DISPLAY_INTEGRAL_VALUES_IN_HEX and (datatype == "pointer" or datatype in integralDataTypes):
			return HEX(returnValue)
		else:
			return returnValue



############################################################################################################################################
############################################################################################################################################
# Encode the value
############################################################################################################################################
############################################################################################################################################
def encodeValue(decimalValue, littleEndianOrBigEndian=LITTLE_ENDIAN, datatype="int", signedOrUnsigned="signed", bitFieldSize=0, bitStartPosition=0):
#	PRINT=OUTPUT
	if littleEndianOrBigEndian not in (LITTLE_ENDIAN, BIG_ENDIAN):
		errorMessage = "ERROR in encodeValue() - Byte order neither little endian nor big endian!"
		errorRoutine(errorMessage)
		return [False, None]
	if bitFieldSize < 0:
		errorMessage = "ERROR in encodeValue() - bitFieldSize = <%d> cannot be less than 1!"%type(bitFieldSize)
		errorRoutine(errorMessage)
		return [False, None]
	if bitFieldSize > 0 and bitFieldSize > primitiveDatatypeLength[datatype]*BITS_IN_BYTE:
		errorMessage = "ERROR in encodeValue() - datatype <%s> is not supported -- exiting!"%type(decimalValue)
		errorRoutine(errorMessage)
		return [False, None]
		
	# For BIG-ENDIAN packing, we actually change the bit offset, so we keep a tab of
	originalBitStartPosition = bitStartPosition

	if datatype in ("float","double"):
		fieldSize = 32 if datatype == "float" else 64
		exponentSize = 8 if datatype == "float" else 11
		mantissaSize = fieldSize - 1 - exponentSize
		exponentBias = (1<<(exponentSize-1))-1
		sign =  0 if decimalValue >= 0 else 1		#IEEEFormatValue >> (fieldSize-1)
		absDecimalValue = abs(decimalValue)
		integerPart = int(absDecimalValue)
		fractionPart = absDecimalValue - integerPart
		if areFloatsCloseEnough(integerPart + fractionPart, absDecimalValue):
			PRINT("integerPart ("+STR(integerPart)+") + fractionPart ("+STR(fractionPart)+") == decimalValue ("+STR(decimalValue)+")")
		else:
			EXIT("integerPart ("+STR(integerPart)+") + fractionPart ("+STR(fractionPart)+") != decimalValue ("+STR(decimalValue)+")")
		PRINT ("decimalValue = integerPart (",integerPart,") + fractionPart (",fractionPart,")")
		
		# Calculate the integer part as an array of 1s and 0s
		integerPartBinary = []
		temp = integerPart
		while temp:
			binaryDigit = temp % 2
			integerPartBinary.append(binaryDigit)
			temp = integerDivision(temp,2)
		integerPartBinary.reverse()
		PRINT("integerPart (",integerPart,") is binarified as integerPartBinary =",integerPartBinary)
		
		if integerPartBinary[0] != 1:
			EXIT("Coding bug in encodeValue() for floating point")
		# We do not store the leading 1
		mantissaArray = integerPartBinary[1:]
		unbiasedExponent = len(mantissaArray)
		biasedExponent = unbiasedExponent + exponentBias
		PRINT("mantissaArray =",mantissaArray,", unbiasedExponent =",unbiasedExponent,", biasedExponent =",biasedExponent)
		
		temp = biasedExponent
		biasedExponentArray = []
		while temp:
			binaryDigit = temp % 2
			biasedExponentArray.append(binaryDigit)
			temp = integerDivision(temp,2)
		if exponentSize > len(biasedExponentArray):
			extra = [0 for x in range(exponentSize-len(biasedExponentArray))]
			biasedExponentArray.extend(extra)
		biasedExponentArray.reverse()
		if len(biasedExponentArray) != exponentSize:
			EXIT("Bug in coding in encodeValue() for floating point - len(biasedExponentArray) ="+STR(len(biasedExponentArray))+" != exponentSize ="+STR(exponentSize))
		PRINT("biasedExponent =",list2plaintext(biasedExponentArray,""),", len(biasedExponent) =", len(biasedExponentArray))
		
		# In case the integer part of the float itself is massive and consuming all of the mantissaSize (or exceeding it), keep only the first mantissaSize bits
		if len(mantissaArray) >= mantissaSize:
			PRINT("Keeping only the first",mantissaSize,"bits of the current ",STR(len(mantissaArray))+"-bit mantissa")
			mantissaArray = mantissaArray[:mantissaSize]
			
		# Calculate the fraction part as an array of 1s and 0s
		temp = fractionPart
		while True:
			if len(mantissaArray) >= mantissaSize:
				break
#			PRINT("temp = ", temp)
			temp *= 2
			if temp >= 1:
				binaryDigit = 1
				temp -= 1.0
			else:
				binaryDigit = 0
			mantissaArray.append(binaryDigit)

		if len(biasedExponentArray) + len(mantissaArray) + 1 != fieldSize:
			EXIT("Coding but in encodeValue() for floating point - len(biasedExponentArray) ("+STR(len(biasedExponentArray))+") + len(mantissaArray) ("+STR(len(mantissaArray))+") + 1 != fieldSize ="+STR(fieldSize))

		returnBitArray = [sign]+biasedExponentArray+mantissaArray
		PRINT("The",len(returnBitArray),"-bit wide returnBitArray =", returnBitArray)
		
		returnByteArray = []
		
		nextBitToConsume = 0
		while nextBitToConsume < fieldSize:
			byte = returnBitArray[nextBitToConsume: nextBitToConsume+BITS_IN_BYTE]
			byteValue = 0
			for i in range(BITS_IN_BYTE):
				byteValue += byte[i]<<(BITS_IN_BYTE-1-i)
			PRINT("Converted byte =",byte,"to byteValue =",byteValue)
			returnByteArray.append(byteValue)
			nextBitToConsume += BITS_IN_BYTE
		PRINT("returnByteArray[] =",returnByteArray," (", len(returnByteArray),"bytes)")
		if len(returnByteArray)*BITS_IN_BYTE != fieldSize:
			EXIT("Coding but in encodeValue() for floating point - len(returnByteArray) ="+STR(len(returnByteArray))+" != "+STR(integerDivision(fieldSize,BITS_IN_BYTE)))

		
		
	elif datatype in ("char","short","int","long","long long"):
		maxBits = primitiveDatatypeLength[datatype]*BITS_IN_BYTE
		if littleEndianOrBigEndian==BIG_ENDIAN and bitFieldSize>0:
			bitStartPosition = maxBits - (originalBitStartPosition+bitFieldSize)
			PRINT("Because of Big-endian packing, bitStartPosition changed from",originalBitStartPosition,"to",bitStartPosition)
		
		if not checkIfIntegral(decimalValue):
			errorMessage = "ERROR in encodeValue(): "+STR(decimalValue)+" is not integral"
			errorRoutine(errorMessage)
			return [False, None]
		elif bitFieldSize < 0 or bitStartPosition < 0 or bitStartPosition + bitFieldSize > maxBits:
			errorMessage = "ERROR in encodeValue(): bitStartPosition="+STR(bitStartPosition)+" with bitFieldSize="+STR(bitFieldSize)+" is not allowed for "+datatype+" as it exceeds "+STR(maxBits)+" bits"
			errorRoutine(errorMessage)
			return [False, None]
		
		totalBits = bitFieldSize if bitFieldSize > 0 else maxBits
		if signedOrUnsigned=="signed":
			if -(2**(totalBits-1)) <= decimalValue < (2**(totalBits-1)):
				PRINT("decimalValue =",decimalValue,"falls within the acceptable signed range")
			else:
				errorMessage = "ERROR in encodeValue(): "+STR(decimalValue)+" falls outside the acceptable range"
				errorRoutine(errorMessage)
				return [False, None]
		elif signedOrUnsigned=="unsigned":
			if 0 <= decimalValue <= (2<<totalBits)-1:
				PRINT("decimalValue =",decimalValue,"falls within the acceptable unsigned range")
			else:
				errorMessage = "ERROR in encodeValue(): "+STR(decimalValue)+" falls outside the acceptable unsigned range"
				errorRoutine(errorMessage)
				return [False, None]
		else:
			EXIT("Unknown value of signedOrUnsigned = "+signedOrUnsigned+" not supported yet")
		
		bitArray = []
		if decimalValue < 0:
			value2convert = (2**totalBits)-abs(decimalValue)	# Converting to 2's compliment and sign-extending it
			PRINT("In two's complement we convert",decimalValue,"to", value2convert)
		else:
			value2convert = decimalValue
		
		binaryBits = []
		temp = value2convert
		while temp:
			binaryBits.append(temp%2)
			temp = integerDivision(temp,2)
		PRINT("We convert the two's complement decimalValue =",value2convert,"as LSb",binaryBits,"MSb format, or MSb", binaryBits[::-1],"LSb format(with totalBits=",totalBits,")")

		# Now create a whole char/short/int/long etc.
		
		#       MSb ......................................... LSb
		#     (maxBits-1) .................................... 0
		#       <--padding--> <--totalBits-->|<--padding-->
		#                                    ^
		#                                    |
		#                             bitStartPosition
		for i in range(bitStartPosition):
			bitArray.append(0)
		for i in range(len(binaryBits)):
			bitArray.append(binaryBits[i])
		# In case the number did not use all the allocated bits (for example if for "int i:8;" we have a value of only 12 that uses only 5 bits
		for i in range(totalBits-len(binaryBits)):
			bitArray.append(0)
		for i in range(maxBits-len(bitArray)):
			bitArray.append(0)
		PRINT("bitArray =",bitArray)
		PRINT("Reversing the bitarray")
		bitArray = bitArray[::-1]
		PRINT("bitArray =",bitArray)
		
		if len(bitArray) != maxBits:
			EXIT("Coding bug in encodeValue(): For bitStartPosition ("+STR(bitStartPosition)+", bitFieldSize = "+STR(bitFieldSize)+", totalBits = "+STR(totalBits)+", len(bitArray) ("+STR(len(bitArray))+") != maxBits ("+STR(maxBits)+")")
		

		returnByteArray = []
		byteIndex = 0
		while True:
			if (byteIndex+1) * BITS_IN_BYTE > len(bitArray):
				break
			bits2add = bitArray[byteIndex*BITS_IN_BYTE:(byteIndex+1)*BITS_IN_BYTE]
			PRINT("bits2add =",bits2add)
			if len(bits2add) != BITS_IN_BYTE:
				EXIT("Coding bug in encodeValue(): len(bits2add) = "+STR(len(bits2add))+" != BITS_IN_BYTE")
			byte2add = 0
			for i in range(BITS_IN_BYTE):
				byte2add += bits2add[i]*(2**(BITS_IN_BYTE-1-i))
			PRINT("After convering bits2add =",bits2add,"to",byte2add,", adding it as returnByteArray[",byteIndex,"]")
			returnByteArray.append(byte2add)
			byteIndex += 1

		
	else:
		EXIT("Datatype Not supported yet")

	returnByteArrayHex = []
	for x in returnByteArray:
		val = "0x{:02X}".format(x)
		returnByteArrayHex.append(val)
	if littleEndianOrBigEndian==LITTLE_ENDIAN and len(returnByteArrayHex)>1:
		PRINT("Reversing the returnByteArrayHex since it is Little endian")
		PRINT("returnByteArray =", returnByteArray[::-1],", returnByteArrayHex =",returnByteArrayHex[::-1])
	else:
		PRINT("returnByteArray =", returnByteArray,", returnByteArrayHex =",returnByteArrayHex)

	# Python 2 and 3 stores the string separately. So we need to encode it differently.
	
	if PYTHON2x: 
		outputBytes = ""
	elif PYTHON3x:
		outputBytes = bytearray()
	
	PRINT("\nStarting with outputBytes =",outputBytes,", type(outputBytes) =",type(outputBytes))
	
#	returnByteArray = [0x41, 0x2b, 0x33, 0x33]	# Hardcoded for text
	index = 0
	while index < len(returnByteArray):
		byte2add = returnByteArray[index]
		PRINT("byte #",index,"of returnByteArray =",byte2add)
		if PYTHON2x:
			py2Byte = chr(byte2add)
			PRINT("The output byte is ",py2Byte)
			outputBytes += py2Byte
		else:
			py3Byte = bytes([byte2add])
			PRINT("The output byte is ",py3Byte)
			outputBytes += py3Byte
		PRINT("After adding byte #",index," = <",byte2add,">, outputBytes =",outputBytes,", len(outputBytes) =", len(outputBytes))
		index += 1
	PRINT("\nFinal outputBytes =",outputBytes)
	
	if littleEndianOrBigEndian==LITTLE_ENDIAN and len(outputBytes)>1:
		PRINT("Reversing the outputBytes since it is Little endian")
		outputBytes = outputBytes[::-1]


	bitStartPosition = originalBitStartPosition

	result = calculateInternalValue(outputBytes, littleEndianOrBigEndian, datatype, signedOrUnsigned, bitFieldSize, bitStartPosition)
	PRINT ("calculateInternalValue() = ", result)
	
	if getRuntimeValue([result,'==',decimalValue])[1]:	# Assuming no errors
		PRINT("result ("+STR(result)+ ") matches decimalValue (" +STR(decimalValue)+")")
	else:
		EXIT("result ("+STR(result)+ ") != decimalValue (" +STR(decimalValue)+")")


	return [True, outputBytes]

#MUST_PRINT( encodeValue(1, LITTLE_ENDIAN, "float")[1])
#sys.exit()

def charIsValidHex(c):
	if ('0' <= c <= '9') or ('a' <= c <= 'f') or ('A' <= c <= 'F'):
		return True
	else:
		return False
		
# This check if the input file is really binary, or rather text representation of Hex chars. If the latter, it fills out a binary array corresponding to it.
def inputFileIsHexText():

	global binaryArray, hexCharArray 
	
	if checkIfIntegral(dataFileName):
		if dataFileName not in range(len(demoData)):
			EXIT("Coding bug in inputFileIsHexText() - the demo data # "+STR(dataFileName)+" does not exist!!")
		data = demoData[dataFileName]
		fileLengthInBytes = len(data)
		PRINT ( "len(data) = ",len(data),"type(data)=",type(data))		# str for Python2, bytes for Python3
	elif checkIfString(dataFileName):
		fileLengthInBytes = os.path.getsize(dataFileName)
		PRINT("Length of the",dataFileName, "file = ",fileLengthInBytes)

		with open(dataFileName, "rb") as file:
			data = file.read()
			PRINT ( "len(data) = ",len(data),"type(data)=",type(data))		# str for Python2, bytes for Python3
			#PRINT ( "type(data[0])=",type(data[0]))							# str for Python2, int for Python3
			#PRINT ( "type(data[0:1])=",type(data[0:1]))						# str for Python2, bytes for Python3

			# We cannot operate RegEx on bytes in Python3, so we need to convert it to string first. If UTF-8 complains, we know it's not text file anyway
			if PYTHON3x:
				try:
					data = data.decode("utf-8")
				except UnicodeDecodeError:
					PRINT("Input file is NOT text")
					return False
				
	hexCharCount = 0
	spaceCount = 0
	hex0xPrefixCount = 0
	nonHexCharCount = 0
	hexCharArray = []
	binaryArray      = "" if PYTHON2x else bytearray() if PYTHON3x else []
	countItNextTime = False


	for n in range(len(data)):
		PRINT ("data[",n,"] =",data[n],"type(data[n]) =",type(data[n]))
		if re.match("[,\s]+",data[n:n+1]) and (n<len(data)-1) and re.match("[,\s]+",data[n+1:n+2]):
			continue
		elif data[n] == '0' and n<len(data)-1 and data[n+1] == 'x':	# Make sure you do not count the 0 in 0x as part of a valid Hex byte
			PRINT( "Prefix found")
			continue
		#elif countItNextTime == False and self.charIsValidHex(data[n]) and (n<len(data)-1) and self.charIsValidHex(data[n+1]):
		elif countItNextTime == False and charIsValidHex(data[n]) and (n<len(data)-1) and charIsValidHex(data[n+1]):
			countItNextTime = True
			continue
		elif re.match("[,\s]+",data[n:n+1]):
			spaceCount += 1
		#elif countItNextTime == True and self.charIsValidHex(data[n]) and (n>0) and self.charIsValidHex(data[n-1]):
		elif countItNextTime == True and charIsValidHex(data[n]) and (n>0) and charIsValidHex(data[n-1]):
			hexCharCount += 1
			hexCharArray.append(data[n-1:n+1])
			byte0 = ord(data[n-1]) - ord('0') if ('0' <= data[n-1] <= '9') else 10 + ord(data[n-1]) - ord('a') if ('a' <= data[n-1] <= 'f') else 10 + ord(data[n-1]) - ord('A') if ('A' <= data[n-1] <= 'F') else 0
			byte1 = ord(data[n  ]) - ord('0') if ('0' <= data[n  ] <= '9') else 10 + ord(data[n  ]) - ord('a') if ('a' <= data[n  ] <= 'f') else 10 + ord(data[n  ]) - ord('A') if ('A' <= data[n  ] <= 'F') else 0
			if PYTHON2x:
				binaryArray += chr(byte0*16+byte1) 
			elif PYTHON3x:
				binaryArray.append(byte0*16+byte1)
			else:
				sys.exit()
				
			countItNextTime = False
		#elif data[n] == 'x' and n>0 and data[n-1] == '0' and (n<len(data)-3) and self.charIsValidHex(data[n+1]) and self.charIsValidHex(data[n+2]):
		elif data[n] == 'x' and n>0 and data[n-1] == '0' and (n<len(data)-3) and charIsValidHex(data[n+1]) and charIsValidHex(data[n+2]):
			hex0xPrefixCount += 1
		else:
			hexCharArray = []
			binaryArray = ""
			
			PRINT ("\n"*3,"REAL Binary file, NOT Textified hex","\n"*3,)
			return False
			nonHexCharCount += 1

	PRINT ( "hexCharCount =", hexCharCount)
	PRINT ( "spaceCount =", spaceCount)
	PRINT ( "hex0xPrefixCount =", hex0xPrefixCount)
	PRINT ( "nonHexCharCount =", nonHexCharCount)
	PRINT ( len(hexCharArray),"-size hexCharArray =", hexCharArray)
	PRINT ( len(binaryArray),"-size binaryArray =", binaryArray)
	
	return True
	
################################################################################################
# This routine takes in a variableId and its value, and it returns its enum literal value.
################################################################################################
def returnEnumLiteralForValue(variableId, inputValue):
#	PRINT=OUTPUT
	if variableId >= len(variableDeclarations):
		errorMessage = "Error in returnEnumLiteralForValue(): Supplied variableId="+STR(variableId)+" is out of bounds"
		errorRoutine(errorMessage)
		return [False, None]
		
	enumType = variableDeclarations[variableId][4]["enumType"]
	if enumType == None:
		errorMessage = "Error in returnEnumLiteralForValue(): Supplied variableId="+STR(variableId)+" is not enum"
		errorRoutine(errorMessage)
		return [False, None]
		
	PRINT("Printing enum literals for variableId",variableId)
	
	if checkIfIntegral(inputValue):
		value = STR(inputValue)
	elif checkIfString(inputValue):
		value = inputValue
	else:
		EXIT("Bad coding in returnEnumLiteralForValue() - inputValue of", STR(inputValue),"neither integral nor string")
		
	negativeValue = True if value[0]=="-" else False
	charsComsumed = 1 if negativeValue else 0
	if DISPLAY_INTEGRAL_VALUES_IN_HEX:
		if value[charsComsumed:charsComsumed+2] != "0x":
			errorMessage = "No 0x in supposedly Hex value of <"+value+">"
			errorRoutine(errorMessage)
			return False
		else:
			valueList = [value[charsComsumed:]]
	else:
		valueList = [value[charsComsumed:]]
		
	PRINT("Calling getRuntimeValue(valueList) for valueList=",STR(valueList))
	getRuntimeValueResult = getRuntimeValue(valueList)
	if getRuntimeValueResult[0]==False:
		errorMessage = "Error evaluating <"+STR(valueList)+">"
		errorRoutine(errorMessage)
		return False
	else:
		valueActual = getRuntimeValueResult[1]
		if negativeValue:
			valueActual = valueActual * (-1)
		PRINT("valueActual =",valueActual)
		valueToDisplay = STR(valueActual)
		if enumType in getDictKeyList(enums):
			matchingEnumLiteralList = []	# Multiple literals might match the same value
			for enumTypeLiteral in getDictKeyList(enums[enumType]):
				if enums[enumType][enumTypeLiteral] == valueActual:
					PRINT("Found enum literal "+enumTypeLiteral+" corresponding to "+STR(valueActual))
					matchingEnumLiteralList.append(enumTypeLiteral)
			if len(matchingEnumLiteralList) > 0:
				if len(matchingEnumLiteralList) == 1:
					valueToDisplay = STR(valueToDisplay)+" ("+STR(matchingEnumLiteralList[0])+")"
				else:
					valueToDisplay = STR(valueToDisplay)+" ("+'/'.join(matchingEnumLiteralList)+")"
		else:
			errorMessage = "Error in prettyPrintUnraveled: Unknown enumType <"+STR(enumType)+">"
			errorRoutine(errorMessage)
			return False
	return [True, valueToDisplay]


##############################################################################################
# This function does a pretty printing of the unraveled list
##############################################################################################
def prettyPrintUnraveled(displayAncestry=False):
	PRINT("\n\n\n","==="*50,"\nInside prettyPrintUnraveled()\n","==="*50)
	if unraveled == []:
		return True
	
	OUTPUT ("\n\n\n\n")
	OUTPUT ("=="*80)
	OUTPUT ("M A P P I N G    O F    T H E   L A Y O U T     O N T O    T H E     D A T A")
	OUTPUT ("=="*80)
	OUTPUT ("\n\n")
	
	unraveledColumnMaxWidths = []
	
	treeViewAllRowsValues = []
	
	# Right now, we have a added a new column at the end - the ancestry. This does not get displayed in the Tree view.
	maxNumberOfColumns = len(treeViewHeadings)
	for N in range(len(unraveled)):
		# The first column is the level #, which we do not display. We do not display the last column etiher, which is the Ancestry
		maxNumberOfColumns = len(unraveled[N])-1 if len(unraveled[N])-2 > maxNumberOfColumns else maxNumberOfColumns
	
	if maxNumberOfColumns > len(treeViewHeadings):
		OUTPUT ("ERROR: There are more fields (",maxNumberOfColumns,") in unraveled than number of headings (",len(treeViewHeadings),")")
		for N in range(len(unraveled)):
			if len(unraveled[N])== maxNumberOfColumns:
				PRINT ("unraveled[",N,"] = ",unraveled[N])
		sys.exit()
		
	#PRINT ("maxNumberOfColumns =",maxNumberOfColumns)
	
	for c in range(maxNumberOfColumns):
		unraveledColumnMaxWidths.append(len(treeViewHeadings[c]))

	for N in range(len(unraveled)):
		PRINT("Hi")
		PRINT ("\nN =",N, "unraveled[",N,"][2] =",unraveled[N][2],"\n\n")
		PRINT ("BYE")
		levelIndent = "    " * unraveled[N][0]
		dataTypeText = unraveled[N][2] if not isinstance(unraveled[N][2],dict) else unraveled[N][2]["datatype"] if unraveled[N][2]["signedOrUnsigned"] != "unsigned" or unraveled[N][2]["datatype"] == "pointer" else unraveled[N][2]["signedOrUnsigned"] + " " + unraveled[N][2]["datatype"]
		if N<len(unraveled)-1 and unraveled[N][0]==unraveled[N+1][0]-1 and isinstance(unraveled[N][2],dict) and unraveled[N][2]["isArray"]:	# The current node is a parent - an array 
			dataTypeText += " array"
		if isinstance(unraveled[N][2],dict) and unraveled[N][2]["datatype"].startswith("function "):	# Hardcode it for functions
			dataTypeText = "function"
		if isinstance(unraveled[N][2],dict) and ("isBitField" in getDictKeyList(unraveled[N][2])) and unraveled[N][2]["isBitField"]:
			isBitField = unraveled[N][2]["isBitField"]
			bitFieldWidth = unraveled[N][2]["bitFieldWidth"]
			bitOffsetWithinStruct = unraveled[N][2]["bitOffsetWithinStruct"]
#			bitFieldInfo = unraveled[N][2]["bitFieldInfo"]
		else:
			isBitField = False
			
		try:
			if isBitField:
#				addrStart = hex(unraveled[N][3]+integerDivision(bitOffsetWithinStruct,BITS_IN_BYTE)) + "." + STR(bitOffsetWithinStruct%BITS_IN_BYTE)
#				addrEnd = hex(unraveled[N][3]+integerDivision(bitOffsetWithinStruct+bitFieldWidth,BITS_IN_BYTE)) + "." + STR((bitOffsetWithinStruct+bitFieldWidth)%BITS_IN_BYTE)
				addrStart = hex(unraveled[N][3]  ) + "." + STR((unraveled[N][2]["bitOffsetWithinStruct"])%BITS_IN_BYTE)
				addrEnd   = hex(unraveled[N][3]+bit2Byte((unraveled[N][2]["bitOffsetWithinStruct"]%BITS_IN_BYTE)+unraveled[N][2]["bitFieldWidth"]-1))+"." + STR((unraveled[N][2]["bitOffsetWithinStruct"]+unraveled[N][2]["bitFieldWidth"]-1)%BITS_IN_BYTE)

				'''
				addrStartOld = hex(unraveled[N][3]+integerDivision(bitFieldInfo["currentBitFieldSequenceCurrentContainerBitIndexStart"],BITS_IN_BYTE)) + "." + STR(bitFieldInfo["currentBitFieldSequenceCurrentContainerBitIndexStart"]%BITS_IN_BYTE)
				addrEndOld = hex(unraveled[N][3]+integerDivision(bitFieldInfo["currentBitFieldSequenceCurrentContainerBitIndexEndInclusive"],BITS_IN_BYTE)) + "." + STR(bitFieldInfo["currentBitFieldSequenceCurrentContainerBitIndexEndInclusive"]%BITS_IN_BYTE)
				if addrStartOld != addrStart or addrEndOld != addrEnd:
					OUTPUT("Mismatch in prettyPrintUnraveled() for unraveled[",N,"=",N,"] =",unraveled[N])
					OUTPUT("addrStart (",addrStartOld," != addrStartNew (",addrStart,"), or addrEndOld (",addrEnd,") != addrEnd (",addrEnd,")")
					sys.exit()
				'''
			else:
				addrStart = hex(unraveled[N][3])
				addrEnd = hex(unraveled[N][4]-1)
				
			if PRINT_ENUM_LITERALS and variableDeclarations[unraveled[N][8][-1]][4]["enumType"]!=None:
				variableId = unraveled[N][8][-1]
				
				valueLE = unraveled[N][6]
				PRINT("Printing enum literals for variableId",variableId,", valueLE=",valueLE)
				returnEnumLiteralForValueResult = returnEnumLiteralForValue(variableId, valueLE)
				if returnEnumLiteralForValueResult[0]==False:
					errorMessage = "Error in prettyPrintUnraveled(): Cannot enum literals for variableId "+STR(variableId)+", valueLE="+STR(valueLE)
					errorRoutine(errorMessage)
					return False
				else:
					valueLE2Display = returnEnumLiteralForValueResult[1]

				valueBE = unraveled[N][7]
				PRINT("Printing enum literals for variableId",variableId,", valueBE=",valueBE)
				returnEnumLiteralForValueResult = returnEnumLiteralForValue(variableId, valueBE)
				if returnEnumLiteralForValueResult[0]==False:
					errorMessage = "Error in prettyPrintUnraveled(): Cannot enum literals for variableId "+STR(variableId)+", valueBE="+STR(valueBE)
					errorRoutine(errorMessage)
					return False
				else:
					valueBE2Display = returnEnumLiteralForValueResult[1]

				treeViewSingleRowValues = [levelIndent+unraveled[N][1], dataTypeText,addrStart,addrEnd,unraveled[N][5], valueLE2Display, valueBE2Display]
			else:
				treeViewSingleRowValues = [levelIndent+unraveled[N][1], dataTypeText,addrStart,addrEnd,unraveled[N][5],STR(unraveled[N][6]),STR(unraveled[N][7])]
			treeViewAllRowsValues.append(treeViewSingleRowValues)
		except IndexError:
			OUTPUT ("IndexError in prettyPrintUnraveled(): List index out of range for N = ",N)
			OUTPUT ("unraveled[N] =", unraveled[N])
			OUTPUT ("treeViewAllRowsValues = ")
			OUTPUT (treeViewAllRowsValues)
			sys.exit()
		for c in range(len(treeViewSingleRowValues)):
			newLength = 0 if treeViewSingleRowValues[c] == None else 5 if type(treeViewSingleRowValues[c]) == bool else len(treeViewSingleRowValues[c])
			unraveledColumnMaxWidths[c] = newLength if newLength > unraveledColumnMaxWidths[c] else unraveledColumnMaxWidths[c]

	# Now that we have gotten the maximum length, let's print it
	headerString = ""
	bottomLine = ""
	for c in range(maxNumberOfColumns):
		# The last 3 column headers need to be right-justified
		if c < maxNumberOfColumns-5:
			headerString +=         treeViewHeadings[c] +" "* (unraveledColumnMaxWidths[c]-len(treeViewHeadings[c])) + "   "
			bottomLine   += "="*len(treeViewHeadings[c])+" "* (unraveledColumnMaxWidths[c]-len(treeViewHeadings[c])) + "   "
		else:
			headerString += " "* (unraveledColumnMaxWidths[c]-len(treeViewHeadings[c])) +         treeViewHeadings[c] + "   "
			bottomLine   += " "* (unraveledColumnMaxWidths[c]-len(treeViewHeadings[c])) + "="*len(treeViewHeadings[c])+ "   "
	OUTPUT (bottomLine)
	OUTPUT (headerString)
	OUTPUT (bottomLine)
		
	for N in range(len(treeViewAllRowsValues)):
		rowText = ""
		for c in range(len(treeViewAllRowsValues[N])):
			lengthCurrentItem = len(treeViewAllRowsValues[N][c]) if not checkIfBoolean(treeViewAllRowsValues[N][c]) else 5 
			currentItem = treeViewAllRowsValues[N][c] if not checkIfBoolean(treeViewAllRowsValues[N][c]) else "True " if treeViewAllRowsValues[N][c] else "False"
			if c <= 1:
				rowText += currentItem + " "* (unraveledColumnMaxWidths[c]-lengthCurrentItem) + "   "
			else:
				rowText += " "* (unraveledColumnMaxWidths[c]-lengthCurrentItem) + currentItem + "   "
				
		if displayAncestry:
			currentRowAncestryVariableIds = unraveled[N][8]
			currentRowAncestryVariableNames = [variableDeclarations[x][0] for x in currentRowAncestryVariableIds]
			currentRowAncestryText = STR(currentRowAncestryVariableIds)+ " "*(30-len(STR(currentRowAncestryVariableIds))) + STR(currentRowAncestryVariableNames)+" "*(30-len(STR(currentRowAncestryVariableNames))) + "<"+unraveled[N][1]+">"
			rowText = rowText + currentRowAncestryText
			
		OUTPUT (rowText)

	
	# Write the header and data to a snapshot file
	while True:
		try:
			outputFile = open(SNAPSHOT_FILE_NAME,"w")
			break
		except IOError:
			warningMessage = "WARNING: cannot open the "+SNAPSHOT_FILE_NAME+" file for writing - possibly already open. Please close it and only then press OK here."
			warningRoutine(warningMessage)
			return False
	headerString = ""
	for c in range(maxNumberOfColumns):
		headerString += treeViewHeadings[c] + ("," if c < maxNumberOfColumns-1 else "\n")
	outputFile.write(headerString)
			
	for N in range(len(treeViewAllRowsValues)):
		rowText = ""
		for c in range(maxNumberOfColumns):
			currentItem = treeViewAllRowsValues[N][c] if not checkIfBoolean(treeViewAllRowsValues[N][c]) else "True " if treeViewAllRowsValues[N][c] else "False"
			rowText += currentItem + ("," if c < maxNumberOfColumns-1 else "\n")
		outputFile.write(rowText)
		
	outputFile.close()
	return True

def dumpDetailsForDebug(MUST=False):
	global PRINT_DEBUG_MSG
	
	PRINT_DEBUG_MSG_backed_up = PRINT_DEBUG_MSG
	
	if MUST:
		PRINT_DEBUG_MSG = True
	
	PRINT ("\n"*3,"=="*50,"\nBEGIN Dumping data for debug\n","=="*50,"\n"*3)

	PRINT ("pragmaPackStack =",pragmaPackStack)
	PRINT ("dataLocationOffset = ",dataLocationOffset )
	PRINT ("fileDisplayOffset =",fileDisplayOffset )
	PRINT ("totalBytesToReadFromDataFile =",totalBytesToReadFromDataFile)
	PRINT ("len(dataBlock) =",len(dataBlock))
	PRINT ("size of variableDeclarations =",len(variableDeclarations) )
	PRINT ("\n"*3,"==="*50,"\nsuDict\n","=="*50 )
	for key in getDictKeyList(suDict):
		PRINT("suDict[",key,"] = ",suDict[key])
	PRINT ("\n"*3,"==="*50,"\nstructuresAndUnions has", len(structuresAndUnions),"entries\n","=="*50 )
	PRINT ("\n"*3,"==="*50,"\nstructuresAndUnions\n","=="*50 )
	for item in structuresAndUnions:
		PRINT ("\n")
		structAttributes = ""
		for key in getDictKeyList(item):
			if key != 'components':
				structAttributes += key + " : "+STR(item[key])+", "
		if 'components' in getDictKeyList(item):
			components = item['components']
			structAttributes += key + ", 'components' : \n"
			for row in components:
				structAttributes+="\n"+STR(row)
		PRINT(structAttributes)
		
	PRINT ("=="*50,"\n"*3 )
	PRINT ("\n"*3,"==="*50,"\nvariableDeclarations\n","=="*50 )
	for item in variableDeclarations:
		PRINT ("\n",item )
	PRINT ("=="*50,"\n"*3 )
	PRINT ("\nvariableIdsInGlobalScope[variableId, scopeStartVariableId, scopeEndVariableId]) =\n")
	for item in variableIdsInGlobalScope:
		PRINT (item, variableDeclarations[item[0]][0])
	PRINT ("\nglobalScopesSelected [variableId, scopeStartVariableId, scopeEndVariableId]) =\n")
	if globalScopesSelected:
		for item in globalScopesSelected:
			PRINT (item)
			try:
				PRINT (variableDeclarations[item[0]][0])
			except IndexError:
				OUTPUT("\n\nAn error occurred with the following statement:\nPRINT (variableDeclarations[item[0]][0])")
				OUTPUT("item in globalScopesSelected for which this error occurreed =", item)
				OUTPUT("\nglobalScopes =\n",variableIdsInGlobalScope)
				OUTPUT("\nglobalScopesSelected =\n",globalScopesSelected)
				OUTPUT("\nvariableDeclarations =\n",variableDeclarations)
	PRINT ("currentMacroNames =",currentMacroNames)
	PRINT ("macroDefinitions = ")
	for item in macroDefinitions:
		PRINT (item)
	PRINT ("\n\n","==="*50)
	PRINT("\n\nenums =",enums)
	PRINT ("\n\n","==="*50)
	PRINT("\n\nenumFieldValues =",enumFieldValues)
	if blankArraysAndTerminationInfo:
		PRINT ("blankArraysAndTerminationInfo =")
		for key in getDictKeyList(blankArraysAndTerminationInfo):
			PRINT ("blankArraysAndTerminationInfo[key=",key,"] = ",blankArraysAndTerminationInfo[key])
	PRINT ("\nsrcFileDetails =")
	for row in srcFileDetails:
		PRINT (row)
	PRINT ("variablesAtGlobalScopeSelected =",variablesAtGlobalScopeSelected)
	PRINT ("variablesAtGlobalScopeSelected =",[variableDeclarations[item][0] for item in variablesAtGlobalScopeSelected])
	PRINT ("variableSelectedIndices =",variableSelectedIndices)
	PRINT ("variableSelectedIndices =",[variableDeclarations[item][0] for item in variableSelectedIndices])
	PRINT ("\n"*3,"==="*50,"\ncoloredVarsIdOffsetSize <start (inclusive), end (not inclusive)> \n","=="*50 )
	for item in coloredVarsIdOffsetSize:
		PRINT("<",item[1],"(",HEX(item[1]),"),",item[1]+item[2],"(",HEX(item[1]+item[2]),")> (length", item[2],") for",variableDeclarations[item[0]][0],)
	PRINT ("\n"*3,"=="*50,"\nunraveled\n","=="*50 )
	printUnraveled(unraveled)
	PRINT ("\n"*3,"=="*50,"\n END Dumping data for debug\n","=="*50,"\n"*3)

	if MUST:
		PRINT_DEBUG_MSG = PRINT_DEBUG_MSG_backed_up


def checkIfDataFileIsValidAndGetItsLength(dataFileNameInput):
	global dataFileName, dataFileSizeInBytes, inputIsHexChar
	
	if (IN_DEMO and checkIfIntegral(dataFileNameInput)) or (dataFileNameInput and os.path.exists(dataFileNameInput)):
	
		dataFileName = dataFileNameInput
	
		inputIsHexChar = False
		# Check if it is binary file, or text version of a hex file
		if inputFileIsHexText():
			inputIsHexChar = True
			PRINT ("WARNING: Input file is Hex text")
			
			dataFileSizeInBytes = len(binaryArray)
		else:
			dataFileSizeInBytes = os.path.getsize(dataFileName)
		return True
	elif dataFileNameInput:
		OUTPUT ("dataFileName = ",dataFileNameInput,"is not valid - exiting!")
		return False

# The other routine, updateDisplayBlock(), reads a fixed-size displayBlock. This, OTOH, reads any-length block from anywhere, and returns that block.
# This is useful when the data to be retrived are outside the BLOCK_SIZE display window. Two cases that are specifically useful are:

def readBytesFromFile(startAddress, numBytesToRead):
	if len(binaryArray)>0:
		blockRead = binaryArray[startAddress: startAddress+numBytesToRead]
	else:
		with open(dataFileName, "rb") as file:
			try:
				file.seek(startAddress, os.SEEK_SET)
				blockRead = file.read(numBytesToRead)	
				PRINT("type(blockRead) =",type(blockRead))	# This is of type "bytes" in Python3 but "str" in Python2
			except ValueError: 
				PRINT ("ValueError on trying to read ",numBytesToRead,"bytes from file offset",startAddress )
				return False
			except:
				PRINT ("Unknown error while trying to read the file - exiting")
				sys.exit()
	PRINT ("type(blockRead) = ",type(blockRead))	# str in Python 2, but bytes in Python 3
	PRINT ("len(blockRead) = ",len(blockRead))
	if len(blockRead) != numBytesToRead:
		warningrMessage = "Warning in readBytesFromFile(): From Offset " + STR(startAddress) + " wanted to read "+ STR(numBytesToRead)+" bytes, but succeeded reading only "+STR(len(blockRead))+" bytes instead!"
		PRINT(warningrMessage)
		if not IN_DEMO:
			warningRoutine(warningrMessage)
		dumpDetailsForDebug()
		#return False
		#sys.exit()
	return blockRead

def findBytesInFile(bytesToFind, lookFromAddress=0):
	PRINT=OUTPUT
	if bytesToFind=="":
		errorMessage = "Error in findBytesInFile(): Need to supply a valid stream of bytes to find"
		errorRoutine(errorMessage)
		return [False, None]
	elif not checkIfIntegral(lookFromAddress) or lookFromAddress <0 or lookFromAddress >= dataFileSizeInBytes:
		errorMessage = "Error in findBytesInFile(): Need to supply a valid lookFromAddress"
		errorRoutine(errorMessage)
		return [False, None]

	numBytesToRead = len(bytesToFind)
	PRINT("type(bytesToFind) = ",type(bytesToFind),", len(bytesToFind) =",numBytesToRead)
	
	if len(binaryArray)>0 and len(binaryArray) != dataFileSizeInBytes:
		EXIT("Coding bug in findBytesInFile(): len(binaryArray) != dataFileSizeInBytes")
	
	foundTheBytes = False
	foundAtAddress = None
	startAddress = lookFromAddress
	if len(binaryArray)>0:
		while True:
			if foundTheBytes or startAddress + numBytesToRead >= dataFileSizeInBytes:
				break
			blockRead = binaryArray[startAddress: startAddress+numBytesToRead]
			if blockRead == bytesToFind:
				foundTheBytes = True
				foundAtAddress = startAddress
			startAddress += 1
	else:
		with open(dataFileName, "rb") as file:
			while True:
				if foundTheBytes or startAddress + numBytesToRead >= dataFileSizeInBytes:
					break
				try:
					PRINT("Attempting to find the bytes from addres",startAddress)
					file.seek(startAddress, os.SEEK_SET)
					blockRead = file.read(numBytesToRead)	
					PRINT("type(blockRead) =",type(blockRead))	# This is of type "bytes" in Python3 but "str" in Python2
					if blockRead == bytesToFind:
						foundTheBytes = True
						foundAtAddress = startAddress
				except ValueError: 
					PRINT ("ValueError on trying to read ",numBytesToRead,"bytes from file offset",startAddress )
					return [False, None]
				except:
					EXIT ("Unknown error while trying to read the file in findBytesInFile() - exiting")
				startAddress += 1
	PRINT ("type(blockRead) = ",type(blockRead))	# str in Python 2, but bytes in Python 3
	PRINT ("len(blockRead) = ",len(blockRead))
	return [True, foundAtAddress]

# Given a initialized variableId, it will lookFromAddress for its initialization value
def findHardcodedDataInFile(partnerId, lookFromAddress):
	if not checkIfIntegral(partnerId) or partnerId not in range(len(variableDeclarations)):
		errorMessage = "Error in findHardcodedDataInFile : illegal partnerId of "+STR(partnerId)
		errorRoutine(errorMessage)
		return [False, None]
	elif not variableDeclarations[partnerId][4]["isInitialized"]:
		errorMessage = "Error in findHardcodedDataInFile : supplied partnerId of "+STR(partnerId)+" is NOT an initialized variable"
		errorRoutine(errorMessage)
		return [False, None]

	# We can look for the initialization value only when we know its datatype, value etc. very precisely. If it is a dynamic variable, too bad
	initializationValue = variableDeclarations[partnerId][4]["initializationValue"]
	if isinstance(initializationValue, list) and len(initializationValue)==1 and checkIfNumber(initializationValue[0]):
		PRINT("The partnerId of",partnerId,"is initialized to a constant value of",initializationValue[0])
		decimalValue = initializationValue[0]
		littleEndianOrBigEndian = DEFAULT_ENDIANNESS
		datatype = variableDeclarations[partnerId][4]["datatype"]
		containerSizeBits = primitiveDatatypeLength[dataype]*BITS_IN_BYTE
		signedOrUnsigned = variableDeclarations[partnerId][4]["signedOrUnsigned"]
		if "offsetWithinStruct" in getDictKeyList(variableDeclarations[partnerId][4]):
			offsetWithinStruct = variableDeclarations[partnerId][4]["offsetWithinStruct"]
			if not checkIfIntegral(bitOffsetWithinStruct):
				return [True, None]
		else:
			return [True, None]
			
		if variableDeclarations[partnerId][4]["isBitField"]:
			bitFieldWidth = variableDeclarations[partnerId][4]["bitFieldWidth"]
			if not checkIfIntegral(bitFieldWidth):
				return [True, None]
			else:
				bitFieldSize = bitFieldWidth
			if "bitOffsetWithinStruct" in getDictKeyList(variableDeclarations[partnerId][4]):
				bitOffsetWithinStruct = variableDeclarations[partnerId][4]["bitOffsetWithinStruct"]
				if not checkIfIntegral(bitOffsetWithinStruct):
					return [True, None]
				else:
					bitStartPosition = bitOffsetWithinStruct%BITS_IN_BYTE
					offsetWithinStruct += integerDivision(bitOffsetWithinStruct, BITS_IN_BYTE)
					mask = ((1<<bitFieldSize)-1)<<(containerSizeBits-bitStartPosition-bitFieldSize)
			else:
				return [True, None]
		else:	# Not a bitfield
			bitFieldSize = 0
			bitStartPosition = 0
			mask = (1<<containerSizeBits)-1
	else:
		return [False, None]
		
	PRINT("Let's try to find some value in the file")
#	decimalValue = -1.4748612360084967e20
#	encodeValueResult = encodeValue(decimalValue, LITTLE_ENDIAN, "float", "signed", 0, 0)
	encodeValueResult = encodeValue(decimalValue, littleEndianOrBigEndian, datatype, signedOrUnsigned, bitFieldSize, bitStartPosition)
	if encodeValueResult[0]==True:
		encodedBytes=encodeValueResult[1]
		hexString = "0x"
		for encodedByte in encodedBytes:
			hexString += hex(ORD(encodedByte))
		PRINT("The encoded byte(s) for", decimalValue,"is",hexString)
		findBytesInFileResult = findBytesInFile(encodedBytes, lookFromAddress, mask)
		if findBytesInFileResult[0]==True:
			foundAtAddress = findBytesInFileResult[1]
			PRINT("Value of",decimalValue,"found at offset",foundAtAddress)
		else:
			PRINT("Offset not found")
	PRINT("Exiting displayAndColorDataWindows()\n")
		
'''
runtimeStatementLocationsInGlobalScope = [] # These are the runtime statements that are OUTSIDE any struct definition. 
											#Every row = [line#, globalTokenNumberStart, globalTokenNumberEnd, [runtime token list] ] 
variableIdsInGlobalScope = []	# These are the variables that are at the global scope, depending on the user selection
globalScopedBuddies = []	# The list of sets of variableId of global scoped variables that must be selected together (if user selects any of them, select ALL of them).
							# This mostly happens because of using #RUNTIME statements. It goes in sync with globalScopedRuntimeBlocks[].
globalScopedRuntimeBlocks = [] # Each entry in a <start line#, end line#> of independent #RUNTIME blocks in runtimeStatementLocationsInGlobalScope. It goes in sync with globalScopedBuddies.
							# So, the first entry will correspond to the first #RUNTIME block, which will enclose the global-scoped variables in first entry of globalScopedBuddies
allPossibleQualifiedNames = [] # These are all the possible fully qualified names. For example, suppose we have a struct S{int i; float f;} S1, S2[2]; 
                               # Then these are all the possible names: S1, S1.i, S1.f, S2[0], S2[0].i, S2[0].f, S2[1], S2[1].i, and S2[1].f. 
globalScopesSelected = []	# These are the variables that are at the global scope, depending on the user selection and the MAP_TYPEDEFS_TOO
variableSelectedIndices = [] # These are the indices of variables that have been selected after the user presses the "Map" button
variablesAtGlobalScopeSelected = [] # These are the variables that are at the global scope, AND are the top-level parents of variables that have been selected by the user

'''


##################################################################################################################################################################
# This routine does three things for an input selectedVariables: 1) Populate the unraveled, 2) Calculate the coloredVarsIdOffsetSize, and 3) Read the dataBlock
##################################################################################################################################################################
def populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize():
#	PRINT=OUTPUT
	global coloredVarsIdOffsetSize, coloredDataIdOffsetSize, totalBytesToReadFromDataFile, dataBlock, unraveled, executionStateStack #, allPossibleQualifiedNames
	initResult = None
	selectedVariablesList = variablesAtGlobalScopeSelected
	# First, reset the coloredVarsIdOffsetSize[], dataBlock[], and unraveled[]
	coloredVarsIdOffsetSize = []
	coloredDataIdOffsetSize = []
	totalBytesToReadFromDataFile = 0
	firstUnmappedOffset = dataLocationOffset
	unraveled = []
#	allPossibleQualifiedNames = []
	
	executionStage = "Interpret" if lastActionWasInterpret else "Map" if lastActionWasMap  else "Undefined Execution Stage"

	if executionStage != "Map":
		errorMessage = "ERROR in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize(): executionStage ("+executionStage+") != \"Map\""
		errorRoutine(errorMessage)
		return False
	

	#    !!!! 	IMPORTANT	!!!! 	IMPORTANT	!!!! 	IMPORTANT	!!!! 	
	
	# ABSOLUTELY DO NOT DELETE THE COMMENT BELOW
	# Do NOT do dataBlock = []
	dataBlock = readBytesFromFile(0,0) # The reason we do it like this is because it returns "str" in Python2 and "bytes" in Python3. We want to keep it that way.
	PRINT("type(dataBlock) =",type(dataBlock))

	selectedVariablesNameList = [variableDeclarations[variableId][0] for variableId in selectedVariablesList]
	PRINT("\n\nInside populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize() where selectedVariablesList =",selectedVariablesList,"(",selectedVariablesNameList,")\n\n")
	
	# Each row in runtimeStatementOrGlobalScopedVariableIdOrStructId[] is either [lineNum, variableId], or [lineNum, [Runtime tokens]], or [lineNum, ['struct'/'union', structId]. 
	# This is very similar to the logic in calculateStructureLength(), except two differences:
	# 1) there we did not have the lineNum - just the variableId or the [Runtime tokens].
	# 2) Here we also have the struct/union definitions. This was not there in calculateStructureLength()
	for row in runtimeStatementOrGlobalScopedVariableIdOrStructId:
		if not isinstance(row, list) or len(row) != 2 or not checkIfIntegral(row[0]) or not(checkIfIntegral(row[1]) or (isinstance(row[1],list) and len(row[1])>=2)):
			errorMessage = "ERROR in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize(): runtimeStatementOrGlobalScopedVariableIdOrStructId[] has this invalid row "+STR(row)
			errorRoutine(errorMessage)
			return False
		elif isinstance(row[1],list) and not ( (row[1][0]==preProcessorSymbol and row[1][1] in runtimeDirectives) or (row[1][0] in ('struct','union') and row[1][1] in range(len(structuresAndUnions)) )):
			errorMessage = "ERROR in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize(): runtimeStatementOrGlobalScopedVariableIdOrStructId[] has invalid row "+STR(row)
			errorRoutine(errorMessage)
			return False
		printRow = STR(row) + " --> " + variableDeclarations[row[1]][0] if checkIfIntegral(row[1]) else STR(row)
		PRINT(printRow)

	# Recall that globalScopedRuntimeBlocks and globalScopedBuddies are always in sync. 
	# globalScopedRuntimeBlocks[] contains entry like this: [startLineNum, endLineNum]
	# globalScopedBuddies[] contains entry like this: [list of global-level variableIds occurring within startLineNum, endLineNum]
	if len(globalScopedRuntimeBlocks) != len(globalScopedBuddies):
		OUTPUT("\nlen(globalScopedRuntimeBlocks) =",len(globalScopedRuntimeBlocks),", globalScopedRuntimeBlocks =",globalScopedRuntimeBlocks)
		OUTPUT("\nlen(globalScopedBuddies) =",len(globalScopedBuddies),",globalScopedBuddies =", globalScopedBuddies)
		errorMessage = "Bad coding in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize(): len(globalScopedRuntimeBlocks) = " + STR(len(globalScopedRuntimeBlocks)) + " != len(globalScopedBuddies) = " + STR(len(globalScopedBuddies))
		errorRoutine(errorMessage)
		sys.exit()
		
	# What this logic below does is the following. We have a variablesAtGlobalScopeSelected[], and we need figure out which portion of runtimeStatementOrGlobalScopedVariableIdOrStructId[]
	# exactly corresponds to that. Because you know, there might be multiple runtime blocks at same level, interspersed by other global variables.
	PRINT("variablesAtGlobalScopeSelected[] =",variablesAtGlobalScopeSelected)
	runtimeStatementOrGlobalScopedVariableIdOrStructIdSelected = []
	for variableId in variablesAtGlobalScopeSelected:
		PRINT("Looking for variableId",variableId,"(variable name",variableDeclarations[variableId][0],")")
		if runtimeStatementOrGlobalScopedVariableIdOrStructIdSelected and variableId in [x[1] for x in runtimeStatementOrGlobalScopedVariableIdOrStructIdSelected]:
			PRINT("variableId",variableId,"already added (thanks to buddies)")
		else:
			PRINT("Looking for variableId",variableId,"among runtime statement scope blocks")
			varWithinRuntimeScopeNumber = LARGE_NEGATIVE_NUMBER
			for N in range(len(globalScopedRuntimeBlocks)):
				if variableId in globalScopedBuddies[N]:	# We looking for exactly the N-th entry, since globalScopedBuddies[N] corresponds to globalScopedRuntimeBlocks[N]
					varWithinRuntimeScopeNumber = N
					break
			if varWithinRuntimeScopeNumber == LARGE_NEGATIVE_NUMBER:	# The variableId is not found within any runtime scope
				for x in runtimeStatementOrGlobalScopedVariableIdOrStructId:		# So it might be outside (or in between) two runtime scopes
					if x[1] == variableId:	# Recall that every row in runtimeStatementOrGlobalScopedVariableIdOrStructId[] is [ line#, variableId/[Runtime tokens]/[struct, structId] ]
						runtimeStatementOrGlobalScopedVariableIdOrStructIdSelected.append(x)
						break
			else: 	# The variableId has been found within a runtime scope.
				startLineNum = globalScopedRuntimeBlocks[N][0]
				endLineNum   = globalScopedRuntimeBlocks[N][1]
				startLineNumIndex = LARGE_NEGATIVE_NUMBER
				endLineNumIndex = LARGE_NEGATIVE_NUMBER
				for r in range(len(runtimeStatementOrGlobalScopedVariableIdOrStructId)):
					x = runtimeStatementOrGlobalScopedVariableIdOrStructId[r]
					if x[0] == startLineNum:
						startLineNumIndex = r
					if x[0] == endLineNum:
						endLineNumIndex = r
				if startLineNumIndex == LARGE_NEGATIVE_NUMBER or endLineNumIndex == LARGE_NEGATIVE_NUMBER:	# We should find it
					errorMessage = "Bad coding in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize() regarding figuring out which startLineNumIndex and endLineNumIndex to choose out of runtimeStatementOrGlobalScopedVariableIdOrStructId[]"
					errorRoutine(errorMessage)
					sys.exit()
				else:
					runtimeStatementOrGlobalScopedVariableIdOrStructIdSelected.extend(runtimeStatementOrGlobalScopedVariableIdOrStructId[startLineNumIndex:endLineNumIndex+1])
	# Sanity check
	variablesAtGlobalScopeSelectedRecreated = []
	for x in runtimeStatementOrGlobalScopedVariableIdOrStructIdSelected:
		if not isinstance(x,list) or len(x) !=2 or not checkIfIntegral(x[0]) or not (checkIfIntegral(x[1]) or isinstance(x[1],list)):
			errorMessage = "Bad coding in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize(), inside runtimeStatementOrGlobalScopedVariableIdOrStructIdSelected[], row "+STR(X)+" is not proper"
			errorRoutine(errorMessage)
			sys.exit()
		elif checkIfIntegral(x[1]):
			variablesAtGlobalScopeSelectedRecreated.append(x[1])
	if variablesAtGlobalScopeSelectedRecreated != variablesAtGlobalScopeSelected:
		errorMessage = "Bad coding in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize(), variablesAtGlobalScopeSelectedRecreated != variablesAtGlobalScopeSelected"
		errorRoutine(errorMessage)
		OUTPUT("variablesAtGlobalScopeSelectedRecreated =", variablesAtGlobalScopeSelectedRecreated) 
		OUTPUT("variablesAtGlobalScopeSelected =", variablesAtGlobalScopeSelected)
		sys.exit()

	PRINT("\n\nruntimeStatementOrGlobalScopedVariableIdSelected (each row is [line#, variableId]) =")
	for row in runtimeStatementOrGlobalScopedVariableIdOrStructIdSelected:
		PRINT(row)
		
	# TO-DO: We will rewrite this later. Right now assume everything is chosen
	statementOrVarIdOrStructId 	= [x[1] 	  			for x in runtimeStatementOrGlobalScopedVariableIdOrStructIdSelected]
	statementOrVarIdStatus  	= ["execute"  			for x in runtimeStatementOrGlobalScopedVariableIdOrStructIdSelected]
	runtimeLines 				= [list2plaintext(x[1]) for x in runtimeStatementOrGlobalScopedVariableIdOrStructIdSelected]
	
	# statementOrVarIdOrStructId will be either 1) A global variableId, or 2) a list ["struct"/"union", structId], or 3) a #RUNTIME statement
	# So, if it is integral, it is global variableId. If it a 2-member-list starting with "struct"/"union", then it is a structId. Else, it is a runtime statement.
	PRINT("structuresAndUnions =")
	for row in structuresAndUnions:
		PRINT(row)
	
	n = 0
	while True:
		if n >= len(statementOrVarIdOrStructId):
			break
	
		PRINT("\n\nInside populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize(), currently dealing with statementOrVarIdOrStructId[n=",n,"] = <",statementOrVarIdOrStructId[n],">, where statementOrVarIdStatus[",n,"] =",statementOrVarIdStatus[n])

		# If it says not to execute a statement, just ignore that statement
		if statementOrVarIdStatus[n] != 'execute':	
			PRINT("Skipping it because of its statementOrVarIdStatus[",n,"] =",statementOrVarIdStatus[n],"!")
			n = n+1
			continue
		# Control come here means statementOrVarIdStatus[n] is 'execute'. Now let's examine what kind of a statement it is
		# If it is not a #RUNTIME statement, no need to evaluate it (obviously)
		elif checkIfIntegral(statementOrVarIdOrStructId[n]): # An integreal value means it is the variableId of a globally-scoped varible, not a #RUNTIME statement
			PRINT("Statement #",n,"(",statementOrVarIdOrStructId[n],") is a variable declaration and is NOT a Runtime statement")
		elif isinstance(statementOrVarIdOrStructId[n],list) and len(statementOrVarIdOrStructId[n])==2 and statementOrVarIdOrStructId[n][0] in ("struct", "union"):
			structId = statementOrVarIdOrStructId[n][1]
			if structId >= len(structuresAndUnions):
				OUTPUT("Coding error in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize() - illegal value of structId =",structId)
				sys.exit()
			structName = structuresAndUnions[structId]["name"]
			if structId not in suDict[structName]:
				OUTPUT("Coding error in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize() - for structName =",structName,"structId =",structId,"does not feature in suDict[structName]=",STR(suDict[structName]))
				sys.exit()
			if structId == suDict[structName][-1]:
				PRINT("For structName =",structName,"structId =",structId," is already at the top of the currentList =",STR(suDict[structName]))
			else:
				currentList = suDict[structName]
				currentPositionalIndex = currentList.index(structId)
				newList = currentList[:currentPositionalIndex]+currentList[currentPositionalIndex+1:]+[structId]
				suDict[structName] = newList
				PRINT("For structName =",structName,"structId =",structId,",currentList =",STR(currentList),"is replaced with newList =",STR(newList))
			n = n+1
			continue
		# If it is a #RUNTIME statement, evaluate it if we are in the Map stage (because the data will now be available)
		elif not checkIfIntegral(statementOrVarIdOrStructId[n]):
			PRINT("statementOrVarIdOrStructId[",n,"] =",statementOrVarIdOrStructId[n])
			if (not isinstance(statementOrVarIdOrStructId[n],list)) or (not statementOrVarIdOrStructId[n][0] == preProcessorSymbol) or (statementOrVarIdOrStructId[n][1] not in runtimeDirectives) or (len(statementOrVarIdOrStructId[n])<=1):
				errorMessage = "ERROR in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize(): Illegal #RUNTIME statement"
				errorRoutine(errorMessage)
				return False

			# First, find the scope of any if condition
			if statementOrVarIdOrStructId[n][1] in ('if', 'loop'):	# Starting of a if-elif-else-endif block
				# First figure out the which all source code statements are impacted by this if statement.
				# There might be multiple code blocks between the if-elif-elif-else-endif statements, but only one of them would succeed.
				PRINT("From populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize(), calling checkPreprocessingDirectivesInterleaving(runtimeLines[n:],True)")
				checkPreprocessingDirectivesInterleavingResult = checkPreprocessingDirectivesInterleaving(runtimeLines[n:],True)
				if checkPreprocessingDirectivesInterleavingResult == False:
					errorMessage = "ERROR in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize() after calling checkPreprocessingDirectivesInterleaving() from line %d"%n
					errorRoutine(errorMessage)
					return False
				else:
					scope = checkPreprocessingDirectivesInterleavingResult

				# Recall that the returned scope is nothing but a list like the one below, where all the linenumbers are relative to the first if statement
				# [ [0,"#if"], [8,"#elif"], [9,"#elif"], [15, "#endif"],[20, "#loop"],[25, "#endloop"] ]


				PRINT("For line #",n," the scope for the if-elif-else-endif is",scope)
				# Recall that the the line numbers returned from checkPreprocessingDirectivesInterleaving() are relative, i.e. they start from 0.
				# So, you need to add the current line number to get any absolute line number
				k = 0

				# Out of the many if-elif-elif-else-endif code blocks, only one will succeed. And once that succeeds, the rest must be deleted irrespecive of
				# whether corresponding #elif condition evaluates to True or not.
				ifConditionTruthValueAlreadyFound = False
				
				while k<len(scope):	# Recall that the scope has the if-elif-else-endif statements only, not the actual code blocks coming under those if-elif-else-endif statements 
					# We following this logic.
					# If the 
					targetLineNumber = scope[k][0]+n	# This is the actual line number in statementOrVarIdOrStructId
					PRINT("Looking at line #",targetLineNumber,"(",statementOrVarIdOrStructId[targetLineNumber],")")

					# Our main goal is to find if a code block should be skipped or not. It can be don
					# If we already had one of the if-elif-elif-else-endif conditions
					if ifConditionTruthValueAlreadyFound == False:
						skipCodeBlock = False	# We first default it to False, but will set it to True if the condition evaluates to be true
						targetLineTokenList = statementOrVarIdOrStructId[targetLineNumber]
						
						# First do a little bit of sanity checking that these are valid #RUNTIME statements
						if (not isinstance(targetLineTokenList,list)) or (len(targetLineTokenList)<2) or (not targetLineTokenList[0] == preProcessorSymbol) or (targetLineTokenList[1] not in runtimeDirectives):
							errorMessage = "ERROR in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize(): Illegal #RUNTIME statement "+STR(targetLineTokenList)
							errorRoutine(errorMessage)
							return False
						elif targetLineTokenList[1] in ('if','ifdef','ifndef', 'elif') and len(targetLineTokenList)<3:
							errorMessage = "ERROR in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize() in line #"+targetLineNumber+": a "+ STR(targetLineTokenList[0:2]) +" statement must not be empty"
							errorRoutine(errorMessage)
							return False
						elif targetLineTokenList[1] in ('else','endif') and len(targetLineTokenList)>2:
							errorMessage = "ERROR in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize() in line #"+targetLineNumber+": a "+ STR(targetLineTokenList[0:2]) +" statement must not supply more than one argument"
							errorRoutine(errorMessage)
							return False
						
						# Calculate the if condition result (True or False). By here we know that all ifdef etc. things have proper arguments
						ifConditionEvaluationResult = False	# The default value

						if targetLineTokenList[1] in ('if','elif'):
							
							parseArithmeticExpressionResult = parseArithmeticExpression(targetLineTokenList[2:])
							if parseArithmeticExpressionResult == False:
								errorMessage = "ERROR in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize() parsing <%s>"%tokenizeLinesResult
								errorRoutine(errorMessage)
								return False
								
							evaluateArithmeticExpressionResult = evaluateArithmeticExpression(parseArithmeticExpressionResult)
							PRINT("evaluateArithmeticExpression(",STR(parseArithmeticExpressionResult),") evaluates to", evaluateArithmeticExpressionResult)
							if evaluateArithmeticExpressionResult[0] == False:
								errorMessage = "ERROR in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize() evaluating <%s> during %s stage"%(evaluateArithmeticExpressionResult,executionStage)
								errorRoutine(errorMessage)
								return False
							elif evaluateArithmeticExpressionResult[1] == 1:	# Truth value in C is 1, not True of Python
								ifConditionEvaluationResult = True
								PRINT("The if condition in line#",targetLineNumber," = <",statementOrVarIdOrStructId[targetLineNumber],"> succeeded")
								ifConditionTruthValueAlreadyFound = True
							elif evaluateArithmeticExpressionResult[1] == 0:	# False value in C is 0, not False of Python
								PRINT("The if condition in line#",targetLineNumber," = <",statementOrVarIdOrStructId[targetLineNumber],"> failed")
							elif evaluateArithmeticExpressionResult[1] == LOGICAL_TEST_RESULT_INDETERMINATE: 
								errorMessage = "ERROR in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize(): Cannot evaluate <%s> during %s stage - the evaluation result is"%(executionStage, STR(evaluateArithmeticExpressionResult))
								errorRoutine(errorMessage)
								return False
							else:
								errorMessage = "ERROR in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize() during %s stage - the evaluation result <%s> is neither 1 (True) nor 0 (False)"%(executionStage, STR(evaluateArithmeticExpressionResult))
								errorRoutine(errorMessage)
								return False
								
						elif targetLineTokenList[1] == 'else': 	# If you are falling on an #else, it is by defintion true
							ifConditionEvaluationResult = True
							PRINT("The '"+preProcessorSymbol+"else' succeeded")
								

						if ifConditionEvaluationResult == True:
							ifConditionTruthValueAlreadyFound = True
							PRINT("The overall if condition in line#",targetLineNumber," = <",statementOrVarIdOrStructId[targetLineNumber],"> succeeded")
						elif ifConditionEvaluationResult == False:
							PRINT("The overall if condition in line#",targetLineNumber," = <",statementOrVarIdOrStructId[targetLineNumber],"> failed")
							skipCodeBlock = True
						else:
							OUTPUT("Bad coding in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize() regarding ifConditionEvaluationResult checking - exiting!")
							sys.exit()
							
					elif ifConditionTruthValueAlreadyFound:
						skipCodeBlock = True
					else:
						OUTPUT("Bad coding regarding ifConditionTruthValueAlreadyFound checking in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize() - exiting!")
						sys.exit()
						
					# Now that we have calculated the if condition result (True or False), skip the if statements and corresponding non-executing code blocks
					if skipCodeBlock == False or k == len(scope)-1:
						numComponentsToSkip = 1
					else:
						numComponentsToSkip = scope[k+1][0] - scope[k][0]
						
					PRINT ("Going to skip line",scope[k][0]+n,"through line",scope[k][0]+n+numComponentsToSkip-1," - a total of",numComponentsToSkip,"lines" )
					d = 0
					while d < numComponentsToSkip:
						PRINT("Going to skip the line #",scope[k][0]+n+d, statementOrVarIdOrStructId[scope[k][0]+n+d])
						statementOrVarIdStatus[scope[k][0]+n+d] = "skip"
						d += 1
					k += 1
					
					PRINT("\nCurrent status of statementOrVarIdOrStructId is")
					for j in range(len(statementOrVarIdStatus)):
						PRINT(statementOrVarIdStatus[j]+" "*(len("execute")-len(statementOrVarIdStatus[j]))+"\t"*3+STR(statementOrVarIdOrStructId[j]))

				
			# For #RUNTIME statements, don't do anything else. 
			n = n+1
			continue	# Corresponding to the loop statement: for n in range(len(statementOrVarIdOrStructId)):
			
		else:	# Should never happen
			OUTPUT("Bad coding in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize() - exiting!!")
			sys.exit()
			

		# From this point, we are not dealing with #RUNTIME statements	
		variableId = statementOrVarIdOrStructId[n]
		if variableDeclarations[variableId][4]["isDynamic"]:
			variableDeclarationsEntry = deepCopy(variableDeclarations[variableId])
		else:	# Regular
			variableDeclarationsEntry = 		 variableDeclarations[variableId]

		speculativeArrayDimensions = []
		
		PRINT("\n\nInside populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize(), for n =",n, ", variableId =",variableId,", statementOrVarIdOrStructId =",statementOrVarIdOrStructId)
		
		# During Map, we take two different actions at the beginning and the ending of this loop for actual member variables.
		#
		# At the beginning, we find out if this variable is the ancestor of either a blank-dimension array (varB).
		# At the end, we find out if this variable is the ancestor of the initialization counterpart (varI) of the blank-dimension array (varB).
		#
		# Actions at the beginning of the loop:
		#
		# If if this variable (varA) is the ancestor of a blank-dimension array variable (varB), do the following:
		#   - Look at the global speculative execution status of the blank-dimension-array variable (call it varA).
		#     - If there is no varA entry on top of the stack, then this is the first time we are dealing with it. In that case, push an entry there with all the information
		#       like which variableId, what speculative value (starting from 0 etc.). Also, save the execution state onto the Global execution state stack.
		#	  - If there is an varA entry on top of the stack, then this is NOT the first time we are dealing with it. In that case, increment the last speculative value there.
		#		Also, restore all the execution state from the Global execution state stack.
		#   
		#
		# Actions at the end of the loop:
		#
		# If if this variable (varA) is the ancestor of the initialization partner (varI) of a blank-dimension array variable (varB), do the following:
		#   - Look at the global speculative execution status of the blank-dimension-array variable (call it varA).
		#	  - If there is an varA entry on top of the stack, then we look at the status of the Initialization. 
		#		 	- It it was a success, then pop the entry and from the Global execution stack and life goes on.
		#			- If it was a failure, then do NOT pop the stack. Choose the next the ancestor sibling of this varR as the next loop index n.
		# 

		if blankArraysAndTerminationInfo:		# No point calling it if the blankArraysAndTerminationInfo{} has no records
			# Find out if the current struct member is the ancestor of a blank dimensional array
			isAncestorOfBlankArray = False
			for blankDimensionArrayVariableId in getDictKeyList(blankArraysAndTerminationInfo):
				if blankDimensionArrayVariableId != blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["blankDimensionArrayVariableId"]:
					EXIT("Bad coding - blankDimensionArrayVariableId != blankArraysAndTerminationInfo[blankDimensionArrayVariableId][\"blankDimensionArrayVariableId\"]")
				partnerVariableId = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["partnerVariableId"]
				ancestorOfBlankDimensionArrayVariableId = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["siblingAncestors"][0]
				ancestorOfInitializationPartner = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["siblingAncestors"][1]
				if variableId == ancestorOfBlankDimensionArrayVariableId:
					isAncestorOfBlankArray = True
					identifierRecord = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]
					PRINT("The variableName",variableDeclarations[variableId][0],"(id",variableId,") is the ancestor of a blank array variable", variableDeclarations[blankDimensionArrayVariableId][0],"(id",blankDimensionArrayVariableId,") - its sibling ancestor has the variable id (",ancestorOfInitializationPartner,") that is the ancestor of the initialization partner", variableDeclarations[partnerVariableId][0],"(id",partnerVariableId,")")
					break
			if isAncestorOfBlankArray:
				PRINT("The current executionStateStack[] has the followin identifierRecord and speculativeValue: ")
				for row in executionStateStack:
					PRINT("identifierRecord =",row["identifierRecord"],", speculativeValue =",row["speculativeValue"])
#				if blankArrayDimensionStack:
				if executionStateStack:
#					PRINT("The top of the stack is",blankArrayDimensionStack[-1])
					PRINT("The top of the stack is",STR(executionStateStack[-1]))
#					if blankArrayDimensionStack[-1]["blankDimensionArrayVariableId"] == blankDimensionArrayVariableId:
					if executionStateStack[-1]["callerFunctionName"] != "populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize()":
						EXIT("Coding bug in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize(): top of executionStateStack[] contains entry from "+executionStateStack[-1]["callerFunctionName"])
					if executionStateStack[-1]["identifierRecord"]["blankDimensionArrayVariableId"] == blankDimensionArrayVariableId:
#						speculativeValue = blankArrayDimensionStack[-1]["speculativeValue"]
						speculativeValue = executionStateStack[-1]["speculativeValue"]
#						PRINT("The top of the blankArrayDimensionStack now has the speculative array dimension of",speculativeValue,"for the blank array variable",variableDeclarations[blankDimensionArrayVariableId][0])
						PRINT("The top of the executionStateStack now has the speculative array dimension of",speculativeValue,"for the blank array variable",variableDeclarations[blankDimensionArrayVariableId][0])
#						blankArrayDimensionStack[-1]["speculativeValue"] += 1
						speculativeValue += 1
						PRINT("\n\n","///"*50,"\n","\t"*8, "speculativeValue =",speculativeValue,"\n","\\\\\\"*50,"\n\n")
						executionStateStack[-1]["speculativeValue"] = speculativeValue
						
						# Restore the Global variables, and get a copy of what the local symbol table during the previous run
						localVariables = restoreGlobalsAndReturnLocals()
						
						# Restore the local variables one by one. Since Python does not have pointers, I do not know any elegant way to overwrite local variables

						if "firstUnmappedOffset" in getDictKeyList(locals()) and "firstUnmappedOffset" in getDictKeyList(localVariables) and firstUnmappedOffset != localVariables["firstUnmappedOffset"]:
							PRINT("firstUnmappedOffset has changed - restoring it")
							firstUnmappedOffset = deepCopy(localVariables["firstUnmappedOffset"])

						if "executionStage" in getDictKeyList(locals()) and "executionStage" in getDictKeyList(localVariables) and executionStage != localVariables["executionStage"]:
							PRINT("executionStage has changed - restoring it")
							executionStage = deepCopy(localVariables["executionStage"])

						if "selectedVariablesNameList" in getDictKeyList(locals()) and "selectedVariablesNameList" in getDictKeyList(localVariables) and selectedVariablesNameList != localVariables["selectedVariablesNameList"]:
							PRINT("selectedVariablesNameList has changed - restoring it")
							selectedVariablesNameList = deepCopy(localVariables["selectedVariablesNameList"])

						if "row" in getDictKeyList(locals()) and "row" in getDictKeyList(localVariables) and row != localVariables["row"]:
							PRINT("row has changed - restoring it")
							row = deepCopy(localVariables["row"])

						if "printRow" in getDictKeyList(locals()) and "printRow" in getDictKeyList(localVariables) and printRow != localVariables["printRow"]:
							PRINT("printRow has changed - restoring it")
							printRow = deepCopy(localVariables["printRow"])

						if "runtimeStatementOrGlobalScopedVariableIdOrStructIdSelected" in getDictKeyList(locals()) and "runtimeStatementOrGlobalScopedVariableIdOrStructIdSelected" in getDictKeyList(localVariables) and runtimeStatementOrGlobalScopedVariableIdOrStructIdSelected != localVariables["runtimeStatementOrGlobalScopedVariableIdOrStructIdSelected"]:
							PRINT("runtimeStatementOrGlobalScopedVariableIdOrStructIdSelected has changed - restoring it")
							runtimeStatementOrGlobalScopedVariableIdOrStructIdSelected = deepCopy(localVariables["runtimeStatementOrGlobalScopedVariableIdOrStructIdSelected"])

						if "variableId" in getDictKeyList(locals()) and "variableId" in getDictKeyList(localVariables) and variableId != localVariables["variableId"]:
							PRINT("variableId has changed - restoring it")
							variableId = deepCopy(localVariables["variableId"])

						if "varWithinRuntimeScopeNumber" in getDictKeyList(locals()) and "varWithinRuntimeScopeNumber" in getDictKeyList(localVariables) and varWithinRuntimeScopeNumber != localVariables["varWithinRuntimeScopeNumber"]:
							PRINT("varWithinRuntimeScopeNumber has changed - restoring it")
							varWithinRuntimeScopeNumber = deepCopy(localVariables["varWithinRuntimeScopeNumber"])

						if "N" in getDictKeyList(locals()) and "N" in getDictKeyList(localVariables) and N != localVariables["N"]:
							PRINT("N has changed - restoring it")
							N = deepCopy(localVariables["N"])

						if "x" in getDictKeyList(locals()) and "x" in getDictKeyList(localVariables) and x != localVariables["x"]:
							PRINT("x has changed - restoring it")
							x = deepCopy(localVariables["x"])

						if "startLineNum" in getDictKeyList(locals()) and "startLineNum" in getDictKeyList(localVariables) and startLineNum != localVariables["startLineNum"]:
							PRINT("startLineNum has changed - restoring it")
							startLineNum = deepCopy(localVariables["startLineNum"])

						if "endLineNum" in getDictKeyList(locals()) and "endLineNum" in getDictKeyList(localVariables) and endLineNum != localVariables["endLineNum"]:
							PRINT("endLineNum has changed - restoring it")
							endLineNum = deepCopy(localVariables["endLineNum"])

						if "startLineNumIndex" in getDictKeyList(locals()) and "startLineNumIndex" in getDictKeyList(localVariables) and startLineNumIndex != localVariables["startLineNumIndex"]:
							PRINT("startLineNumIndex has changed - restoring it")
							startLineNumIndex = deepCopy(localVariables["startLineNumIndex"])

						if "endLineNumIndex" in getDictKeyList(locals()) and "endLineNumIndex" in getDictKeyList(localVariables) and endLineNumIndex != localVariables["endLineNumIndex"]:
							PRINT("endLineNumIndex has changed - restoring it")
							endLineNumIndex = deepCopy(localVariables["endLineNumIndex"])

						if "r" in getDictKeyList(locals()) and "r" in getDictKeyList(localVariables) and r != localVariables["r"]:
							PRINT("r has changed - restoring it")
							r = deepCopy(localVariables["r"])

						if "variablesAtGlobalScopeSelectedRecreated" in getDictKeyList(locals()) and "variablesAtGlobalScopeSelectedRecreated" in getDictKeyList(localVariables) and variablesAtGlobalScopeSelectedRecreated != localVariables["variablesAtGlobalScopeSelectedRecreated"]:
							PRINT("variablesAtGlobalScopeSelectedRecreated has changed - restoring it")
							variablesAtGlobalScopeSelectedRecreated = deepCopy(localVariables["variablesAtGlobalScopeSelectedRecreated"])

						if "statementOrVarIdOrStructId" in getDictKeyList(locals()) and "statementOrVarIdOrStructId" in getDictKeyList(localVariables) and statementOrVarIdOrStructId != localVariables["statementOrVarIdOrStructId"]:
							PRINT("statementOrVarIdOrStructId has changed - restoring it")
							statementOrVarIdOrStructId = deepCopy(localVariables["statementOrVarIdOrStructId"])

						if "statementOrVarIdStatus" in getDictKeyList(locals()) and "statementOrVarIdStatus" in getDictKeyList(localVariables) and statementOrVarIdStatus != localVariables["statementOrVarIdStatus"]:
							PRINT("statementOrVarIdStatus has changed - restoring it")
							statementOrVarIdStatus = deepCopy(localVariables["statementOrVarIdStatus"])

						if "runtimeLines" in getDictKeyList(locals()) and "runtimeLines" in getDictKeyList(localVariables) and runtimeLines != localVariables["runtimeLines"]:
							PRINT("runtimeLines has changed - restoring it")
							runtimeLines = deepCopy(localVariables["runtimeLines"])

						if "structId" in getDictKeyList(locals()) and "structId" in getDictKeyList(localVariables) and structId != localVariables["structId"]:
							PRINT("structId has changed - restoring it")
							structId = deepCopy(localVariables["structId"])

						if "currentList" in getDictKeyList(locals()) and "currentList" in getDictKeyList(localVariables) and currentList != localVariables["currentList"]:
							PRINT("currentList has changed - restoring it")
							currentList = deepCopy(localVariables["currentList"])

						if "currentPositionalIndex" in getDictKeyList(locals()) and "currentPositionalIndex" in getDictKeyList(localVariables) and currentPositionalIndex != localVariables["currentPositionalIndex"]:
							PRINT("currentPositionalIndex has changed - restoring it")
							currentPositionalIndex = deepCopy(localVariables["currentPositionalIndex"])

						if "newList" in getDictKeyList(locals()) and "newList" in getDictKeyList(localVariables) and newList != localVariables["newList"]:
							PRINT("newList has changed - restoring it")
							newList = deepCopy(localVariables["newList"])

						if "checkRuntimeDirectivesInterleavingResult" in getDictKeyList(locals()) and "checkRuntimeDirectivesInterleavingResult" in getDictKeyList(localVariables) and checkRuntimeDirectivesInterleavingResult != localVariables["checkRuntimeDirectivesInterleavingResult"]:
							PRINT("checkRuntimeDirectivesInterleavingResult has changed - restoring it")
							checkRuntimeDirectivesInterleavingResult = deepCopy(localVariables["checkRuntimeDirectivesInterleavingResult"])

						if "scope" in getDictKeyList(locals()) and "scope" in getDictKeyList(localVariables) and scope != localVariables["scope"]:
							PRINT("scope has changed - restoring it")
							scope = deepCopy(localVariables["scope"])

						if "k" in getDictKeyList(locals()) and "k" in getDictKeyList(localVariables) and k != localVariables["k"]:
							PRINT("k has changed - restoring it")
							k = deepCopy(localVariables["k"])

						if "ifConditionTruthValueAlreadyFound" in getDictKeyList(locals()) and "ifConditionTruthValueAlreadyFound" in getDictKeyList(localVariables) and ifConditionTruthValueAlreadyFound != localVariables["ifConditionTruthValueAlreadyFound"]:
							PRINT("ifConditionTruthValueAlreadyFound has changed - restoring it")
							ifConditionTruthValueAlreadyFound = deepCopy(localVariables["ifConditionTruthValueAlreadyFound"])

						if "targetLineNumber" in getDictKeyList(locals()) and "targetLineNumber" in getDictKeyList(localVariables) and targetLineNumber != localVariables["targetLineNumber"]:
							PRINT("targetLineNumber has changed - restoring it")
							targetLineNumber = deepCopy(localVariables["targetLineNumber"])

						if "skipCodeBlock" in getDictKeyList(locals()) and "skipCodeBlock" in getDictKeyList(localVariables) and skipCodeBlock != localVariables["skipCodeBlock"]:
							PRINT("skipCodeBlock has changed - restoring it")
							skipCodeBlock = deepCopy(localVariables["skipCodeBlock"])

						if "targetLineTokenList" in getDictKeyList(locals()) and "targetLineTokenList" in getDictKeyList(localVariables) and targetLineTokenList != localVariables["targetLineTokenList"]:
							PRINT("targetLineTokenList has changed - restoring it")
							targetLineTokenList = deepCopy(localVariables["targetLineTokenList"])

						if "ifConditionEvaluationResult" in getDictKeyList(locals()) and "ifConditionEvaluationResult" in getDictKeyList(localVariables) and ifConditionEvaluationResult != localVariables["ifConditionEvaluationResult"]:
							PRINT("ifConditionEvaluationResult has changed - restoring it")
							ifConditionEvaluationResult = deepCopy(localVariables["ifConditionEvaluationResult"])

						if "parseArithmeticExpressionResult" in getDictKeyList(locals()) and "parseArithmeticExpressionResult" in getDictKeyList(localVariables) and parseArithmeticExpressionResult != localVariables["parseArithmeticExpressionResult"]:
							PRINT("parseArithmeticExpressionResult has changed - restoring it")
							parseArithmeticExpressionResult = deepCopy(localVariables["parseArithmeticExpressionResult"])

						if "evaluateArithmeticExpressionResult" in getDictKeyList(locals()) and "evaluateArithmeticExpressionResult" in getDictKeyList(localVariables) and evaluateArithmeticExpressionResult != localVariables["evaluateArithmeticExpressionResult"]:
							PRINT("evaluateArithmeticExpressionResult has changed - restoring it")
							evaluateArithmeticExpressionResult = deepCopy(localVariables["evaluateArithmeticExpressionResult"])

						if "numComponentsToSkip" in getDictKeyList(locals()) and "numComponentsToSkip" in getDictKeyList(localVariables) and numComponentsToSkip != localVariables["numComponentsToSkip"]:
							PRINT("numComponentsToSkip has changed - restoring it")
							numComponentsToSkip = deepCopy(localVariables["numComponentsToSkip"])

						if "d" in getDictKeyList(locals()) and "d" in getDictKeyList(localVariables) and d != localVariables["d"]:
							PRINT("d has changed - restoring it")
							d = deepCopy(localVariables["d"])

						if "j" in getDictKeyList(locals()) and "j" in getDictKeyList(localVariables) and j != localVariables["j"]:
							PRINT("j has changed - restoring it")
							j = deepCopy(localVariables["j"])

						if "isAncestorOfBlankArray" in getDictKeyList(locals()) and "isAncestorOfBlankArray" in getDictKeyList(localVariables) and isAncestorOfBlankArray != localVariables["isAncestorOfBlankArray"]:
							PRINT("isAncestorOfBlankArray has changed - restoring it")
							isAncestorOfBlankArray = deepCopy(localVariables["isAncestorOfBlankArray"])

						if "identifierRecord" in getDictKeyList(locals()) and "identifierRecord" in getDictKeyList(localVariables) and identifierRecord != localVariables["identifierRecord"]:
							PRINT("identifierRecord has changed - restoring it")
							identifierRecord = deepCopy(localVariables["identifierRecord"])

						speculativeArrayDimensions = [[speculativeValue]]+variableDeclarations[variableId][4]["arrayDimensions"][1:]
						
					else:
						# The stack is not empty, but the top entry is not what we expect. So, it is the first time; Save the current execution state
#						PRINT("The blankArrayDimensionStack[] is not empty, but the top of the blankArrayDimensionStack now has NO speculative array dimension for the blank array variable",variableDeclarations[blankDimensionArrayVariableId][0])
						PRINT("The executionStateStack[] is not empty, but the top of the executionStateStack now has NO speculative array dimension for the blank array variable",variableDeclarations[blankDimensionArrayVariableId][0])
						speculativeValue = 1
						speculativeArrayDimensions = [[speculativeValue]]+variableDeclarations[variableId][4]["arrayDimensions"][1:]
						PRINT("\n\n","///"*50,"\n","\t"*8, "speculativeValue =",speculativeValue,"\n","\\\\\\"*50,"\n\n")
						saveExecutionState(identifierRecord, speculativeValue, locals())
						executionStateStack[-1]["callerFunctionName"] = "populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize()"
#						executionStateStack.append({{"identifierRecord":identifierRecord,"speculativeValue":speculativeValue}})
				else:		
					# The stack is empty. So, it is the first time; Save the current execution state
#					PRINT("The blankArrayDimensionStack[] is currently empty, so obviously the top of the blankArrayDimensionStack now has NO speculative array dimension for the blank array variable",variableDeclarations[blankDimensionArrayVariableId][0])
					PRINT("The executionStateStack[] is currently empty, so obviously the top of the executionStateStack now has NO speculative array dimension for the blank array variable",variableDeclarations[blankDimensionArrayVariableId][0])
					speculativeValue = 1
					speculativeArrayDimensions = [[speculativeValue]]+variableDeclarations[variableId][4]["arrayDimensions"][1:]
					PRINT("\n\n","///"*50,"\n","\t"*8, "speculativeValue =",speculativeValue,"\n","\\\\\\"*50,"\n\n")
#					saveExecutionState(locals())
					saveExecutionState(identifierRecord, speculativeValue, locals())
					executionStateStack[-1]["callerFunctionName"] = "populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize()"
#					blankArrayDimensionStack.append({"blankDimensionArrayVariableId":variableId,"speculativeValue":speculativeValue})

		variableName = variableDeclarations[variableId][0]
		# Each of the routine expects a list of variableIds, hence we create a list artificially
		selectedVariables = [variableId]
		dataLocationOffsetForCurrentSetOfVariables = firstUnmappedOffset

		PRINT("For selected variableId =",STR(variableId),", variable name =",variableName,"calling addVariableToUnraveled(0,",variableId,'"", dataLocationOffsetForCurrentSetOfVariables =',dataLocationOffsetForCurrentSetOfVariables,", unraveled)")
		PRINT("\nBefore invoking addVariableToUnraveled(0,",variableId,',"", dataLocationOffsetForCurrentSetOfVariables =',dataLocationOffsetForCurrentSetOfVariables,", unraveled), unraveled =")
		printUnraveled(unraveled)
		PRINT("Passing speculativeArrayDimensions =",speculativeArrayDimensions)
		# Add this to unraveled
		addVariableToUnraveledResult = addVariableToUnraveled(0, variableDeclarationsEntry, "", dataLocationOffsetForCurrentSetOfVariables, unraveled, [], False, speculativeArrayDimensions)
		if addVariableToUnraveledResult == False:
			errorMessage = "ERROR in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize(): Error after calling addVariableToUnraveled() with variableId = "+STR(variableId)
			errorRoutine(errorMessage)
			return False
		else:
			unraveled = addVariableToUnraveledResult[0]
			initResult = addVariableToUnraveledResult[1]
		PRINT("After calling addVariableToUnraveled() for",variableName," (variableId =",variableId,", speculativeArrayDimensions =",speculativeArrayDimensions, ", initResult = ", "True" if initResult else "False")
		
		PRINT("\nAfter invoking addVariableToUnraveled(0,",variableId,'"", dataLocationOffsetForCurrentSetOfVariables =',dataLocationOffsetForCurrentSetOfVariables,", unraveled), unraveled =")
		printUnraveled(unraveled)

		# Update the firstUnmappedOffset for the next round
		for item in unraveled:
			endOffsetExclusiveForCurrentVariable = item[4]
			if checkIfIntegral(endOffsetExclusiveForCurrentVariable) and endOffsetExclusiveForCurrentVariable > firstUnmappedOffset:
				firstUnmappedOffset = endOffsetExclusiveForCurrentVariable
				
		totalBytesToReadFromDataFileForCurrentSetOfVariables = firstUnmappedOffset - dataLocationOffsetForCurrentSetOfVariables
		totalBytesToReadFromDataFile += totalBytesToReadFromDataFileForCurrentSetOfVariables
		PRINT ("\nInside populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize(), after processing variable",variableName,"(variableId =",variableId,"), now totalBytesToReadFromDataFile =",totalBytesToReadFromDataFile," and coloredVarsIdOffsetSize =",coloredVarsIdOffsetSize)


		PRINT("Now going to read", totalBytesToReadFromDataFile, "bytes from the data file")
		if dataFileName=="":
			return False

		if dataFileSizeInBytes < totalBytesToReadFromDataFileForCurrentSetOfVariables:
			PRINT("WARNING: Input file smaller than provided file format/structure - not all values would be displayable")
			
		dataBlockForCurrentSetOfVariables = readBytesFromFile(dataLocationOffsetForCurrentSetOfVariables, totalBytesToReadFromDataFileForCurrentSetOfVariables)
		
		if len(dataBlockForCurrentSetOfVariables) != min(totalBytesToReadFromDataFileForCurrentSetOfVariables, dataFileSizeInBytes-dataLocationOffsetForCurrentSetOfVariables):
			OUTPUT("ERROR in reading data file, was able to read only",len(dataBlockForCurrentSetOfVariables),"bytes of data while trying to read",totalBytesToReadFromDataFileForCurrentSetOfVariables,"bytes from",dataFileSizeInBytes,"-byte-sized data file")
			sys.exit()
		elif len(dataBlockForCurrentSetOfVariables)==0:
			OUTPUT("somehow for selectedVariables =",STR(selectedVariables), "len(dataBlockForCurrentSetOfVariables) = 0")
		else:
			PRINT("Adding len(dataBlockForCurrentSetOfVariables) =",len(dataBlockForCurrentSetOfVariables),"bytes to the exiting len(dataBlock) =",len(dataBlock))
			#dataBlock.extend(dataBlockForCurrentSetOfVariables)
			dataBlock += dataBlockForCurrentSetOfVariables
			PRINT("The new len(dataBlock) =",len(dataBlock))
	
		# Populate all possible variable names
#		arrayDimensions = [] if not variableDeclarations[variableId][4]["isArray"] else variableDeclarations[variableId][4]["arrayDimensions"]
#		allPossibleQualifiedNames = printAllArrayVariableNames(variableId, variableName, arrayDimensions, allPossibleQualifiedNames)

		# Actions at the end of the loop:
		#
		# If if this variable (varA) is the ancestor of the initialization partner (varI) of a blank-dimension array variable (varB), do the following:
		#   - Look at the global speculative execution status of the blank-dimension-array variable (call it varA).
		#	  - If there is an varA entry on top of the stack, then we look at the status of the Initialization. 
		#		 	- It it was a success, then pop the entry and from the Global execution stack and life goes on.
		#			- If it was a failure, then do NOT pop the stack. Choose the next the ancestor sibling of this varR as the next loop index n.
		# 
		if blankArraysAndTerminationInfo: 
			isAncestorOfInitializationPartner = False
			for blankDimensionArrayVariableId in getDictKeyList(blankArraysAndTerminationInfo):
				if blankDimensionArrayVariableId != blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["blankDimensionArrayVariableId"]:
					EXIT("Bad coding - blankDimensionArrayVariableId != blankArraysAndTerminationInfo[blankDimensionArrayVariableId][\"blankDimensionArrayVariableId\"]")
				partnerVariableId = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["partnerVariableId"]
				ancestorOfBlankDimensionArrayVariableId = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["siblingAncestors"][0]
				ancestorOfInitializationPartner = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]["siblingAncestors"][1]
				if variableId == ancestorOfInitializationPartner:
					identifierRecord = blankArraysAndTerminationInfo[blankDimensionArrayVariableId]
					isAncestorOfInitializationPartner = True
					PRINT("The variable",variableName,"(id",variableId,") is the ancestor of an initialization partner",variableDeclarations[partnerVariableId][0],"(id",partnerVariableId,") of a blank array variable", variableDeclarations[blankDimensionArrayVariableId][0],"(id",blankDimensionArrayVariableId,")")
					break
			if isAncestorOfInitializationPartner:
#				PRINT("The current blankArrayDimensionStack = ",blankArrayDimensionStack)
				if initResult == True:
					PRINT("The initialization succeeded")
					if not executionStateStack:
						errorMessage = "ERROR in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize() - for global variable " + variableName + ", the initResult is a success, but the executionStateStack[] is empty - to pop"
						errorRoutine(errorMessage)
						return False
					elif executionStateStack[-1]["identifierRecord"] != identifierRecord:
						errorMessage = "ERROR in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize() - for global variable " + variableName + ", the initResult is a success, and the executionStateStack[] is NOT empty either, but the top of the execution stack does not match the identifier record - it has a value of "+STR(executionStateStack[-1]["identifierRecord"])
						errorRoutine(errorMessage)
						return False
					else:
						PRINT("for global variable ", variableName, ", the initResult is a success, and the executionStateStack[] is NOT empty either, and the top of the execution stack also matches the identifier record - it has a value of ",STR(executionStateStack[-1]["identifierRecord"]))
						PRINT("Now going to pop the executionStateStack manually")
						executionStateStack.pop()
				elif initResult == False:		
					PRINT("The initialization failed - need to go back to the loop global variable", variableDeclarations[ancestorOfBlankDimensionArrayVariableId][0],"(id =",ancestorOfBlankDimensionArrayVariableId,")")
					# Find its blank variable counterpart
					goBackTarget = None
					# statementOrVarIdOrStructId will be either 1) A global variableId, or 2) a list ["struct"/"union", structId], or 3) a #RUNTIME statement
					# So, if it is integral, it is global variableId. If it a 2-member-list starting with "struct"/"union", then it is a structId. Else, it is a runtime statement.
					for k in statementOrVarIdOrStructId:
						if checkIfIntegral(statementOrVarIdOrStructId[k]): 
							if statementOrVarIdOrStructId[k]==ancestorOfBlankDimensionArrayVariableId:
								goBackTarget = k
								break
					if goBackTarget == None:
						EXIT("Coding bug in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize() - cannot find structMember variable "+ variableDeclarations[ancestorOfBlankDimensionArrayVariableId][0]+" (id = "+STR(ancestorOfBlankDimensionArrayVariableId)+")")
					else:
						PRINT("\nLooping back to n=",goBackTarget,"\n\n")
						n = goBackTarget
						continue
				elif initResult == None:
					EXIT("Coding bug in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize() - initResult should not be None here.")
				else:
					EXIT("Coding bug in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize() - invalid initResult = ", initResult)
		n = n+1


	# END-WHILE-LOOP

	# From now, we only do "collective" stuff
	
	# After unraveled is created, create the global variable coloredVarsIdOffsetSize from the global unraveled
	createColoredVarsIdOffsetSizeFromUnraveledResult = createColoredVarsIdOffsetSizeFromUnraveled()
	if createColoredVarsIdOffsetSizeFromUnraveledResult == False:
		errorMessage = "ERROR in populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize(): Error after calling createColoredVarsIdOffsetSizeFromUnraveled() with selectedVariables = "+STR(selectedVariables)
		errorRoutine(errorMessage)
		return False
		
##################################################################################################################################################################
# This creates the coloredVarsIdOffsetSize dataset from the unraveled. Recall that coloredVarsIdOffsetSize is the offset of the colored variables in the interpreted code window.
# coloredVarsIdOffsetSize refelects which all variables get mapped, and hence colored. It does not have same number of rows as unraveled, much less in most of the cases.
# Essentially, if coloredVarsIdOffsetSize has N rows, there are N number of variables in the interpreted code window that need to be colored.
# We NEVER unravel an array inside coloredVarsIdOffsetSize - all we have is a single entry, specifying its starting offset and total array size.
# We also never unravel a struct inside coloredVarsIdOffsetSize, with one exception - where the struct variable is declared in the same statement where the struct is defined.
# See example below why.
###################################################################################################################################################################
# Suppose we have a declaration like this below and then the user chooses to map (or color) var1 and var2.
#		struct S { int i; float f;} var1, var2;
# In that case, var1 (not var2) will occupy the same data space as i and f, and coloredVarsIdOffsetSize should reflect that by also adding i and f in it.

# However, suppose the code is like below and then the user chooses to map (or color) var1 and var2 only (i.e. it did not select the struct definition statement).
# So, the Anonymous struct variable did not get selected as a variable to be mapped - only the var1 and var2.
# 		struct S { int i; float f;};
# 		struct S var1, var2;
# In this case, var1 is not sharing its mapped data space with the Anonymous struct (or with variables i and f). 
# So, coloredVarsIdOffsetSize would not contain rows for i or f - it will only have rows for var1 and var2.
###################################################################################################################################################################
def createColoredVarsIdOffsetSizeFromUnraveled():
	global coloredVarsIdOffsetSize, coloredDataIdOffsetSize
	# The format of unraveled is like this below (with element index given for easy reading):
	#   0		1				2						3							4						5				6			7			8
	# level, variable, datatype/{Description}, starting offset (inclusive), ending offset+1 (exclusive), Raw Hex Bytes, Value (LE), Value (BE), [Ancestry list ending with current variableId]
	coloredVarsIdOffsetSize = []
	coloredDataIdOffsetSize = []
	for unraveledRowNumber in range(len(unraveled)):
		row = unraveled[unraveledRowNumber]
		varname = row[1]
		ancestry = row[8]
		suffixes2strip = [ " is of type struct", " is of type union", " - Array of "]	# Remove the part of the variable name starting from this
		for x in suffixes2strip:
			if x in varname:
				varname = varname[:varname.find(x)]
				PRINT("After stripping, varname =",varname)
		if varname[-1]=="]":
			PRINT("varname =",varname,"is an array element - skipping unraveledRowNumber",unraveledRowNumber," for coloredVarsIdOffsetSize")
			valueLE = row[6]
			valueBE = row[7]
			if valueLE != "" or valueBE != "":
				coloredDataIdOffsetSize.append([variableId,row[3],row[4]-row[3],unraveledRowNumber])
			else:
				PRINT("varname =",varname,"is an array element without a value - skipping unraveledRowNumber",unraveledRowNumber," for coloredDataIdOffsetSize")
		else:
			varname = re.split('\.',varname)[-1]
			if not checkIfIntegral(row[3]) or not checkIfIntegral(row[4]):
				OUTPUT("Non-Integral start or end address for unraveled[unraveledRowNumber=",unraveledRowNumber,"] =",unraveled[unraveledRowNumber])
				errorMessage = "Error in createColoredVarsIdOffsetSizeFromUnraveled(): unraveled["+STR(unraveledRowNumber)+"] = "+STR(unraveled[unraveledRowNumber])+" has non-Integral start or end address for variable "+varname
				errorRoutine(errorMessage)
				OUTPUT("\nCurrently, unraveled =")
				MUST_printUnraveled(unraveled)
				return False
			
			PRINT("After splitting, varname =",varname,"start offset =",row[3],", size =", row[4]-row[3],"for unraveledRowNumber",unraveledRowNumber)
			variableId = ancestry[-1]
			if variableDeclarations[variableId][0] != varname:
				errorMessage = "Error in createColoredVarsIdOffsetSizeFromUnraveled(): unraveled["+STR(unraveledRowNumber)+"][0] =",STR(unraveled[unraveledRowNumber][0]),"cannot be greater than unraveled[",STR(unraveledRowNumber),"-1][0]+1, which is ",STR(unraveled[unraveledRowNumber-1][0]+1)
				errorRoutine(errorMessage)
				return False
			else:
				PRINT("Adding unraveledRowNumber = ",unraveledRowNumber,"to coloredVarsIdOffsetSize[]\n")
				coloredVarsIdOffsetSize.append([variableId,row[3],row[4]-row[3],unraveledRowNumber])
				coloredDataIdOffsetSize.append([variableId,row[3],row[4]-row[3],unraveledRowNumber])
				
	PRINT("\n\n\nBefore sorting coloredVarsIdOffsetSize\n\n")
	PRINT("coloredVarsIdOffsetSize =",coloredVarsIdOffsetSize)
	for item in coloredVarsIdOffsetSize:	
		PRINT(variableDeclarations[item[0]][0],"<",item[1],",",item[1]+item[2],"> (length", item[2],") <start (inclusive), end (not inclusive)>", "unraveledRowNumber",unraveledRowNumber)
	coloredVarsIdOffsetSize.sort(key=lambda list3rdItem: list3rdItem[2], reverse=True)
	
	PRINT("\nAfter sorting, coloredVarsIdOffsetSize created =",coloredVarsIdOffsetSize)
	for row in coloredVarsIdOffsetSize:
		PRINT(row)
	
	PRINT("\n\n\nBefore sorting coloredDataIdOffsetSize\n\n")
	PRINT("coloredDataIdOffsetSize =",coloredDataIdOffsetSize)
	for item in coloredDataIdOffsetSize:	
		PRINT(variableDeclarations[item[0]][0],"<",item[1],",",item[1]+item[2],"> (length", item[2],") <start (inclusive), end (not inclusive)>", "unraveledRowNumber",unraveledRowNumber)
	coloredDataIdOffsetSize.sort(key=lambda list3rdItem: list3rdItem[2], reverse=True)
	
	PRINT("\nAfter sorting, coloredDataIdOffsetSize created =")
	for row in coloredDataIdOffsetSize:
		PRINT(row)
		
	return True

############################################################################################################################
############################################################################################################################
#
# interpret - Batch portion
#
############################################################################################################################
############################################################################################################################

def interpretBatch():
	global lines, gTokenLocationLinesChars, enums, enumFieldValues, typedefs, structuresAndUnions, suDict, unraveled	#, allPossibleQualifiedNames
	global dummyVariableCount, totalVariableCount, variableIdsInGlobalScope, globalScopesSelected, coloredVarsIdOffsetSize, variablesAtGlobalScopeSelected, runtimeStatementOrGlobalScopedVariableIdOrStructId
	global pragmaPackCurrentValue, pragmaPackStack, blankArraysAndTerminationInfo, executionStateStack	#, blankArrayDimensionStack

	PRINT ("\n\n\n============ Entered interpretBatch() ==================\n\n\n")

	pragmaPackCurrentValue = None
	pragmaPackStack = []
	gTokenLocationLinesChars = []
	variableDeclarations = []
#	allPossibleQualifiedNames = []
	unraveled = []
	enums.clear()
	enumFieldValues.clear()
	typedefs.clear()
	suDict.clear()
	structuresAndUnions = []
	dummyVariableCount = 0
	totalVariableCount = 0
	variableIdsInGlobalScope = []
	globalScopesSelected = []
	coloredVarsIdOffsetSize = []
	variablesAtGlobalScopeSelected = []
	runtimeStatementOrGlobalScopedVariableIdOrStructId = []
	dataBlock = []
	blankArraysAndTerminationInfo = {} 
	executionStateStack = []
#	blankArrayDimensionStack = []
	
	# Call the main module
	mainWorkOutput = mainWork()
	if mainWorkOutput == False:
		OUTPUT ("ERROR in interpretBatch() after calling mainWork() - exiting" )
		return False

def checkIfColoredVarsIdOffsetSizeIsInSyncWithTotalBytesToReadFromDataFile():
	
	if totalBytesToReadFromDataFile == 0:
		if not coloredVarsIdOffsetSize:
			return
		else:
			for item in coloredVarsIdOffsetSize:
				if item[2] != 0:
					OUTPUT("totalBytesToReadFromDataFile =",totalBytesToReadFromDataFile,", yet coloredVarsIdOffsetSize =",STR(coloredVarsIdOffsetSize))
				
	hasBitfields = False
	for item in coloredVarsIdOffsetSize:
		if variableDeclarations[item[0]][4]['isBitField']== True:
			hasBitfields = True
	
	# Sanity check. Remember that this straight-up addition would not work for bitfield, since there many different variables would occupy the same container.
	min = 10000000000000000000000
	max = -1
	for item in coloredVarsIdOffsetSize:
		if item[1]<min:
			min = item[1]
		if item[1]+item[2] > max:
			max = item[1]+item[2]
	if min != dataLocationOffset:
		OUTPUT("ERROR in checkIfColoredVarsIdOffsetSizeIsInSyncWithTotalBytesToReadFromDataFile(): totalBytesToReadFromDataFile =",totalBytesToReadFromDataFile,"coloredVarsIdOffsetSize =",STR(coloredVarsIdOffsetSize))
		OUTPUT("min (",min,") != dataLocationOffset (",dataLocationOffset,") - exiting")
		sys.exit()
	if max != dataLocationOffset+totalBytesToReadFromDataFile and hasBitfields == False:
		OUTPUT("ERROR in checkIfColoredVarsIdOffsetSizeIsInSyncWithTotalBytesToReadFromDataFile(): totalBytesToReadFromDataFile =",totalBytesToReadFromDataFile,"coloredVarsIdOffsetSize =",STR(coloredVarsIdOffsetSize))
		OUTPUT("max (",max,") != dataLocationOffset (",dataLocationOffset,") + totalBytesToReadFromDataFile (",totalBytesToReadFromDataFile,")")
		sys.exit()
	return


############################################################################################
#  
#  process in the Batch mode
#
############################################################################################

def processBatch():
	global lines, variablesAtGlobalScopeSelected, PRINT_DEBUG_MSG, lastActionWasInterpret, lastActionWasMap
	global coloredVarsIdOffsetSize, totalBytesToReadFromDataFile, dataBlock, unraveled
	PRINT("Inside processBatch()")
	
	if not BATCHMODE:
		OUTPUT ("ERROR - being asked to process in batchmode when BATCHMODE is False")
		sys.exit()
	
	if codeFileName and os.path.exists(codeFileName):
		with open(codeFileName, "r") as codeFile:
			try:
				lines = codeFile.readlines()
				if not checkIfStringOrListOfStrings(lines):
					errorMessage = "ERROR in coding: input code file content is NOT string - type(lines) = "+STR(type(asciiLines))
					errorRoutine(errorMessage)
					return False
				
			except ValueError: # Empty file
				return False
	else:
		OUTPUT("ERROR - cannot open code file",codeFileName)
		sys.exit()
		
	PRINT ("Code file contains:", lines )

	PRINT ("calling interpretBatch()")
	lastActionWasInterpret = True
	lastActionWasMap = False
	interpretBatchResult = interpretBatch()

	# Call the main module
	if interpretBatchResult == False:
		OUTPUT ("ERROR in interpret() after calling mainWork() - exiting" )
		return False
	else:
		PRINT("Successfully executed interpretBatchResult()")

	gStructuresAndUnions = deepCopy(structuresAndUnions)
	gVariableDeclarations = deepCopy(variableDeclarations)

	# Instead of mapping, we create straightaway say everything at global scope is selected (unless it is a typedef and we are not mapping that)
	variablesAtGlobalScopeSelected = []
	for i in range(len(variableIdsInGlobalScope)):
		varIndex = variableIdsInGlobalScope[i][0]
		PRINT("i =",i,"variableDeclarations[varIndex] =",variableDeclarations[varIndex])
		if 'typedef' in variableDeclarations[varIndex][2]: 
			if MAP_TYPEDEFS_TOO:
				PRINT("Counting typedefs")
				# There is a special case - where we are using builtin typedefs, and we are mapping typedefs too, but since it is builtin, there is no code to actual color
				if variableDeclarations[varIndex][4]["globalTokenListIndex"] >= 0:
					variablesAtGlobalScopeSelected.append(varIndex)
			else:	
				PRINT("Cannot count typedefs")
			pass
		else:
			PRINT("Counting non-typedef")
			variablesAtGlobalScopeSelected.append(varIndex)
	
	if inputVariables:
		allPossibleGlobalVariableNames = [variableDeclarations[variableId][0] for variableId in variablesAtGlobalScopeSelected]
		globalsToKeep = []
		PRINT("allPossibleGlobalVariableNames =",allPossibleGlobalVariableNames)
		PRINT("Keeping only the list of the user-supplied variables (assuming they are indeed global): ",inputVariables)
		for variableId in variablesAtGlobalScopeSelected:
			variableName = variableDeclarations[variableId][0]
			if variableName in inputVariables:
				globalsToKeep.append(variableId)
		PRINT("After processing the input list, globalsToKeep =",[variableDeclarations[variableId][0] for variableId in globalsToKeep])
		if globalsToKeep:
			variablesAtGlobalScopeSelected = globalsToKeep
		else:
			OUTPUT("None of the user-supplied variables are in the global list - hence displaying ALL global variables")


		# This part below is completely copied from selectVariablesAtGlobalScope (might want to put it under a separate routine in order to 
		# not having to make identical edits to 2 places)

		# Now, if the variablesAtGlobalScopeSelected have some global-scoped variables that have global-scoped buddies, the buddies must get selected too.
		# This happens when we have #RUNTIME statements outside any struct definition
		if globalScopedBuddies:
			PRINT("\n\nThe current variablesAtGlobalScopeSelected =",variablesAtGlobalScopeSelected)
			selectTheseBuddiesToo = []
			for var in variablesAtGlobalScopeSelected:
				for buddyGroup in globalScopedBuddies:
					if var in buddyGroup:
						indexVal = buddyGroup.index(var)
						temp = buddyGroup[:indexVal]+buddyGroup[indexVal+1:]
						for t in temp:
							# Do not select something that is already selected (or will be selected)
							if t not in variablesAtGlobalScopeSelected and t not in selectTheseBuddiesToo:
								PRINT("Adding global-scoped varaible id",t,"because global-scoped variableId",var,"was chosen")
								selectTheseBuddiesToo.append(t)
			if selectTheseBuddiesToo:
				variablesAtGlobalScopeSelected.extend(selectTheseBuddiesToo)
				variablesAtGlobalScopeSelected.sort()
				PRINT("The final variablesAtGlobalScopeSelected =",variablesAtGlobalScopeSelected)
		else:
			PRINT("\n\nBlank globalScopedBuddies[] - unchanged variablesAtGlobalScopeSelected =",variablesAtGlobalScopeSelected)


	if not checkIfDataFileIsValidAndGetItsLength(dataFileName):
		OUTPUT("Error opening data file",dataFileName)
		sys.exit()

	lastActionWasInterpret = False
	lastActionWasMap = True

	returnStatus = populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize()
	if returnStatus == False:
		OUTPUT("Error in processBatch() after calling populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize()")
		sys.exit()
	
	PRINT("Now going to print the unraveled")
	prettyPrintUnraveled()
	PRINT("THE END")

	if gStructuresAndUnions != structuresAndUnions or gVariableDeclarations != variableDeclarations:
		PRINT("structuresAndUnions or variableDeclarations changes")
	else:
		PRINT("structuresAndUnions or variableDeclarations does NOT change")
	

		
#	AST=['var2','.','f']
#	evaluateArithmeticExpressionResult = evaluateArithmeticExpression(AST)
#	if evaluateArithmeticExpressionResult[0]:
#		MUST_PRINT("evaluateArithmeticExpression(V1.i)=",evaluateArithmeticExpressionResult[1])
#	else:
#		MUST_PRINT("Error evaluating evaluateArithmeticExpression(V1.i)=")
		
def main():
	
	global window, BATCHMODE, MAINLOOP_STARTED

	if not BATCHMODE:
		try:
			app = tk.Tk()
		except tk.TclError:
			OUTPUT("Error in instantiating GUI - resorting to batch mode")
			BATCHMODE = True
	
	parseCommandLineArguments()

	if BATCHMODE:
		processBatch()
	elif not BATCHMODE:
		try:
			app.title(TOOL_NAME)
			window = MainWindow(app)
			app.protocol("WM_DELETE_WINDOW", window.quit)
			app.resizable(width=False, height=False)
			
			if IN_DEMO:
				window.runDemo()
				
			MAINLOOP_STARTED = True
			app.mainloop()
		except tk.TclError:
			OUTPUT("Error in instantiating GUI - exiting!")
			sys.exit()
	else:
		OUTPUT("Unknown value of BATCHMODE =",BATCHMODE)
		sys.exit()

class MainWindow:

	def __init__(self, parent):
		self.parent = parent
		self.validateCommandDataOffsetEntry = parent.register(self.validateRoutineDataOffsetEntry)		# Data location offset
		self.validateCommandFileOffsetEntry = parent.register(self.validateRoutineFileOffsetEntry)		# File display  offset
		self.createGUIvariables()
		self.createWidgets()
		self.createToolLayout()
		self.create_bindings()
		
		if codeFileName:
			self.openCodeFile(codeFileName)

		# Do NOT delete the BUG below. 
#		if dataFileName:	# BUG !!! BUG !!!  BUG !!! If dataFileName == 0 (which means run the first demo), this test will fail since 0 is considered false
		if dataFileName != "":
			self.openDataFile(dataFileName)

		# Explicitly set
		if dataLocationOffset != 0:
			self.dataOffsetEntry.insert(tk.END,dataLocationOffset)
		
	def createGUIvariables(self):
#		self.dataFileSizeInBytes = None
#		self.gTokenLocationLinesChars = []
#		self.dataFileName = None

		# This variable has a special purpose. We have trace variables associated with the self.fileOffset, which means every time it changes, the data window gets re-displayed.
		# We also have a special handling of self.fileOffset variable - if it is blank, set it to 0.
		# Unfortunately, this creates a particular problem - we can never update it properly. That's because, on the IntVar variable in Tcl/Tk, there is no "direct" update method -
		# you have to first delete it and only then insert it. However, the moment you delete it, it gets blanked out, and gets reset to 0. And due to trace, we re-display.
		# So, now when you re-insert your intended value, it's going to have an extra 0 at the end, thereby effectively multiplying it by 10.
		# So, we want to solve two problems. We want to stop re-displaying the data windows until they are really ready.
		self.OK2reDisplayDataWindows = False 	# We will set it to True at the end of this routine
		
		# This is modified by both SpinBox (directly) and the Entry to its right (indirectly)
		self.fileOffset = tk.IntVar()
		PRINT("Inside createGUIvariables(), doing self.fileOffset.set(0)")
		self.fileOffset.set(0)
		PRINT("Inside createGUIvariables(), did self.fileOffset.set(0)")
		
		# There are two variables associated with the data offset.
		# 1. The one where you can enter any text (like 1MB/2+0x13). This is NOT an int-only field, hence we need a StringVar.
		# 2. The integer variable (self.dataOffset) that we deduce from the above string.
		
		self.dataOffset = tk.IntVar()		
		PRINT("Inside createGUIvariables(), doing self.dataOffset.set(0)")
		self.dataOffset.set(0)
		PRINT("Inside createGUIvariables(), did self.dataOffset.set(0)")
		
		
		self.dataOffsetEntryVariable = tk.StringVar()
		self.fileOffsetEntryVariable = tk.StringVar()
		
#		self.originalCodeTextVariable = tk.StringVar()		# We do not need another similar variable for the Interpreted code window since that is supposed to be used as Rread-only
		
		self.colorTagsFG = []	# Contains the tag name texts that are associated with the tags that color the Interpreted Code and Data (Hex and ASCII) windows in the foreground.
		self.colorTagsData = []
		self.COLORS = []
		self.currentCoordinates = ""

		self.OK2reDisplayDataWindows = True
		
		# This array/list is created for a very special reason. Suppose after coloring code and data, we take our cursor over certain data items, 
		# and as a result the corresponding variable in the Interpreted Code gets background-highlighted.
		# Now, imgine doing a Page down. You did not really move the cursor, do the <Leave> routine will not get triggered. 
		# As a result, the highlighting in the Interpreted Code window will remain.
		# This is NOT just a problem with Page Up or Page Down
		self.interpretedCodeVariablesHighlightedStartEndCoordinates = []

	def validateRoutineDataOffsetEntry(self, P):
		PRINT ("Inside validateRoutineDataOffsetEntry() Passed parameter(P) =",P,"type(P) =",type(P))
		self.dataOffsetEntryVariable.set(P)
		humanReadableOffsetString = self.dataOffsetEntryVariable.get()
		PRINT ("Currently self.dataOffsetEntryVariable =",humanReadableOffsetString)
		if humanReadableOffsetString.strip() == "":
			self.dataOffset.set(0)
			self.dataOffsetEntry.delete(0, tk.END)
			# If we are returning False, the dataOffsetEntry will get disabled. So here is a hack to enable it from outside
#			self.frame.after_idle(lambda: self.dataOffsetEntry.config(validate='focusout'))	
			self.frame.after(1000,lambda: self.dataOffsetEntry.config(validate='focusout'))	 
			return False
		else:
			result = convertByteUnits2Decimal(humanReadableOffsetString)
			if result[0] == False:
				self.frame.after(1000,lambda: self.dataOffsetEntry.config(validate='focusout'))	
				return False
			else:
				offsetValue = result[1]
			PRINT ("Data location offset of <",humanReadableOffsetString,"> resolves to ",offsetValue)
			if offsetValue < 0:
#			if offsetValue + totalBytesToReadFromDataFile <= 0:
#				errorMessage = STR(humanReadableOffsetString)+ " resolves to "+STR(offsetValue)+", while the total size of the mapped variables ="+STR(totalBytesToReadFromDataFile)+" bytes, which means that none of the data format will get mapped"
				errorMessage = STR(humanReadableOffsetString)+ " resolves to "+STR(offsetValue)+", while is less than zero"
				errorRoutine(errorMessage)
				self.frame.after(1000,lambda: self.dataOffsetEntry.config(validate='focusout'))	
				return False
			elif offsetValue >= dataFileSizeInBytes:
				errorMessage = STR(humanReadableOffsetString)+ " resolves to "+STR(offsetValue)+", which is not a valid data offset as file size iteself is "+STR(dataFileSizeInBytes)
				errorRoutine(errorMessage)
				self.frame.after(1000,lambda: self.dataOffsetEntry.config(validate='focusout'))	
				return False
			else:
				PRINT("\n"*3,"=="*50,"\n Now going to re-display data for data location offset %d\n"%offsetValue,"=="*50,"\n"*2)
				self.dataOffset.set(offsetValue)
				self.displayAndColorDataWindows()
				return True

	def validateRoutineFileOffsetEntry(self, P):	
		PRINT( "Inside validateRoutineFileOffsetEntry() Passed parameter(P) =",P,"type(P) =",type(P))
		self.fileOffsetEntryVariable.set(P)
		humanReadableOffsetString = self.fileOffsetEntryVariable.get()
		PRINT ("Currently self.fileOffsetEntryVariable =",humanReadableOffsetString)
		if humanReadableOffsetString.strip() == "":
			self.fileOffsetEntry.delete(0, tk.END)
			# If we are returning False, the fileOffsetEntry will get disabled. So here is a hack to enable it from outside
#			self.frame.after_idle(lambda: self.fileOffsetEntry.config(validate='focusout'))	
			self.frame.after(1000,lambda: self.fileOffsetEntry.config(validate='focusout'))	
			return False
		else:
			result = convertByteUnits2Decimal(humanReadableOffsetString)
			if result[0] == False:
				self.frame.after(1000,lambda: self.fileOffsetEntry.config(validate='focusout'))	
				return False
			else:
				offsetValue = result[1]
			PRINT (humanReadableOffsetString," resolves to ",offsetValue)
			if offsetValue < 0:
				errorMessage = STR(humanReadableOffsetString)+ " resolves to "+STR(offsetValue)+", which is not a valid file offset"
				errorRoutine(errorMessage)
				self.frame.after(1000,lambda: self.fileOffsetEntry.config(validate='focusout'))	
				return False
			elif offsetValue >= dataFileSizeInBytes:
				errorMessage = STR(humanReadableOffsetString)+ " resolves to "+STR(offsetValue)+", which is not a valid file offset as file size iteself is "+STR(dataFileSizeInBytes)
				errorRoutine(errorMessage)
				self.frame.after(1000,lambda: self.fileOffsetEntry.config(validate='focusout'))	
				return False
			else:
				PRINT("\n"*3,"=="*50,"\n Now going to re-display data for file offset %d\n"%offsetValue,"=="*50,"\n"*2)
#				self.fileOffsetSpinbox.config(from_=offsetValue)
				PRINT ("Going to delete the self.fileOffsetSpinbox value")
				PRINT("Currently, self.fileOffsetSpinbox.get() =",self.fileOffsetSpinbox.get(),"self.fileOffset.get() =",self.fileOffset.get())
				self.OK2reDisplayDataWindows = False
				self.fileOffsetSpinbox.delete(0,"end")
				PRINT ("Deleted the self.fileOffsetSpinbox value.")
				self.OK2reDisplayDataWindows = True
				self.fileOffsetSpinbox.insert(0,offsetValue)
				PRINT ("After inserting the value of", offsetValue,"into the self.fileOffsetSpinbox, self.fileOffsetSpinbox.get() =",self.fileOffsetSpinbox.get(),"self.fileOffset.get() =",self.fileOffset.get())
				self.fileOffset.set(offsetValue)
				PRINT ("After performing self.fileOffset.set(offsetValue) where offsetValue =", offsetValue,"self.fileOffsetSpinbox.get() =",self.fileOffsetSpinbox.get(),"self.fileOffset.get() =",self.fileOffset.get())
				self.displayAndColorDataWindows()
				return True
	
	def toggleDebug(self):
		global PRINT_DEBUG_MSG
		if PRINT_DEBUG_MSG:
			PRINT ("\nTurning Debug OFF\n")
			dumpDetailsForDebug()
			PRINT_DEBUG_MSG = False
			self.toggleDebugButton.config(text="Debug OFF")
		else:
			PRINT_DEBUG_MSG = True
			PRINT ("\nTurning Debug ON\n")
			self.toggleDebugButton.config(text="Debug ON")

	def toggleHexDec(self):
		global DISPLAY_INTEGRAL_VALUES_IN_HEX
		
		if DISPLAY_INTEGRAL_VALUES_IN_HEX == True:
			PRINT("Switching to Dec")
			DISPLAY_INTEGRAL_VALUES_IN_HEX = False
			self.toggleHexDecButton.config(text="Dec/Hex")
		else:
			PRINT("Switching to Hex")
			DISPLAY_INTEGRAL_VALUES_IN_HEX = True
			self.toggleHexDecButton.config(text="Hex/Dec")
		
		if lines:
			self.dataOffsetChange()
		

	def toggleRunOrClearDemo(self):
		global IN_DEMO
		
		if IN_DEMO == False:
			IN_DEMO = True
			self.toggleRunOrClearDemoButton.config(text="Clear Demo")
			self.runDemo()
		elif IN_DEMO == True:
			IN_DEMO = False
			self.toggleRunOrClearDemoButton.config(text="Run Demo")
			self.clearDemo()
		else:
			errorMessage = "ERROR in toggleRunOrClearDemo(), IN_DEMO value neither True nor False"
			errorRoutine(errorMessage)
		

	def toggleMapTypedefsToo(self):
		global MAP_TYPEDEFS_TOO
		
		if MAP_TYPEDEFS_TOO == True:
			PRINT("Now typedefs would NO LONGER be treated as variable declarations (for data mapping purposes)")
			MAP_TYPEDEFS_TOO = False
			self.toggleMapTypedefsTooButton.config(text="Not mapping typedefs")
		elif MAP_TYPEDEFS_TOO == False:
			PRINT("Now typedefs would also be treated as variable declarations (for data mapping purposes)")
			MAP_TYPEDEFS_TOO = True
			self.toggleMapTypedefsTooButton.config(text="Mapping typedefs too")
		else:
			sys.exit()
		
		if lines:
			self.selectVariablesAtGlobalScope()
			self.dataOffsetChange()

				
	def createWidgets(self):
		frame = self.frame = ttk.Frame(self.parent)
		self.openCodeFileButton = ttk.Button(frame, text="Open code file", underline=5,command=self.openCodeFileDialogue)
		self.originalCodeLabel = ttk.Label(frame, text="Original code")
		self.interpretButton = ttk.Button(frame, text="Interpret", underline=0,command=self.interpret)
		self.interpretedCodeLabel = ttk.Label(frame, text="Interpreted code")
		self.mapButton = ttk.Button(frame, text="Map", underline=0,command=self.mapStructureToData)
		self.dataLocationOffsetLabel = ttk.Label(frame, text="Data starts at offset", underline=1)
		
		self.dataOffsetEntry = ttk.Entry(frame, text="dataOffsetEntry", validate="focusout", validatecommand=(self.validateCommandDataOffsetEntry, '%P'))
		if dataFileName == None:
			self.dataOffsetEntry.config(state=tk.DISABLED)
		
		self.openDataFileButton = ttk.Button(frame, text="Open data file", underline=0,command=self.openDataFileDialogue)
		self.fileOffsetLabel = ttk.Label(frame, text="from Offset", underline=0, width=12)
		self.fileOffsetSpinbox = Spinbox(frame, from_=0, textvariable=self.fileOffset, increment=BLOCK_SIZE)


		self.fileOffsetEntryLabel = ttk.Label(frame, text=" or ", width = 4)
		# Apparently, the text (or textvariable) has use - if we have two Entry widgets with the same text (or textvariable), they get "linked" by TCL
		# So, we MUST use different variables
		self.fileOffsetEntry = ttk.Entry(frame, text="fileOffsetEntry", validate="focusout", validatecommand=(self.validateCommandFileOffsetEntry, '%P'))
		if dataFileName == None:
			self.fileOffsetEntry.config(state=tk.DISABLED)
		
		toggleHexDecInitalText = "Hex/Dec" if DISPLAY_INTEGRAL_VALUES_IN_HEX else "Dec/Hex"
		self.toggleHexDecButton = ttk.Button(frame, text=toggleHexDecInitalText, underline=0,command=self.toggleHexDec)  
		toggleDebugInitalText = "Debug ON" if PRINT_DEBUG_MSG else "Debug OFF"
		self.toggleDebugButton = ttk.Button(frame, text=toggleDebugInitalText, underline=1,command=self.toggleDebug)  
		self.originalCodeText = tk.Text(self.frame, height=DISPLAY_BLOCK_HEIGHT, width=DISPLAY_BLOCK_WIDTH * 3)
		self.originalCodeTextVerticalScrollbar = ttk.Scrollbar(self.frame, command=self.originalCodeText.yview)
		self.interpretedCodeText = tk.Text(self.frame, height=DISPLAY_BLOCK_HEIGHT, width=DISPLAY_BLOCK_WIDTH * 3)
		self.interpretedCodeTextVerticalScrollbar = ttk.Scrollbar(self.frame, command=self.interpretedCodeText.yview)
		
		self.interpretedCodeText.config(state=tk.DISABLED)	# Initially, it should be disabled. Only Interpret should make it NORMAL

#		self.viewDataText = tk.Text(self.frame, height=DISPLAY_BLOCK_HEIGHT, width=4+(DISPLAY_BLOCK_WIDTH * 4))
		self.addressColumnText = tk.Text(self.frame, height=DISPLAY_BLOCK_HEIGHT, width=13)
		self.viewDataHexText = tk.Text(self.frame, height=DISPLAY_BLOCK_HEIGHT, width=(DISPLAY_BLOCK_WIDTH * 3))
		self.viewDataAsciiText = tk.Text(self.frame, height=DISPLAY_BLOCK_HEIGHT, width=(DISPLAY_BLOCK_WIDTH+1))
		self.CodeDataMeaningLabel = ttk.Label(frame, text="Description: ")
#		self.CodeDataMeaningText = ttk.Label(frame)										# MannaManna
		self.CodeDataMeaningText = ttk.Label(self.frame,wraplength=600,justify=tk.LEFT)
		self.dataAddressStartLabel = ttk.Label(frame, text="Address (start):")
		self.dataAddressEndLabel = ttk.Label(frame, text="Address (end):")
		self.dataAddressStartText = ttk.Label(frame)
		self.dataAddressEndText = ttk.Label(frame)
		self.dataLengthLabel = ttk.Label(frame, text="Length: ")
		self.dataLengthText = ttk.Label(frame)
		self.dataValueLELabel = ttk.Label(frame, text="Value (Little-Endian): ")
		self.dataValueBELabel = ttk.Label(frame, text="Value (Big-Endian)   : ")
		self.dataValueLEText = ttk.Label(frame)
		self.dataValueBEText = ttk.Label(frame)
#		self.treeView = ttk.Treeview(frame, height=8, displaycolumns='#all')		# Didn't work
		self.treeView = ttk.Treeview(frame, height=8)
		self.treeScroll = ttk.Scrollbar(frame, orient="vertical", command=self.treeView.yview)
		self.treeView.configure(yscrollcommand=self.treeScroll.set)
		toggleRunOrClearDemoInitalText = "Clear Demo" if IN_DEMO else "Run Demo"
		self.toggleRunOrClearDemoButton = ttk.Button(frame, text=toggleRunOrClearDemoInitalText, underline=9,command=self.toggleRunOrClearDemo)
		toggleMapTypedefsTooInitalText = "Mapping typedefs too" if MAP_TYPEDEFS_TOO else "Not mapping typedefs"
		self.toggleMapTypedefsTooButton = ttk.Button(frame, text=toggleMapTypedefsTooInitalText, underline=8,command=self.toggleMapTypedefsToo)
		
		self.createBasicTags()

	def createBasicTags(self):
		self.viewDataHexText.tag_configure("ascii", foreground="green")
		self.viewDataHexText.tag_configure("error", foreground="red")
		self.viewDataHexText.tag_configure("hexspace", foreground="navy")
		self.viewDataHexText.tag_configure("graybg", background="lightgray")
		self.viewDataHexText.tag_configure("yellowbg", background=HIGHLIGHT_COLOR)
		
		self.viewDataAsciiText.tag_configure("ascii", foreground="green")
		self.viewDataAsciiText.tag_configure("error", foreground="red")
		self.viewDataAsciiText.tag_configure("hexspace", foreground="navy")
		self.viewDataAsciiText.tag_configure("graybg", background="lightgray")
		self.viewDataAsciiText.tag_configure("yellowbg", background=HIGHLIGHT_COLOR)
		
		self.interpretedCodeText.tag_configure("yellowbg", background=HIGHLIGHT_COLOR)

	def createToolLayout(self):
		#####################
		# First Row widgets
		#####################
		
		# Widgets above the Original code window
		col = 0
		colSpan = 2
		self.openCodeFileButton.grid(row=0,column=col, columnspan=colSpan, sticky=tk.W)
		col = col + colSpan
		colSpan = 2
		self.originalCodeLabel.grid(row=0,column=col, columnspan=colSpan, sticky=tk.W)
		col = col + colSpan
		colSpan = 2
		self.interpretButton.grid(row=0,column=col, columnspan=colSpan, sticky=tk.W)
		
		# Widgets above the Interpreted code window
		col = col + colSpan
		colSpan = 2
		self.interpretedCodeLabel.grid(row=0,column=col, columnspan=colSpan, sticky=tk.W)
		col = col + colSpan
		colSpan = 1
		self.mapButton.grid(row=0,column=col, columnspan=colSpan, sticky=tk.W)
		col = col + colSpan
		colSpan = 1
		self.dataLocationOffsetLabel.grid(row=0, column=col, columnspan=colSpan, sticky=tk.E)
		col = col + colSpan
		colSpan = 2
		self.dataOffsetEntry.grid(row=0, column=col, columnspan=colSpan, sticky=tk.E)
		
		# Widgets above the Data display window
		col = 12
		colSpan = 1
		self.openDataFileButton.grid(row=0, column=col, columnspan=colSpan, sticky=tk.W) 
		col = col + colSpan
		colSpan = 1
		self.fileOffsetLabel.grid(row=0, column=col, columnspan=colSpan, sticky=tk.W) 
		col = col + colSpan
		colSpan = 1
		self.fileOffsetSpinbox.grid(row=0, column=col, columnspan=colSpan, sticky=tk.W) 
		col = col + colSpan
		colSpan = 1
		self.fileOffsetEntryLabel.grid(row=0, column=col, columnspan=colSpan, sticky=tk.W) 
		col = col + colSpan
		colSpan = 2
		self.fileOffsetEntry.grid(row=0, column=col, columnspan=colSpan, sticky=tk.W) 
		col = col + colSpan
		colSpan = 2
		self.toggleHexDecButton.grid(row=0, column=col, columnspan=colSpan, sticky=tk.E) 
		col = col + colSpan
		colSpan = 1
#		self.toggleDebugButton.grid(row=0, column=col, columnspan=colSpan, sticky=tk.E) 
		self.toggleRunOrClearDemoButton.grid(row=0, column=col, columnspan=colSpan, sticky=tk.E) 
#		for column, widget in enumerate((self.openDataFileButton, self.fileOffsetLabel, self.fileOffsetSpinbox, self.fileOffsetEntryLabel, self.fileOffsetEntry, self.toggleDebugButton)):
#			widget.grid(row=0, column=column+12, sticky=tk.W if widget != self.toggleDebugButton else tk.E)

#		self.fileOffsetEntryVariable = tk.StringVar()

		#######################
		# Second Row widgets
		#######################
		col = 0
		colSpan = 5
		self.originalCodeText.grid(row=1,column=0, columnspan=colSpan, sticky=tk.NSEW)
		col = col + colSpan
		colSpan = 1
		self.originalCodeTextVerticalScrollbar.grid(row=1,column=col, sticky=tk.NSEW)
		self.originalCodeText['yscrollcommand'] = self.originalCodeTextVerticalScrollbar.set
		
		col = col + colSpan
		colSpan = 5
		self.interpretedCodeText.grid(row=1,column=6, columnspan=5, sticky=tk.NSEW)
		self.interpretedCodeTextVerticalScrollbar.grid(row=1,column=11, sticky=tk.NSEW)
		self.interpretedCodeText['yscrollcommand'] = self.interpretedCodeTextVerticalScrollbar.set
		col = 12
		colSpan = 1
		self.addressColumnText.grid  (row=1, column=col, columnspan=colSpan, sticky=tk.W)
		col = col + colSpan
		colSpan = 6
		self.viewDataHexText.grid  (row=1, column=col, columnspan=colSpan, sticky=tk.W)
		col = col + colSpan
		colSpan = 2
		self.viewDataAsciiText.grid(row=1, column=col, columnspan=colSpan, sticky=tk.W)
		
		################################
		# Third Row widgets
		################################
		col = 0
		colSpan = 1
		self.CodeDataMeaningLabel.grid(row=2, rowspan=2, column=col, columnspan=colSpan, sticky=tk.W)
		col = col + colSpan
		colSpan = 11
		self.CodeDataMeaningText.grid(row=2, rowspan=2, column=col, columnspan=colSpan, sticky=tk.W)
		col = col + colSpan
		colSpan = 1
		self.dataAddressStartLabel.grid(row=2, column=col, columnspan=colSpan, sticky=tk.W)
		col = col + colSpan
		colSpan = 1
		self.dataAddressStartText.grid(row=2, column=col, columnspan=colSpan, sticky=tk.W)
		col = col + colSpan
		colSpan = 1
		self.dataValueLELabel.grid(row=2,column=col, columnspan=colSpan, sticky=tk.W)
		col = col + colSpan
		colSpan = 4
		self.dataValueLEText.grid(row=2,column=col, columnspan=colSpan, sticky=tk.W)
		col = col + colSpan
		colSpan = 1
		self.dataLengthLabel.grid(row=2,column=col, columnspan=colSpan, sticky=tk.W)
		col = col + colSpan
		colSpan = 1
		self.dataLengthText.grid(row=2,column=col, columnspan=colSpan, sticky=tk.W)

		################################
		# Fourth Row widgets
		################################
		col = 12
		colSpan = 1
		self.dataAddressEndLabel.grid(row=3, column=col, columnspan=colSpan, sticky=tk.W)
		col = col + colSpan
		colSpan = 1
		self.dataAddressEndText.grid(row=3, column=col, columnspan=colSpan, sticky=tk.W)
		col = col + colSpan
		colSpan = 1
		self.dataValueBELabel.grid(row=3,column=col, columnspan=colSpan, sticky=tk.W)
		col = col + colSpan
		colSpan = 4
		self.dataValueBEText.grid(row=3,column=col, columnspan=colSpan, sticky=tk.W)
		col = col + colSpan
		colSpan = 1

		################################
		# Fifth Row widgets
		################################
		
		self.treeView.grid(row=4,column=0,columnspan=col+1, sticky=tk.NSEW)
		self.treeScroll.grid(row=4,column=col+2, sticky=tk.NSEW)
		self.treeView["columns"]=("1","2","3","4","5","6","7")
		self.treeView["height"]=7
		self.treeView.column("#0", width=100, anchor=tk.W)
		self.treeView.column("1", width=400, anchor=tk.W)
		self.treeView.column("2", width=200, anchor='c')
		self.treeView.column("3", width=100, anchor='c')
		self.treeView.column("4", width=100, anchor='c')
		self.treeView.column("5", width=200, anchor='c')
		self.treeView.column("6", width=150, anchor='c')
		self.treeView.column("7", width=150, anchor='c')

#		self.treeViewHeadings = ["Variable Name", "Data Type", "Addr Start", "Addr End", "Raw Hex Bytes", "Value (LE)", "Value (BE)"]
#		for c in range(len(self.treeViewHeadings)):

		# Special treatment for the Expand/Collapse function
		self.treeView.heading("#0", text="Expand/Collapse")					

		for c in range(len(treeViewHeadings)):
#			self.treeView.heading(STR(c+1), text=self.treeViewHeadings[c])
			self.treeView.heading(STR(c+1), text=treeViewHeadings[c])
			
		self.treeView['show'] = 'tree headings'				# Shows both the Tree icon and the Headings
#		self.treeView['show'] = 'headings'					# Hides the Expand/Collapse icon


		################################
		# Sixth Row widgets
		################################
		
		col = 0
		colSpan = 2
		self.toggleDebugButton.grid(row=5, column=col, columnspan=colSpan, sticky=tk.W) 
#		self.toggleRunOrClearDemoButton.grid(row=5, column=col, columnspan=colSpan, sticky=tk.W) 
		col = col + colSpan
		colSpan = 4
		'''
		self.toggleStructEndPaddingButton.grid(row=5, column=col, columnspan=colSpan, sticky=tk.W) 
		col = col + colSpan
		colSpan = 4
		'''
		self.toggleMapTypedefsTooButton.grid(row=5, column=col, columnspan=colSpan, sticky=tk.W) 
		
		
		self.frame.grid(row=0, column=0, sticky=tk.NSEW)

	def printCoordinates(self, eventOrigin):
		x = eventOrigin.x
		y = eventOrigin.y
		PRINT ("INFORMATION: Mouse click happened on Interpreted code window with pixel coordinates (x=",x,",y=",y,")" )
		currentCoordinates = self.interpretedCodeText.index(tk.CURRENT)
		PRINT ("Line.char currentCoordinates of last Mouse click =",currentCoordinates )

	def displayDataWindowFromOffset(self, newFileOffset):
		if newFileOffset < 0 or newFileOffset >= dataFileSizeInBytes:
			return
		
		# When we change the displayed data window, which all Interpreted Code Window variables will get highlighted (based on cursor movement)
		# also changes. Hence, first we need to remove all those transient color tags.
		PRINT("interpretedCodeVariablesHighlightedStartEndCoordinates =",self.interpretedCodeVariablesHighlightedStartEndCoordinates)
		for item in self.interpretedCodeVariablesHighlightedStartEndCoordinates:
			codeVarStart = item[0]
			codeVarEnd = item[1]
			self.interpretedCodeText.tag_remove("yellowbg", codeVarStart, codeVarEnd)
			
		currentWindowBaseNewValue = newFileOffset
		PRINT("Now going to set self.OK2reDisplayDataWindows = False")
		self.OK2reDisplayDataWindows = False
		self.fileOffsetSpinbox.delete(0,"end")
		PRINT("Now going to set self.OK2reDisplayDataWindows = True")
		self.OK2reDisplayDataWindows = True
		self.fileOffsetSpinbox.insert(0,currentWindowBaseNewValue)
		PRINT("After updating the self.fileOffsetSpinbox, self.fileOffsetSpinbox.get() =",self.fileOffsetSpinbox.get())
		if currentWindowBaseNewValue != int(self.fileOffsetSpinbox.get()):
			OUTPUT("ERROR - tried to set the offsetSpinbox to",currentWindowBaseNewValue,"but after the pasting, the value is",self.fileOffsetSpinbox.get())
		return

	# Find the line anchor that shows maximum number of variables corresponding to a data item in Hex or Ascii window
	def findLineAnchorForDoubleClickHexOrAscii(self, eventOrigin, HexOrAscii):
		if HexOrAscii == "Hex":
			widthPerByte = 3
			currentCoordinates = self.viewDataHexText.index(tk.CURRENT)
		elif HexOrAscii == "Ascii":
			widthPerByte = 1
			currentCoordinates = self.viewDataAsciiText.index(tk.CURRENT)
		else:
			OUTPUT("Invalid value of HexOrAscii =",STR(HexOrAscii))
			sys.exit()
		x = eventOrigin.x
		y = eventOrigin.y
		PRINT ("INFORMATION: Double click happened on", HexOrAscii,"window with pixel coordinates (x=",x,",y=",y,")" )
		PRINT ("Line.char currentCoordinates of last Mouse Double click in", HexOrAscii, "data window =",currentCoordinates )

		doubleClickLocationLineNum = int(currentCoordinates.split(".")[0])-1	# Remember that in Text widget the line # starts from 1, not 0
		doubleClickLocationCharNum = int(currentCoordinates.split(".")[1])
		
		if (0 <= doubleClickLocationLineNum < DISPLAY_BLOCK_HEIGHT) and (0 <= doubleClickLocationCharNum < DISPLAY_BLOCK_WIDTH*widthPerByte):
			PRINT("The double-click location at line #",doubleClickLocationLineNum,"and char #",doubleClickLocationCharNum,"is valid")
		else:
			errorMessage = "The double-click location at line #" + STR(doubleClickLocationLineNum) + "and char # "+ STR(doubleClickLocationCharNum) + " is invalid"
			errorRoutine(errorMessage)
			return False
			
		# From here, find the file Offset of the click location
		fileOffsetOfDoubleClickedLocation = fileDisplayOffset + doubleClickLocationLineNum * DISPLAY_BLOCK_WIDTH + integerDivision(doubleClickLocationCharNum,widthPerByte)
		PRINT("The double-click location at line #",doubleClickLocationLineNum,"and char #",doubleClickLocationCharNum,"corresponds to file offset of",fileOffsetOfDoubleClickedLocation)
		if not (fileDisplayOffset <= fileOffsetOfDoubleClickedLocation < fileDisplayOffset+BLOCK_SIZE):
			errorMessage = "The double-click location at line #" + STR(doubleClickLocationLineNum) + "and char # "+ STR(doubleClickLocationCharNum) + " is invalid because its corresponding file offset ("+STR(fileOffsetOfDoubleClickedLocation)+") is outside the file display range <"+STR(fileDisplayOffset)+","+STR(fileDisplayOffset+BLOCK_SIZE-1)+">"
			errorRoutine(errorMessage)
			return False
		
		# Now find out which all variables map to this fileOffsetOfDoubleClickedLocation
		variableIdsForThisDataLocation = []
		lineNumsForVariablesForThisDataLocation = []
		for item in coloredVarsIdOffsetSize:
			if item[1] <= fileOffsetOfDoubleClickedLocation < item[1]+item[2]:
				tokenStartLineNum = gTokenLocationLinesChars[variableDeclarations[item[0]][4]["globalTokenListIndex"]][0][0]
				variableName = variableDeclarations[item[0]][0]
				PRINT("variable",variableName,", which starts at line #",tokenStartLineNum,"map to this double-clicked data location")
				variableIdsForThisDataLocation.append(item[0])
				lineNumsForVariablesForThisDataLocation.append(tokenStartLineNum)

		lineNumsForVariablesForThisDataLocation.sort()
		PRINT("lineNumsForVariablesForThisDataLocation =\n")
		for item in lineNumsForVariablesForThisDataLocation:
			PRINT(item)
		# Find out the optimum window of displaying the mapped variables
		if not lineNumsForVariablesForThisDataLocation:
			return
		elif len(lineNumsForVariablesForThisDataLocation) == 1:
			PRINT("A single variable correspond to the data - no need to find out the optimum location")
			lineToAnchor = lineNumsForVariablesForThisDataLocation[0]
		else:
			# Here, when we use the term "variable", we only count those variables that correspond to the data location that has been double-clicked.
			# Here is the logic that we implement. if there is a single variable, we will show that.
			# However, if there are multiple variables that point to the same double-clicked data, then We want to maximize the number of such variables.
			# The problem is that, all these variables may not fit in the Interpreted code window, which can only show DISPLAY_BLOCK_HEIGHT lines at a time.
			# Hence, for every such variable, we try to find out if we start to show from that variable, how many other such variables we can also show.
			# Once we get this count, the highest guy wins. 
			# However, that still leaves the problem that there might be multiple such variables with identical show-count.
			# In such cases, to break the tie, we use the following criteria. We try to see whichever variable gives us the most "centered" feel.
			# Basically, we should try to have similar number of non-shown variables both BEFORE and AFTER the shown Interpreted window.
			PRINT("Many variables correspond to the double-clicked data - need to find out the optimum location")
			tab = []	# This table holds 4 entries < baseLine#, # non-visible variables before this window, # variables shown, # non-visible variables after this window>
			for i in range(len(lineNumsForVariablesForThisDataLocation)):
				baseLineNum = lineNumsForVariablesForThisDataLocation[i]
				#i is the number of variables missed before the window if we are starting to show from ith row of lineNumsForVariablesForThisDataLocation
				nonVisibleCountBeforeWindow = i
				visibleCount = 0
				nonVisibleCountAfterWindow = 0
				lastVisibleVariableLineNumForThisBaseLineNum = baseLineNum
				for j in range(len(lineNumsForVariablesForThisDataLocation[i+1:])):
					lineNum = lineNumsForVariablesForThisDataLocation[i+1+j]
					if lineNum < baseLineNum + DISPLAY_BLOCK_HEIGHT:
						visibleCount += 1
						lastVisibleVariableLineNumForThisBaseLineNum = lineNum
					else:
						nonVisibleCountAfterWindow += 1
				tab.append([baseLineNum, lastVisibleVariableLineNumForThisBaseLineNum, nonVisibleCountBeforeWindow, visibleCount, nonVisibleCountAfterWindow]) 
			# The -abs(x[2]-x[4]) term represents the assymetry between the before and after missed
			sortedTab = sorted(tab, key=lambda x: (x[3],-abs(x[2]-x[4])), reverse=True)
			PRINT("Unsorted tab = ",tab)
			PRINT("Sorted tab = ",sortedTab)
			lineToAnchor = integerDivision(sortedTab[0][0]+sortedTab[0][1],2)
			
		PRINT("Going to anchor line #",lineToAnchor)
		self.interpretedCodeText.see(STR(lineToAnchor+1)+".0")		# Here the screen line # starts from 1, not 0

	# When someone double-clicks on a colored data item, scroll the Interpreted code window to the place that maximizes the variables that correspond to that data
	def doubleClickAscii(self, eventOrigin):
		# If no variables have been mapped to some data, no use of this routine
		if not variableSelectedIndices or not coloredVarsIdOffsetSize:
			return
		if dataFileName == None or dataFileName == "" or not dataFileSizeInBytes:
			return
		
		self.findLineAnchorForDoubleClickHexOrAscii(eventOrigin, "Ascii")


	# When someone double-clicks on a colored data item, scroll the Interpreted code window to the place that maximizes the variables that correspond to that data
	def doubleClickHex(self, eventOrigin):
		# If no variables have been mapped to some data, no use of this routine
		if not variableSelectedIndices or not coloredVarsIdOffsetSize:
			return
		if dataFileName == None or dataFileName == "" or not dataFileSizeInBytes:
			return
		
		self.findLineAnchorForDoubleClickHexOrAscii(eventOrigin, "Hex")
		
	def doubleClickInterpreted(self, eventOrigin):
		# If no variables have been mapped to some data, no use of this routine
		if not variableSelectedIndices or not coloredVarsIdOffsetSize:
			return
		if dataFileName == None or dataFileName == "" or not dataFileSizeInBytes:
			return
			
		x = eventOrigin.x
		y = eventOrigin.y
		PRINT ("INFORMATION: Double click happened on Interpreted code window with pixel coordinates (x=",x,",y=",y,")" )
		currentCoordinates = self.interpretedCodeText.index(tk.CURRENT)
		PRINT ("Line.char currentCoordinates of last Mouse Double click in the Interpreted code window =",currentCoordinates )

		doubleClickLocationLineNum = int(currentCoordinates.split(".")[0])-1	# Remember that in Text widget the line # starts from 1, not 0
		doubleClickLocationCharNum = int(currentCoordinates.split(".")[1])
		
		# Find index of the token on which the double-click happened. Remember that it need not be a token - it could be some whitespace too.
		# Also, it is possible that multiple tokens will get selected because there is no whitespace between them.
		doubleClickLocationTokenIndex = -100000
		doubleClickedTokenIndices = []
		i = 0
		for i in range(len(gTokenLocationLinesChars)):
			if ((gTokenLocationLinesChars[i][0][0] <= doubleClickLocationLineNum <= gTokenLocationLinesChars[i][1][0]) and
				(gTokenLocationLinesChars[i][0][1] <= doubleClickLocationCharNum <= gTokenLocationLinesChars[i][1][1])):
				doubleClickedTokenIndices.append(i)
		if not doubleClickedTokenIndices:
			PRINT("The user has NOT double-clicked on any token")
			return True
		else:	
			# The user has indeed clicked on a token(s) (not space), but that may or may not be a variable.
			PRINT("The user has double-clicked on the following token indices =",doubleClickedTokenIndices)
			doubleClickedVariableIndices = []
			for doubleClickLocationTokenIndex in doubleClickedTokenIndices:
				k = 0
				while k in range(len(variableDeclarations)):
					item = variableDeclarations[k]
					if variableDeclarations[k][4]["variableId"] != k:
						errorMessage = "ERROR - wrong value of variableId - exiting"
						errorRoutine(errorMessage)
						return False
					elif (doubleClickLocationTokenIndex == item[4]["globalTokenListIndex"]):
						doubleClickedVariableIndices.append(k)
					k += 1
			
			if not doubleClickedVariableIndices:
				PRINT("Unfortunately, none of the tokens is a variable")
				return True
			else:
				doubleClickedSelectedVariableIndices = []	# The subset of doubleClickedVariableIndices, which are also mapped
				for doubleClickLocationVariableIndex in doubleClickedVariableIndices:
					# The user has indeed clicked on a variable, but that may or may not be selected for mapping.
					doubleClickLocationVariableName = variableDeclarations[doubleClickLocationVariableIndex][0]
					PRINT("The user clicked on a token which happens to be a variable <",doubleClickLocationVariableName,"> with variable index =",doubleClickLocationVariableIndex)
					if doubleClickLocationVariableIndex not in variableSelectedIndices:
						PRINT("Unfortunately, the variable",doubleClickLocationVariableName,"is not in variableSelectedIndices")
						PRINT("\nvariableSelectedIndices =",variableSelectedIndices)
					else:
						PRINT("Fortunately, token # ",doubleClickLocationTokenIndex,"which corresponds to",doubleClickLocationVariableIndex,"is indeed in variableSelectedIndices")
						doubleClickedSelectedVariableIndices.append(doubleClickLocationVariableIndex)

				if not doubleClickedSelectedVariableIndices:
					PRINT("Unfortunately, none of the variables",doubleClickedVariableIndices,"is not in variableSelectedIndices")
					return
				else:
					#if we have multiple candidates, choose the first one
					doubleClickLocationVariableIndex = doubleClickedSelectedVariableIndices[0]
					
					# Now find its absolute (NOT relative) offset and size
					itemFound = False
					for item in coloredVarsIdOffsetSize:	# We do not know which order the coloredVarsIdOffsetSize is sorted, hence need to find it
						if item[0] == doubleClickLocationVariableIndex:
							variableOffset =     item[1]	# Absolute value, not relative to dataLocationOffset
							variablelength =     item[2]
							selectedVariable = variableDeclarations[doubleClickLocationVariableIndex]
							itemFound = True
							break;
					if not itemFound:
						errorMessage("ERROR - Could not find the entry for variable id =",doubleClickLocationVariableIndex)
						errorRoutine(errorMessage)
						return False
					else:
						absoluteStart       = variableOffset
						absoluteEndExcluded = variableOffset + variablelength
						
						PRINT("Variable id =",doubleClickLocationVariableIndex,"has size",variablelength,", starts from relative offset of",HEX(variableOffset),"from dataLocationOffset =",HEX(dataLocationOffset))
						PRINT("Which means it starts from byte #",HEX(absoluteStart),"(included) and ends at byte #",HEX(absoluteEndExcluded),"(excluded)")
						
						currentWindowBaseOldValue = int(self.fileOffsetSpinbox.get())


						# If the variable is already being displayed, do nothing
						if variablelength >= BLOCK_SIZE:
							PRINT("Maximizing its display")
							currentWindowBaseNewValue = absoluteStart
						else:
							PRINT("Attempting to display the variable as close to the middle as possible")
							# Try to display the variable about right in the middle of the data display window
							currentWindowBaseNewValue = absoluteStart + integerDivision(variablelength,2)-integerDivision(BLOCK_SIZE,2)
							currentWindowBaseNewValue = 0 if currentWindowBaseNewValue < 0 else currentWindowBaseNewValue
							PRINT("The Display window needs to be redisplayed from byte #",HEX(currentWindowBaseNewValue),"to show the variable",HEX(doubleClickLocationVariableName),"right in the middle")
				
						if currentWindowBaseNewValue == currentWindowBaseOldValue:
							PRINT("No need to re-display")
							return
						else:
							PRINT("Going to re-display")
							PRINT("After redisplay, currentWindowBaseNewValue =",HEX(currentWindowBaseNewValue))
							self.displayDataWindowFromOffset(currentWindowBaseNewValue)
							return True
		

	# Anytime self.fileOffset changes, this gets called directly.
	# Anytime self.dataOffset changes, this gets called indirectly (via dataOffsetChange).
	def fileOffsetChange(self, *args):
		global fileDisplayOffset
		
		if self.OK2reDisplayDataWindows == False:
			PRINT("self.OK2reDisplayDataWindows is False - returning from fileOffsetChange()")
			return
		
		PRINT("Updating fileDisplayOffset to self.fileOffset.get() =",self.fileOffset.get())
		fileDisplayOffset = self.fileOffset.get()
			
		PRINT("Inside fileOffsetChange(), going to call self.updateDisplayBlock()")
		self.updateDisplayBlock()
		PRINT("Inside fileOffsetChange(), came back after calling self.updateDisplayBlock()")
		if coloredVarsIdOffsetSize:
			self.performInterpretedCodeColoring()
			self.displayAndColorDataWindows()
		else:
			self.displayAndColorDataWindows()

	# Anytime self.dataOffset changes, this gets called directly.
	# Now, when the data offset changes, if there is dynamic code, the code itself (and resultingly coloredVarsIdOffsetSize) will change too.
	def dataOffsetChange(self, *args):
		global dataLocationOffset
		PRINT("Previous value of dataLocationOffset =",dataLocationOffset)
		dataLocationOffset = self.dataOffset.get()
		PRINT("Current value of dataLocationOffset =",dataLocationOffset)
		
		if coloredVarsIdOffsetSize:	# Without this, it will even try to calculate the coloredVarsIdOffsetSize for a Interpreted Code window where nothing has been selected
			PRINT("\n\nCalling calculateColoredVarsIdOffsetSize() from dataOffsetChange()\n")
			self.calculateColoredVarsIdOffsetSize()
			PRINT("\n\nCalling fileOffsetChange() from dataOffsetChange()\n")
			self.fileOffsetChange()
			PRINT("\n\nCalling displayBottomTreeWindow() from dataOffsetChange()\n")
			self.displayBottomTreeWindow()
		
	def dataPageUp(self, *args):
		if dataFileName == None or dataFileName == "" or not dataFileSizeInBytes:
			return
		PRINT("Page Up")
		currentWindowBaseOldValue = int(self.fileOffsetSpinbox.get())
		PRINT("Current self.fileOffsetSpinbox.get() =",currentWindowBaseOldValue)
		currentWindowBaseNewValue = currentWindowBaseOldValue - BLOCK_SIZE if currentWindowBaseOldValue - BLOCK_SIZE >= 0 else 0
		PRINT("After Page Up, currentWindowBaseNewValue =",currentWindowBaseNewValue)
		self.displayDataWindowFromOffset(currentWindowBaseNewValue)
		return True
		
	def dataPageDown(self, *args):
		if dataFileName == None or dataFileName == "" or not dataFileSizeInBytes:
			return
		PRINT("Page Down")
		currentWindowBaseOldValue = int(self.fileOffsetSpinbox.get())
		PRINT("Current self.fileOffsetSpinbox.get() =",currentWindowBaseOldValue)
		currentWindowBaseNewValue = currentWindowBaseOldValue+BLOCK_SIZE if currentWindowBaseOldValue+BLOCK_SIZE <= dataFileSizeInBytes-1 else dataFileSizeInBytes - BLOCK_SIZE
		PRINT("After Page Down, setting currentWindowBaseNewValue =",currentWindowBaseNewValue)
		self.displayDataWindowFromOffset(currentWindowBaseNewValue)
		return True
		
	def create_bindings(self):
		for keypress in ("<Control-o>", "<Alt-o>"):
			self.parent.bind(keypress, self.openDataFileDialogue)
		for keypress in ("<Control-q>", "<Alt-q>", "<Escape>"):
			self.parent.bind(keypress, self.quit)
		self.parent.bind("<Alt-f>", lambda *args: self.fileOffsetSpinbox.focus())
		self.interpretedCodeText.bind("<Button 1>",self.printCoordinates)
		
		self.interpretedCodeText.bind("<Double 1>",self.doubleClickInterpreted)	 
		self.viewDataHexText.bind("<Double 1>",self.doubleClickHex)	 
		self.viewDataAsciiText.bind("<Double 1>",self.doubleClickAscii)	 
		
		# When the data offset changes, the unraveled data should also change
		for variable in (self.dataOffset,):
			variable.trace_variable("w", self.dataOffsetChange)
			
		# When the file offset changes, the unraveled data should NOT change
		for variable in (self.fileOffset,):
			variable.trace_variable("w", self.fileOffsetChange)
		
		self.addressColumnText.bind("<Prior>",self.dataPageUp)
		self.viewDataHexText.bind("<Prior>",self.dataPageUp)
		self.viewDataAsciiText.bind("<Prior>",self.dataPageUp)

		self.addressColumnText.bind("<Next>",self.dataPageDown)
		self.viewDataHexText.bind("<Next>",self.dataPageDown)
		self.viewDataAsciiText.bind("<Next>",self.dataPageDown)
		

	############################################################################################################################################################
	# This function returns the start and end <LINE#.CHAR#> strings of a data byte range in the Hex and ASCII windows (recall that LINE# starts from 1, not 0)
	############################################################################################################################################################
	def getDataCoordinates(self, dataByteStartOffset, dataByteEndOffsetExclusive):
		# These two offsets below describe the displayed window range (has nothing to do with the specific data)
		# The Pythonic way: "START" is included, "END" is not included
		firstByteDisplayedOffset = fileDisplayOffset	# The file offset of first byte displayed on the window
		lastByteDisplayedOffsetPlusOne = fileDisplayOffset + BLOCK_SIZE	# The file offset of first byte after firstByteDisplayedOffset NOT displayed on the window
																
		# TO-DO: Possible bug: Should it not be dataByteStartOffset >= dataByteEndOffsetExclusive?	That might create problems for 0-length data like functions, though
		if dataByteStartOffset > dataByteEndOffsetExclusive:	
			errorMessage = "ERROR in getDataCoordinates(): dataByteStartOffset = " + str(dataByteStartOffset) + " is greater than dataByteEndOffsetExclusive = " + str(dataByteEndOffsetExclusive)+" !!!"
			errorRoutine(errorMessage)
			return False
#		elif dataByteStartOffset < firstByteDisplayedOffset and dataByteEndOffsetExclusive > lastByteDisplayedOffsetPlusOne:		# BUG? I think this is wrong
		elif dataByteEndOffsetExclusive < firstByteDisplayedOffset or  dataByteStartOffset >= lastByteDisplayedOffsetPlusOne:
			errorMessage = "ERROR in getDataCoordinates(): Input byte <start,end> pair = <"+STR(dataByteStartOffset)+", "+ STR(dataByteEndOffsetExclusive)+"> is outside the display window <"+STR(firstByteDisplayedOffset)+", "+STR(lastByteDisplayedOffsetPlusOne)+"(excluded)>"
			PRINT(errorMessage)	# Observe that we are not flagging errorRoutine(errorMessage), since that would trigger an error message for many non-error conditions
			return False	# TO-DO: Should we change it to False or blank?
		
		PRINT ("Data byte range <",dataByteStartOffset, ",", dataByteEndOffsetExclusive,"> is displayable within current display window of <",firstByteDisplayedOffset,",", lastByteDisplayedOffsetPlusOne,"(excluded)>")

		# We find out which part of the supplied data range is actually being displayed in the current data display window.
		startOffset = firstByteDisplayedOffset if dataByteStartOffset < firstByteDisplayedOffset else dataByteStartOffset
		endOffsetExclusive = lastByteDisplayedOffsetPlusOne if dataByteEndOffsetExclusive > lastByteDisplayedOffsetPlusOne else dataByteEndOffsetExclusive
		

		# Find the start and end location in the Hex and Ascii Windows. Remeber, conforming to the Pythonic way, the Start coordinate is included, the End coordiate is not
		startLineNum = integerDivision((startOffset-firstByteDisplayedOffset),DISPLAY_BLOCK_WIDTH)
		startCharNumAscii = (startOffset-firstByteDisplayedOffset)%DISPLAY_BLOCK_WIDTH
		startCharNumHex = startCharNumAscii * 3
		endLineNum = integerDivision((endOffsetExclusive-firstByteDisplayedOffset),DISPLAY_BLOCK_WIDTH)
		endCharNumAscii = (endOffsetExclusive-firstByteDisplayedOffset)%DISPLAY_BLOCK_WIDTH
		endCharNumHex = endCharNumAscii * 3 
		startStrHex = str(startLineNum+1) + "." + str(startCharNumHex)			# Recall that on Text line number starts from 1, not 0
		endStrHex = str(endLineNum+1) + "." + str(endCharNumHex)				# Recall that on Text line number starts from 1, not 0
		startStrAscii = str(startLineNum+1) + "." + str(startCharNumAscii)		# Recall that on Text line number starts from 1, not 0
		endStrAscii = str(endLineNum+1) + "." + str(endCharNumAscii)			# Recall that on Text line number starts from 1, not 0
		PRINT ("Hex coordinates are",startStrHex,"(inlcuded) and ends at", endStrHex,"(NOT inlcuded)" )
		PRINT ("Ascii coordinates are",startStrAscii,"(inlcuded) and ends at", endStrAscii,"(NOT inlcuded)" )
		return [[startStrHex,endStrHex],[startStrAscii,endStrAscii]]


	############################################################################################################################
	# The setDataOffsetToZeroIfBlank() sets the dataOffset.
	############################################################################################################################
	def setDataOffsetToZeroIfBlank(self):
		PRINT("Entered setDataOffsetToZeroIfBlank(), currently self.fileOffset = ",self.fileOffset.get(), "self.dataOffset = ",self.dataOffset.get())
		# If dataLocationOffsetEntryVariable is blank, set it to zero
		PRINT("Inside setDataOffsetToZeroIfBlank(), going to zeroize self.dataOffset if blank")
		try:
			PRINT("Inside setDataOffsetToZeroIfBlank(), currently self.dataOffset.get() = <",self.dataOffset.get(),">")
			if STR(self.dataOffset.get()).strip() == '':
				PRINT ("WARNING - Blank self.dataOffset!!" )
				PRINT("Inside setDataOffsetToZeroIfBlank(), currently self.dataOffset.get() = <",self.dataOffset.get(),"> going to perform self.dataOffset.set(0)")
				self.dataOffset.set(0)
				PRINT("Inside setDataOffsetToZeroIfBlank(), just performed self.dataOffset.set(0), now self.dataOffset.get() =",self.dataOffset.get())
		except ValueError: 
			PRINT ("WARNING - Blank self.dataOffset - setting it to 0!!" )
			PRINT("Inside setDataOffsetToZeroIfBlank(), going to perform self.dataOffset.set(0) for ValueError")
			self.dataOffset.set(0)
			PRINT("Inside setDataOffsetToZeroIfBlank(), just performed self.dataOffset.set(0) for ValueError")
			PRINT("Inside setDataOffsetToZeroIfBlank(), zeroized self.dataOffset if it was blank")


	############################################################################################################################
	# The updateDataBlock() populates a global variable-size dataBlock variable. It does not return the dataBlock.
	############################################################################################################################
	def updateDataBlock(self):
		global dataBlock
		if dataFileName == None or dataFileName == "":
			return False

		self.setDataOffsetToZeroIfBlank()
		
		dataBlock = readBytesFromFile(dataLocationOffset, totalBytesToReadFromDataFile)

	############################################################################################################################
	# The updateDisplayBlock() populates a global fixed-size displayBlock variable. It does not return the displayBlock.
	############################################################################################################################
	def updateDisplayBlock(self):
		global displayBlock
		if (dataFileName == "") or (dataFileName == None):
			return False

		PRINT("Entered updateDisplayBlock(), currently self.fileOffset = ",self.fileOffset.get(), "self.dataOffset = ",self.dataOffset.get())
			
		# If dataFileOffset is blank, set it to zero
		PRINT("Inside updateDisplayBlock(), going to zeroize self.fileOffset if blank")
		try:
			PRINT("Inside updateDisplayBlock(), currently self.fileOffset.get() = <",self.fileOffset.get(),">")
			if STR(self.fileOffset.get()).strip() == '':
#				if not self.fileOffset.get():	# <==== HUGE BUG! DO not use this. Keeping this to warn you.
				PRINT ("WARNING - Blank self.fileOffset!!" )
				PRINT("Inside updateDisplayBlock(), currently self.fileOffset.get() = <",self.fileOffset.get(),">. Now going to perform self.fileOffset.set(0)")
				self.fileOffset.set(0)
				PRINT("Inside updateDisplayBlock(), just performed self.fileOffset.set(0), now self.fileOffset.get()", self.fileOffset.get())
		except ValueError: 
			PRINT ("WARNING - Blank self.fileOffset - setting it to 0!!" )
			PRINT("Inside updateDisplayBlock(), going to perform self.fileOffset.set(0) for ValueError")
			self.fileOffset.set(0)
			PRINT("Inside updateDisplayBlock(), just performed self.fileOffset.set(0) for ValueError")
		PRINT("Inside updateDisplayBlock(), zeroized self.fileOffset if it was blank")
		
#		displayBlock = readBytesFromFile(fileDisplayOffset, BLOCK_SIZE)			# MANNA_MANNA
		displayBlock = readBytesFromFile(fileDisplayOffset, max(0, min(dataFileSizeInBytes-fileDisplayOffset,BLOCK_SIZE)))
			
		PRINT("Leaving updateDisplayBlock(), currently self.fileOffset = ",self.fileOffset.get(), "self.dataOffset = ",self.dataOffset.get())
				
		return True	

	###############################################################################################################################
	# Displays the Data Window (Address, Hex, ASCII) with the data. FG Colors the Hex and ASCII windows. 
	# We know that performInterpretedCodeColoring() already does the FG coloring of the Data windows. The reason we are re-doing
	# the FG coloring here (via calling showIndividualLineWithFGcolor() at the beginning) is because we might have people simply
	# doing PgUp/PgDn on the Data windows without doing anything else. In which cases, we need a way to FG color the Data windows
	# without invoking the performInterpretedCodeColoring() again and again.
	# Also adds transient tags on Code window based on cursor movements in the Data windows.
	###############################################################################################################################

	def displayAndColorDataWindows(self, *args):
		
		if dataFileName == None or dataFileName == "":
			return False

		PRINT("\nEntered displayAndColorDataWindows()")

		# There is a subtle differnce between how the Interpreted Code window and the Data windows are displayed. For Interpreted code window, the whole code is pasted 
		# inside the window, irrespective of how big the code size is (we use scrollbars to go up or down). So, there is no question of re-pasting the Code, even if
		# the data offset or data file itself changes. The only thing that changes are the colors (depends on the data). That is why there is "display" in the routine
		# performInterpretedCodeColoring() - the code is already displayed, it just does the coloring. In contrast, for the Data window, we need to fetch and display
		# the data first. That being said, there is a twist on how we do it.
		#
		# For the Data window, we could easily be dealing with a 5GB data file. Hence, we designed our program to NOT to load the whole of the datafile to memory.
		# We only fetch the specific data that can fit wtihin the display window (Hex or ASCII). We call this fixed-size data block as displayData[], and it changes every
		# time the fileOffset changes (e.g. when we do a PgUp/PgDn). So, we need to retrieve this displayData every time, and then print it in the Hex and ASCII windows.
		# And upto this point it is just like any other ordinary Hex viewer - it is ablivious to the Interpreted Code (doesn't matter if there is none).
		
		# After that, depending on the Interpreted code and selected variables, we will have to color this displayed data.
		
		# We start by wiping the slate clean.
		self.addressColumnText.delete("1.0", "end")
		self.viewDataHexText.delete("1.0", "end")
		self.viewDataAsciiText.delete("1.0", "end")
		
		# When we change the fileOffset via PgUp/PgDn, a new block of data gets displayed on the Data window.
		# Now, suppose the cursor was in the Hex or ASCII window. If it was hovering over a mapped variable, then the corresponding variable in the 
		# interpreted Code window was also getting highlighted via a transient yellowbg tag. When you pressed the PgUp or PgDn via the keyboard,
		# your cursor now hovers over a different part of the data block that is exactly BLOCK_SIZE away, and chances that the the data corresponding to the 
		# new position of the cursor corresponds to the exact same variable is very low (unless the variable is a big array or structure whose data spans over
		# multiple data display blocks. Hence, whenever we do a PgUp/PgDn, we need to clear all the transient yellowbg tags from the Interpreted Code window first.
		# (This problem does not exist if we click on the Spinbox or Data Offset box and explicitly enter the data offset there. Because then the cursor will
		# NOT be hovering on the data (because it will hover over the spinbox or data offset), so no variable in the Interpreted Code window will get highlighted anyway.
		self.interpretedCodeVariablesHighlightedStartEndCoordinates = []
		
		PRINT("Inside displayAndColorDataWindows(), deleted Address/Hex/Ascii windows")
		
		PRINT ("\n"*3,"=="*50,"\n Inside displayAndColorDataWindows(), for data Offset =",dataLocationOffset,"File Offset =",fileDisplayOffset,"\n","=="*50,"\n"*3)

		# this merely updates the block of data (that eventually gets displayed, but not by this routine)
		self.updateDisplayBlock() # The updateDisplayBlock() populates a global fixed-size displayBlock variable. It does not return the displayBlock.

		
		# Populate the Address column
		
		startAddress = fileDisplayOffset
		for rowNum in range(DISPLAY_BLOCK_HEIGHT):
			address = startAddress + rowNum * DISPLAY_BLOCK_WIDTH
			addressStr = "0x{:010X} ".format(address)+ ("\n" if rowNum < DISPLAY_BLOCK_HEIGHT-1 else "")
			printAddress = str(rowNum+1)+"."+"0"
			PRINT ("Row ",rowNum,". Address = ",addressStr )
			self.addressColumnText.insert("end",addressStr)

		# Populate the Display window row by row, and add only the foreground color tags (no BG color tags)
		
		rows = [displayBlock[i:i + DISPLAY_BLOCK_WIDTH] for i in range(0, len(displayBlock), DISPLAY_BLOCK_WIDTH)]
		
		if len(rows) > DISPLAY_BLOCK_HEIGHT:
			PRINT("ERROR in displayAndColorDataWindows() - len(rows) =", len(rows), ", which is  > DISPLAY_BLOCK_HEIGHT =", DISPLAY_BLOCK_HEIGHT)
			sys.exit()
			
		for rowNum in range(len(rows)):
			row = rows[rowNum]
			rowStartOffset =  DISPLAY_BLOCK_WIDTH * rowNum
			fileOffset = fileDisplayOffset + rowStartOffset
			PRINT ("Now printing row #", rowNum, "starting from original offset",fileDisplayOffset," + current Offset ", rowStartOffset," = fileOffset",fileOffset )
			
			# Below we print a row for both Hex and Ascii windows with foreground color. No background color yet.
#			self.showIndividualLineWithFGcolor(row,fileOffset)	
			
			# The input is one line (or row) of the Data window (the treatment is the same for both Hex and ASCII windows). Then we iterate over each byte of this line (or row). 
			# For each byte, we iterate over the individual items of coloredVarsIdOffsetSize[]. Recall that each row in coloredVarsIdOffsetSize[] corresponds to a variable
			# in the Interpreted code window, based on the selection made by the user (not every variable in the Interpreted code gets mapped, of course).
			# Not only that, there might be multiple rows in coloredVarsIdOffsetSize[] for a single mapped variable. This can happen because if you see the example below, 
			# there will be 5 different rows corresponding to the same variable i.
			# 
			#  	struct S { int i;} structVar[5];
			#
			# Also remember that coloredVarsIdOffsetSize[] is sorted based on size, from biggest to smallest. And for every byte in the supplied input line, we iterate over
			# each of the rows in coloredVarsIdOffsetSize[], from biggest size to the smallest. If we see that the coloredVarsIdOffsetSize[] row applies to the byte,
			# then we apply the correspondiong tag, which only applies the FOREGROUND color, NOT the background one. And since we apply from the largest size to the smallest,
			# we ensure that smallest variables gets the priority over the large structs, setting for more granular viewing.
			
			for i in range(len(row)):
				tags = ()
				byte = row[i] 
				byteFileOffset = fileOffset + i
				
				# TO=DO: Why are we doing the FG coloring here, since we know that performInterpretedCodeColoring() does the FG coloring for both the Code and Data windows anyway?
				
				if coloredVarsIdOffsetSize and (dataLocationOffset <= byteFileOffset < dataLocationOffset+totalBytesToReadFromDataFile):	# This is data to be colored differently
					tagIndex = -1 		# Default Error value
					for j in range(len(coloredVarsIdOffsetSize)):
						if coloredVarsIdOffsetSize[j][1] <= byteFileOffset < coloredVarsIdOffsetSize[j][1]+coloredVarsIdOffsetSize[j][2]:	# This is data to be colored differently
							tagIndex = j	# In case multiple tags match, only the latest (smallest sized) will win by overwriting others
					if tagIndex == -1 and COMPILER_PADDING_ON == False:	# The only way we get a non-coloring within a colored window is when we add compiler paddings
						for item in coloredVarsIdOffsetSize:	
							OUTPUT(variableDeclarations[item[0]][0],"<",item[1],",",item[1]+item[2],"> (length", item[2],") <start (inclusive), end (not inclusive)>")
						OUTPUT("dataLocationOffset =",dataLocationOffset, ", fileOffset =",fileOffset,", i =",i,", byteFileOffset =",byteFileOffset, ", totalBytesToReadFromDataFile =",totalBytesToReadFromDataFile,", dataLocationOffset+totalBytesToReadFromDataFile =",dataLocationOffset+totalBytesToReadFromDataFile)
						OUTPUT("\ncoloredVarsIdOffsetSize =",coloredVarsIdOffsetSize,"\n")
						errorMessage = "ERROR in displayAndColorDataWindows() for char # %d in current row (overall %d-th byte of file) - Invalid tag, exiting"%(i,byteFileOffset)
						errorRoutine(errorMessage)
						return False
					else:
						try:
							tags = (self.colorTagsFG[tagIndex],)	# Why is this line NOT getting invalidated by the later statement (now commented out) ===>    tags = ()
						except IndexError:
							errorMessage = "Inside displayAndColorDataWindows(), byte = <"+STR(byte)+"> is causing IndexError for tagIndex = "+STR(tagIndex)+" currently self.colorTagsFG= "+STR(self.colorTagsFG)
							errorRoutine(errorMessage)
							dumpDetailsForDebug()

				if ((0x20 <= ORD(byte) <= 0x7E) or (0x80 <= ORD(byte) <= 0xFE)):
					byteToPrint = byte
				else:
					byteToPrint = "."
				try:
	#				tags = ()	# Why is this line NOT invalidating the previous statement ===>    tags = (self.colorTagsFG[tagIndex],)
					self.viewDataHexText.insert("end", "{:02X}".format(ORD(byte)), tags)
					self.viewDataAsciiText.insert("end", chr(ORD(byteToPrint)), tags)
				except ValueError:
					PRINT ("byte=<",byte,"> is causing ValueError" )
				self.viewDataHexText.insert("end", " ")

			if len(row) < DISPLAY_BLOCK_WIDTH:
				self.viewDataHexText.insert("end", " " * (DISPLAY_BLOCK_WIDTH - len(row)) * 3)
			
			# There should be a newline at the end of every line. However, we cannot put this responsibility in a separate routine because the last line should not have it,
			# and that routine cannot know which line is the last line. So, we add it explicitly outside.
			if rowNum < len(rows)-1:
				self.viewDataHexText.insert("end", "\n")
				self.viewDataAsciiText.insert("end", "\n")

		# Foreground coloring is done. Now add the background color and cursor-movement by adding tags
		
		
		# First get the current window (from which byte to which byte of the file is displayed)
		firstByteDisplayedOffset = fileDisplayOffset
		lastByteDisplayedOffsetPlusOne  = fileDisplayOffset + BLOCK_SIZE

		PRINT ("Current value of dataLocationOffset =",dataLocationOffset,"firstByteDisplayedOffset =",firstByteDisplayedOffset,"lastByteDisplayedOffsetPlusOne =",lastByteDisplayedOffsetPlusOne)
		dumpDetailsForDebug()

		if not unraveled:	# No BG coloring possible
#			findHardcodedDataInFile()
			return True

		
		PRINT("\n\n coloredVarsIdOffsetSize =")
		for item in coloredVarsIdOffsetSize:
			# Recall the coloredDataIdOffsetSize format is [variableId, startAddr, dataItemSize, unraveledRownumber]
			PRINT(unraveled[item[3]][1],"<",item[1],",",item[1]+item[2],"> (length", item[2],") <start (inclusive), end (not inclusive)>", "unraveledRowNumber",item[3])

		# Get the minimum starting Addr and maximum ending Addr from the coloredDataIdOffsetSize[] so that we know if ANY of the mapped data is in the current display window 
		PRINT("\n\n coloredDataIdOffsetSize =")
		minStartAddr = LARGE_POSITIVE_NUMBER
		maxEndAddrExclusive = LARGE_NEGATIVE_NUMBER
		for item in coloredDataIdOffsetSize:
			# Recall the coloredDataIdOffsetSize format is [variableId, startAddr, dataItemSize, unraveledRownumber]
			PRINT(unraveled[item[3]][1],"<",item[1],",",item[1]+item[2],"> (length", item[2],") <start (inclusive), end (not inclusive)>", "unraveledRowNumber",item[3])
			minStartAddr = item[1] if item[1] < minStartAddr else minStartAddr
			maxEndAddrExclusive = item[1]+item[2] if item[1]+item[2] > maxEndAddrExclusive else maxEndAddrExclusive
		
		# TO-DO: We need to figure out how bitfields work for start and end addresses
		if minStartAddr != dataLocationOffset:
			errorMessage = "ERROR in displayAndColorDataWindows(): minStartAddr ("+STR(minStartAddr)+") != dataLocationOffset ("+STR(dataLocationOffset)+")"
			errorRoutine(errorMessage)
			return False
		if maxEndAddrExclusive != dataLocationOffset+totalBytesToReadFromDataFile:
			warningMessage = "ERROR in displayAndColorDataWindows(): maxEndAddrExclusive ("+STR(maxEndAddrExclusive)+") != dataLocationOffset+totalBytesToReadFromDataFile ("+STR(dataLocationOffset+totalBytesToReadFromDataFile)+")"
			warningRoutine(warningMessage)
			# Override it
			maxEndAddrExclusive = max(maxEndAddrExclusive, dataLocationOffset+totalBytesToReadFromDataFile)

		if ( (firstByteDisplayedOffset <= minStartAddr 		  <  lastByteDisplayedOffsetPlusOne) or	# data starts within window
			 (firstByteDisplayedOffset <  maxEndAddrExclusive <= lastByteDisplayedOffsetPlusOne) or	# data ends within window
			 (minStartAddr < firstByteDisplayedOffset < lastByteDisplayedOffsetPlusOne < maxEndAddrExclusive)): # data envelopes the whole window
			PRINT("The current display window has some data")
		else:
			PRINT("The current display window has no data that can be mapped")
			return True
		
		# The problem is that there is no guarantee that if all the mapped data will fit in the current window. It may spill over multiple windows.
		# So, we check if anything in the current window needs to be colored by the following logic.
		# If the first or last member of dataOffsets[] (after adding dataLocationOffset) falls within the <firstByteDisplayedOffset,lastByteDisplayedOffsetPlusOne>,
		# Then we know that there is SOMETHING to color. 
		
		# TO-DO: Verify from unraveled that the first data offset to be displayed is indeed dataLocationOffset, and last data offset to be displayed is indeed 
		# (dataLocationOffset + totalBytesToReadFromDataFile)

		for j in range(len(coloredDataIdOffsetSize)):

			self.colorTagsData.append("DataTagBG"+STR(j))

			variableId 			= coloredDataIdOffsetSize[j][0]
			variableName 		= variableDeclarations[variableId][0]
			startAddr			= coloredDataIdOffsetSize[j][1]
			endAddrExclusive	= coloredDataIdOffsetSize[j][1] + coloredDataIdOffsetSize[j][2]
			
			if ( (firstByteDisplayedOffset <= startAddr 	   <  lastByteDisplayedOffsetPlusOne) or	# data starts within window
				 (firstByteDisplayedOffset <  endAddrExclusive <= lastByteDisplayedOffsetPlusOne) or	# data ends within window
				 (startAddr < firstByteDisplayedOffset < lastByteDisplayedOffsetPlusOne < endAddrExclusive)): # data envelopes the whole window
				PRINT("The current display window has some data for variable ", variableName," (id of",variableId,")")
			else:
				PRINT("The current display window has no mappable data for variable ", variableName," (id of",variableId,")")
				continue


			variableDescription = variableDeclarations[variableId][4]["description"] 
			signedOrUnsigned 	= variableDeclarations[variableId][4]["signedOrUnsigned"]
			datatype 			= variableDeclarations[variableId][4]["datatype"]
			isArray 			= variableDeclarations[variableId][4]["isArray"]
			arrayDimensions 	= variableDeclarations[variableId][4]["arrayDimensions"] if isArray else []
			isBitField 			= variableDeclarations[variableId][4]["isBitField"]
		
			# For the Interpreted code window, find out the locations of the variable names (to which the tags would apply)
			tokenStartLineNum = gTokenLocationLinesChars[variableDeclarations[coloredDataIdOffsetSize[j][0]][4]["globalTokenListIndex"]][0][0]
			tokenStartCharNum = gTokenLocationLinesChars[variableDeclarations[coloredDataIdOffsetSize[j][0]][4]["globalTokenListIndex"]][0][1]
			tokenEndLineNum = gTokenLocationLinesChars[variableDeclarations[coloredDataIdOffsetSize[j][0]][4]["globalTokenListIndex"]][1][0]
			tokenEndCharNum = gTokenLocationLinesChars[variableDeclarations[coloredDataIdOffsetSize[j][0]][4]["globalTokenListIndex"]][1][1]
			strCodeWindowVariableStart = str(tokenStartLineNum+1)+"."+str(tokenStartCharNum)		# Remember that on Text the line number starts from 1, not 0
			strCodeWindowVariableEnd   = str(tokenEndLineNum  +1)+"."+str(tokenEndCharNum+1)		# Remember that on Text the line number starts from 1, not 0

			# Depending on the fileOffset, not all mapped variables will have their data highlighted within the Data windows.
			# So, this array below is a list of the coordiates for variables (within the Code window) for which the data is indeed getting highlighted.
			# We do not do anything with the array in THIS routine, but it is useful for other places. For example, when we do PgUp/PgDn,
			# we have to first clear all the transient background tags from the Interpreted Code window.
			self.interpretedCodeVariablesHighlightedStartEndCoordinates.append([strCodeWindowVariableStart,strCodeWindowVariableEnd])

		
			# For the Data windows, find out the locations of the data items (to which the tags would apply)
			getDataCoordinatesResult = self.getDataCoordinates( (coloredDataIdOffsetSize[j][1]), (coloredDataIdOffsetSize[j][1]+coloredDataIdOffsetSize[j][2]) )
			if getDataCoordinatesResult == False:
				errorMessage = "ERROR in displayAndColorDataWindows(): for variable "+variableName+" (id "+ STR(variableId) + "), somehow calling getDataCoordinates (startAddr = "+ STR(startAddr) + ", endAddrExclusive = "+ STR(endAddrExclusive),") returned False!!!"
				errorRoutine(errorMessage)
				return False
			else:
				startStrHex   	= getDataCoordinatesResult[0][0] 
				endStrHex   	= getDataCoordinatesResult[0][1]
				startStrAscii 	= getDataCoordinatesResult[1][0] 
				endStrAscii  	= getDataCoordinatesResult[1][1]


			# We can mention the line.char of the end position of the tag, or we can just say line.char of the start position of the tag + size[j] characters
			startEndStrHex   = startStrHex   + " + " + str(coloredDataIdOffsetSize[j][2]*3) + " chars"
			startEndStrAscii = startStrAscii + " + " + str(coloredDataIdOffsetSize[j][2])   + " chars"
			

			# Next, populate the fields that pop up when you hover the cursor above the data item. Below we populate the Addr start, Addr end, and length
			unraveledRowNumber = coloredDataIdOffsetSize[j][3]
			actualDataAddrStart = "0x{:010X}".format(unraveled[unraveledRowNumber][3])
#			actualDataAddrStart = unraveled[unraveledRowNumber][3]
			actualDataAddrEnd   = "0x{:010X}".format(unraveled[unraveledRowNumber][4])	# This byte is INCLUDED
#			actualDataAddrEnd = unraveled[unraveledRowNumber][4]		# This byte is INCLUDED
			unraveledFullyQualifiedVariableName = unraveled[unraveledRowNumber][1]
			
			if isBitField:
				dataLengthValue = STR(variableDeclarations[variableId][4]["bitFieldWidth"]) + " bits"
			else:
				dataLengthValue = STR(coloredDataIdOffsetSize[j][2])+" byte" + ("s" if coloredDataIdOffsetSize[j][2] > 1 else "")
			
			valueLE = unraveled[unraveledRowNumber][6]
			valueBE = unraveled[unraveledRowNumber][7]
			valueLEStr = str(valueLE)
			valueBEStr = str(valueBE)
			
			if PRINT_ENUM_LITERALS and variableDeclarations[variableId][4]["enumType"]!=None:
				
				PRINT("Printing enum literals for variableId",variableId,", valueLE=",valueLE)
				returnEnumLiteralForValueResult = returnEnumLiteralForValue(variableId, valueLE)
				if returnEnumLiteralForValueResult[0]==False:
					errorMessage = "Error in displayAndColorDataWindows(): Cannot find enum literals for variableId "+STR(variableId)+", valueLE="+STR(valueLE)
					errorRoutine(errorMessage)
					return False
				else:
					valueLEStr = returnEnumLiteralForValueResult[1]
					#if the valueLEStr is too big to show, we truncate it
					if len(valueLEStr) > PRINT_ENUM_LITERALS_MAX_SIZE_CHAR:
						valueLEStr = valueLEStr[0:PRINT_ENUM_LITERALS_MAX_SIZE_CHAR] + "..."

				PRINT("Printing enum literals for variableId",variableId,", valueBE=",valueBE)
				returnEnumLiteralForValueResult = returnEnumLiteralForValue(variableId, valueBE)
				if returnEnumLiteralForValueResult[0]==False:
					errorMessage = "Error in displayAndColorDataWindows(): Cannot find enum literals for variableId "+STR(variableId)+", valueBE="+STR(valueBE)
					errorRoutine(errorMessage)
					return False
				else:
					valueBEStr = returnEnumLiteralForValueResult[1]
					#if the valueBEStr is too big to show, we truncate it
					if len(valueBEStr) > PRINT_ENUM_LITERALS_MAX_SIZE_CHAR: 
						valueBEStr = valueBEStr[0:PRINT_ENUM_LITERALS_MAX_SIZE_CHAR] + "..."

			if isArray:	# We need to add the proper array indices in case it is an array
				variableDescription = unraveledFullyQualifiedVariableName +", where "+ variableDescription

			# Apply the background coloring to the Interpreted Code, Hex, and ASCII windows based on the cursor movement in the Hex window
			
			PRINT ("Going to apply the tag",self.colorTagsData[j],"in Hex window from",startStrHex,"to", endStrHex, "(",startEndStrHex,") for variable",j,variableDeclarations[coloredDataIdOffsetSize[j][0]][0],", with variableDescription =",variableDescription )
			self.viewDataHexText.tag_add(self.colorTagsData[j], startStrHex, endStrHex)

			# Below, we have two sets of near-identical operations. Here is is the rationale.
			# The way we designed this is that on the Data windows, when we bring our cursor on top of any mapped data item, the specific (smallest sized) data item
			# like a char, short, int, long, float etc. gets highlighted so that we know exactly from where the data item starts and where it ends. 
			# This is slightly different behavior than what happens when we hover our cursor over a variable in the Code window. You see, in the Code window,
			# we naturally know which variable we are talking about (on top of which we have placed the cursor), so there is no further need to highlight it.
			# On the other hand, in the Data windows all we see is data, there is no "natural" boundary that is visual. Hence we must find a way to demarcate the data item.
			#
			# The problem is that, if we have structs and arrays, there are MANY dataitems for the same data byte. For example, if we have struct like this:
			#  								struct S {	int i[2]; } var[3];
			# then when we hover over a databyte belonging to var[1].i[1], it will also satisfy the rows in coloredDataIdOffsetSize[] corresponding to var, which means
			# the whole 24 bytes will get highligted instead of the just 4 bytes. Hence we take the following strategy: For the data window, unless we have the 
			# value in the unraveled, we do not highlight in the Data window.
			
			PRINT("\nFor j=",j,"variableName =",variableName, ", unraveledRowNumber =",unraveledRowNumber,", unraveled[",unraveledRowNumber,"] =\n", unraveled[unraveledRowNumber])
			
			if valueLEStr and valueBEStr:

				# This is no real list. We just create a fake list so that individual list items (each one is a statement) gets executed.
				# This is a dirty hack, but I don't know how to do it the pythonic way to make multi-statement Lambda functions.
				self.viewDataHexText.tag_bind(self.colorTagsData[j], "<Enter>", 
					lambda event, textValue=variableDescription, addrValueStart=actualDataAddrStart, addrValueEnd=actualDataAddrEnd, 
					lengthValue=dataLengthValue, dataValueLEValue=valueLEStr, dataValueBEValue=valueBEStr, 
					startStrHexValue=startStrHex, endStrHexValue=endStrHex, startStrAsciiValue=startStrAscii, endStrAsciiValue=endStrAscii, 
					codeVarStart=strCodeWindowVariableStart, codeVarEnd=strCodeWindowVariableEnd: 
					[self.CodeDataMeaningText.configure(text=textValue), 
					 self.dataAddressStartText.configure(text=addrValueStart),
					 self.dataAddressEndText.configure(text=addrValueEnd),			# This address is INCLUDED. Which means, the field ends here.
					 self.dataLengthText.configure(text=lengthValue),
					 self.dataValueLEText.configure(text=dataValueLEValue), 
					 self.dataValueBEText.configure(text=dataValueBEValue), 
					 self.viewDataHexText.tag_add("yellowbg", startStrHexValue, endStrHexValue),
					 self.viewDataAsciiText.tag_add("yellowbg", startStrAsciiValue, endStrAsciiValue),
					 self.interpretedCodeText.tag_add("yellowbg", codeVarStart, codeVarEnd)])
					 
				self.viewDataHexText.tag_bind (self.colorTagsData[j], "<Leave>", 
					lambda event, textValue="", startStrHexValue=startStrHex, endStrHexValue=endStrHex, startStrAsciiValue=startStrAscii, endStrAsciiValue=endStrAscii, 
					codeVarStart=strCodeWindowVariableStart, codeVarEnd=strCodeWindowVariableEnd : 
					[self.CodeDataMeaningText.configure(text=textValue), 
					 self.dataAddressStartText.configure(text=""), 
					 self.dataAddressEndText.configure(text=""),
					 self.dataLengthText.configure(text=""), 
					 self.dataValueLEText.configure(text=""), 
					 self.dataValueBEText.configure(text=""), 
					 self.viewDataHexText.tag_remove("yellowbg", startStrHexValue, endStrHexValue),
					 self.viewDataAsciiText.tag_remove("yellowbg", startStrAsciiValue, endStrAsciiValue),
					 self.interpretedCodeText.tag_remove("yellowbg", codeVarStart, codeVarEnd)])

				# Apply the background coloring to the Interpreted Code, Hex, and ASCII windows based on the cursor movement in the ASCII window

				self.viewDataAsciiText.tag_add(self.colorTagsData[j], startStrAscii, endStrAscii)
				
				self.viewDataAsciiText.tag_bind(self.colorTagsData[j], "<Enter>", 
					lambda event, textValue=variableDescription, addrValueStart=actualDataAddrStart, addrValueEnd=actualDataAddrEnd, 
					lengthValue=dataLengthValue, dataValueLEValue=valueLEStr, dataValueBEValue=valueBEStr, 
					startStrHexValue=startStrHex, endStrHexValue=endStrHex, startStrAsciiValue=startStrAscii, endStrAsciiValue=endStrAscii, 
					codeVarStart=strCodeWindowVariableStart, codeVarEnd=strCodeWindowVariableEnd : 
					[self.CodeDataMeaningText.configure(text=textValue),
					 self.dataAddressStartText.configure(text=addrValueStart),
					 self.dataAddressEndText.configure(text=addrValueEnd),
					 self.dataLengthText.configure(text=lengthValue),
					 self.dataValueLEText.configure(text=dataValueLEValue), 
					 self.dataValueBEText.configure(text=dataValueBEValue), 
					 self.viewDataHexText.tag_add("yellowbg", startStrHexValue, endStrHexValue),
					 self.viewDataAsciiText.tag_add("yellowbg", startStrAsciiValue, endStrAsciiValue),
					 self.interpretedCodeText.tag_add("yellowbg", codeVarStart, codeVarEnd),
					 self.interpretedCodeText.tag_add("yellowbg", codeVarStart, codeVarEnd)])
					 
				self.viewDataAsciiText.tag_bind(self.colorTagsData[j], "<Leave>", 
					lambda event, textValue="", startStrHexValue=startStrHex, endStrHexValue=endStrHex, startStrAsciiValue=startStrAscii, endStrAsciiValue=endStrAscii, 
					codeVarStart=strCodeWindowVariableStart, codeVarEnd=strCodeWindowVariableEnd  : 
					[self.CodeDataMeaningText.configure(text=textValue),
					 self.dataAddressStartText.configure(text=""), 
					 self.dataAddressEndText.configure(text=""), 
					 self.dataLengthText.configure(text=""), 
					 self.dataValueLEText.configure(text=""), 
					 self.dataValueBEText.configure(text=""), 
					 self.viewDataHexText.tag_remove("yellowbg", startStrHexValue, endStrHexValue),
					 self.viewDataAsciiText.tag_remove("yellowbg", startStrAsciiValue, endStrAsciiValue),
					 self.interpretedCodeText.tag_remove("yellowbg", codeVarStart, codeVarEnd)])

			else:

				# This is no real list. We just create a fake list so that individual list items (each one is a statement) gets executed.
				# This is a dirty hack, but I don't know how to do it the pythonic way to make multi-statement Lambda functions.
				self.viewDataHexText.tag_bind(self.colorTagsData[j], "<Enter>", 
					lambda event, textValue=variableDescription, addrValueStart=actualDataAddrStart, addrValueEnd=actualDataAddrEnd, 
					lengthValue=dataLengthValue, dataValueLEValue=valueLEStr, dataValueBEValue=valueBEStr, 
					startStrHexValue=startStrHex, endStrHexValue=endStrHex, startStrAsciiValue=startStrAscii, endStrAsciiValue=endStrAscii, 
					codeVarStart=strCodeWindowVariableStart, codeVarEnd=strCodeWindowVariableEnd: 
					[self.CodeDataMeaningText.configure(text=textValue), 
					 self.dataAddressStartText.configure(text=addrValueStart),
					 self.dataAddressEndText.configure(text=addrValueEnd),			# This address is INCLUDED. Which means, the field ends here.
					 self.dataLengthText.configure(text=lengthValue),
					 self.dataValueLEText.configure(text=dataValueLEValue), 
					 self.dataValueBEText.configure(text=dataValueBEValue), 
#					 self.viewDataHexText.tag_add("yellowbg", startStrHexValue, endStrHexValue),			# Don't highlight the Hex   window if no data in unraveled
#					 self.viewDataAsciiText.tag_add("yellowbg", startStrAsciiValue, endStrAsciiValue),		# Don't highlight the ASCII window if no data in unraveled
					 self.interpretedCodeText.tag_add("yellowbg", codeVarStart, codeVarEnd)])
					 
				self.viewDataHexText.tag_bind (self.colorTagsData[j], "<Leave>", 
					lambda event, textValue="", startStrHexValue=startStrHex, endStrHexValue=endStrHex, startStrAsciiValue=startStrAscii, endStrAsciiValue=endStrAscii, 
					codeVarStart=strCodeWindowVariableStart, codeVarEnd=strCodeWindowVariableEnd : 
					[self.CodeDataMeaningText.configure(text=textValue), 
					 self.dataAddressStartText.configure(text=""), 
					 self.dataAddressEndText.configure(text=""),
					 self.dataLengthText.configure(text=""), 
					 self.dataValueLEText.configure(text=""), 
					 self.dataValueBEText.configure(text=""), 
#					 self.viewDataHexText.tag_remove("yellowbg", startStrHexValue, endStrHexValue),			# Don't highlight the Hex   window if no data in unraveled
#					 self.viewDataAsciiText.tag_remove("yellowbg", startStrAsciiValue, endStrAsciiValue),	# Don't highlight the ASCII window if no data in unraveled
					 self.interpretedCodeText.tag_remove("yellowbg", codeVarStart, codeVarEnd)])

				# Apply the background coloring to the Interpreted Code, Hex, and ASCII windows based on the cursor movement in the ASCII window

				self.viewDataAsciiText.tag_add(self.colorTagsData[j], startStrAscii, endStrAscii)
				
				self.viewDataAsciiText.tag_bind(self.colorTagsData[j], "<Enter>", 
					lambda event, textValue=variableDescription, addrValueStart=actualDataAddrStart, addrValueEnd=actualDataAddrEnd, 
					lengthValue=dataLengthValue, dataValueLEValue=valueLEStr, dataValueBEValue=valueBEStr, 
					startStrHexValue=startStrHex, endStrHexValue=endStrHex, startStrAsciiValue=startStrAscii, endStrAsciiValue=endStrAscii, 
					codeVarStart=strCodeWindowVariableStart, codeVarEnd=strCodeWindowVariableEnd : 
					[self.CodeDataMeaningText.configure(text=textValue),
					 self.dataAddressStartText.configure(text=addrValueStart),
					 self.dataAddressEndText.configure(text=addrValueEnd),
					 self.dataLengthText.configure(text=lengthValue),
					 self.dataValueLEText.configure(text=dataValueLEValue), 
					 self.dataValueBEText.configure(text=dataValueBEValue), 
#					 self.viewDataHexText.tag_add("yellowbg", startStrHexValue, endStrHexValue),			# Don't highlight the Hex   window if no data in unraveled
#					 self.viewDataAsciiText.tag_add("yellowbg", startStrAsciiValue, endStrAsciiValue),		# Don't highlight the ASCII window if no data in unraveled
					 self.interpretedCodeText.tag_add("yellowbg", codeVarStart, codeVarEnd)])
					 
				self.viewDataAsciiText.tag_bind(self.colorTagsData[j], "<Leave>", 
					lambda event, textValue="", startStrHexValue=startStrHex, endStrHexValue=endStrHex, startStrAsciiValue=startStrAscii, endStrAsciiValue=endStrAscii, 
					codeVarStart=strCodeWindowVariableStart, codeVarEnd=strCodeWindowVariableEnd  : 
					[self.CodeDataMeaningText.configure(text=textValue),
					 self.dataAddressStartText.configure(text=""), 
					 self.dataAddressEndText.configure(text=""), 
					 self.dataLengthText.configure(text=""), 
					 self.dataValueLEText.configure(text=""), 
					 self.dataValueBEText.configure(text=""), 
#					 self.viewDataHexText.tag_remove("yellowbg", startStrHexValue, endStrHexValue),			# Don't highlight the Hex   window if no data in unraveled
#					 self.viewDataAsciiText.tag_remove("yellowbg", startStrAsciiValue, endStrAsciiValue),	# Don't highlight the ASCII window if no data in unraveled
					 self.interpretedCodeText.tag_remove("yellowbg", codeVarStart, codeVarEnd)])
			
			tags = (self.colorTagsData[j],)
		
		
		return True

	####################################################################
	# This funcion fills one row of the Hex and ASCII windows
	####################################################################
	
	def showIndividualLineWithFGcolor(self, row, fileOffset):
		# The input is one line (or row) of the Data window (the treatment is the same for both Hex and ASCII windows). Then we iterate over each byte of this line (or row). 
		# For each byte, we iterate over the individual items of coloredVarsIdOffsetSize[]. Recall that each row in coloredVarsIdOffsetSize[] corresponds to a variable
		# in the Interpreted code window, based on the selection made by the user (not every variable in the Interpreted code gets mapped, of course).
		# Not only that, there might be multiple rows in coloredVarsIdOffsetSize[] for a single mapped variable. This can happen because if you see the example below, 
		# there will be 5 different rows corresponding to the same variable i.
		# 
		#  	struct S { int i;} structVar[5];
		#
		# Also remember that coloredVarsIdOffsetSize[] is sorted based on size, from biggest to smallest. And for every byte in the supplied input line, we iterate over
		# each of the rows in coloredVarsIdOffsetSize[], from biggest size to the smallest. If we see that the coloredVarsIdOffsetSize[] row applies to the byte,
		# then we apply the correspondiong tag, which only applies the FOREGROUND color, NOT the background one. And since we apply from the largest size to the smallest,
		# we ensure that smallest variables gets the priority over the large structs, setting for more granular viewing.
		for i in range(len(row)):
			tags = ()
			byte = row[i] 
			byteFileOffset = fileOffset + i
			
			# TO=DO: Why are we doing the FG coloring here, since we know that performInterpretedCodeColoring() does the FG coloring for both the Code and Data windows anyway?
			
			if coloredVarsIdOffsetSize and (dataLocationOffset <= byteFileOffset < dataLocationOffset+totalBytesToReadFromDataFile):	# This is data to be colored differently
				tagIndex = -1 		# Default Error value
				for j in range(len(coloredVarsIdOffsetSize)):
					if coloredVarsIdOffsetSize[j][1] <= byteFileOffset < coloredVarsIdOffsetSize[j][1]+coloredVarsIdOffsetSize[j][2]:	# This is data to be colored differently
						tagIndex = j	# In case multiple tags match, only the latest (smallest sized) will win by overwriting others
				if tagIndex == -1 and COMPILER_PADDING_ON == False:	# The only way we get a non-coloring within a colored window is when we add compiler paddings
					for item in coloredVarsIdOffsetSize:	
						OUTPUT(variableDeclarations[item[0]][0],"<",item[1],",",item[1]+item[2],"> (length", item[2],") <start (inclusive), end (not inclusive)>")
					OUTPUT("dataLocationOffset =",dataLocationOffset, ", fileOffset =",fileOffset,", i =",i,", byteFileOffset =",byteFileOffset, ", totalBytesToReadFromDataFile =",totalBytesToReadFromDataFile,", dataLocationOffset+totalBytesToReadFromDataFile =",dataLocationOffset+totalBytesToReadFromDataFile)
					OUTPUT("\ncoloredVarsIdOffsetSize =",coloredVarsIdOffsetSize,"\n")
					errorMessage = "ERROR in showIndividualLineWithFGcolor() for char # %d in current row (overall %d-th byte of file) - Invalid tag, exiting"%(i,byteFileOffset)
					errorRoutine(errorMessage)
					return False
				else:
					try:
						tags = (self.colorTagsFG[tagIndex],)	# Why is this line NOT getting invalidated by the later statement (now commented out) ===>    tags = ()
					except IndexError:
						errorMessage = "Inside showIndividualLineWithFGcolor(), byte = <"+STR(byte)+"> is causing IndexError for tagIndex = "+STR(tagIndex)+" currently self.colorTagsFG= "+STR(self.colorTagsFG)
						errorRoutine(errorMessage)
						dumpDetailsForDebug()

			if ((0x20 <= ORD(byte) <= 0x7E) or (0x80 <= ORD(byte) <= 0xFE)):
				byteToPrint = byte
			else:
				byteToPrint = "."
			try:
#				tags = ()	# Why is this line NOT invalidating the previous statement ===>    tags = (self.colorTagsFG[tagIndex],)
				self.viewDataHexText.insert("end", "{:02X}".format(ORD(byte)), tags)
				self.viewDataAsciiText.insert("end", chr(ORD(byteToPrint)), tags)
			except ValueError:
				PRINT ("byte=<",byte,"> is causing ValueError" )
			self.viewDataHexText.insert("end", " ")

		if len(row) < DISPLAY_BLOCK_WIDTH:
			self.viewDataHexText.insert("end", " " * (DISPLAY_BLOCK_WIDTH - len(row)) * 3)
		
		return True

	def openCodeFileDialogue(self, *args):
		global codeFileName
		codeFileName = filedialog.askopenfilename(title="Open code file - {}".format(TOOL_NAME))
		self.openCodeFile()
		
	def openCodeFile(self, demoCodeIndexPassed=-1):
		if IN_DEMO == True and (codeFileName == None or codeFileName == ""):
			if demoCodeIndexPassed not in range(len(demoCode)):
				EXIT("Coding bug in openCodeFile: demoCodeIndexPassed = "+STR(demoCodeIndexPassed)+", but len(demoCode) = "+STR(len(demoCode)))
			singleCodeLine = ''.join(demoCode[demoCodeIndexPassed])
			PRINT ("singleCodeLine =",singleCodeLine )
			S = tk.StringVar()
			S.set(singleCodeLine)
			PRINT ("StringVar S = <",S.get(),">" )
			self.originalCodeText.delete("1.0", "end")
			self.originalCodeText.insert("end",S.get())
			return True
		
		elif codeFileName != None and codeFileName != "":
			if codeFileName and os.path.exists(codeFileName):
				self.originalCodeText.delete("1.0", "end")
				with open(codeFileName, "r") as codeFile:
					try:
						codeLines = codeFile.readlines()
					except ValueError: # Empty file
						return False
				PRINT ("Code file contains:", codeLines )
				
				singleCodeLine = ''.join(codeLines)
				PRINT ("singleCodeLine =",singleCodeLine )
				S = tk.StringVar()
				S.set(singleCodeLine)
				PRINT ("StringVar S = <",S.get(),">" )
				self.originalCodeText.delete("1.0", "end")
				self.originalCodeText.insert("end",S.get())
				return True
			else:
				errorMessage = "ERROR- Unknown code file name "+codeFileName
				errorRoutine(errorMessage)
				return False

			
	def openDataFileDialogue(self, *args):
		global dataFileName
		dataFileNameChosen = filedialog.askopenfilename(title="Open data file - {}".format(TOOL_NAME))
		
		if dataFileNameChosen == None or dataFileNameChosen == "":
				return
			
		dataFileName = dataFileNameChosen
			
		if fileDisplayOffset != 0:
			self.fileOffset.set(0)
		
		self.openDataFile(dataFileName)

	def openDataFile(self, dataFileNameInput):
		global dataBlock, displayBlock
		
		self.viewDataHexText.delete("1.0", "end")
		self.viewDataAsciiText.delete("1.0", "end")
		
		PRINT("Control inside openDataFile(dataFileNameInput=",dataFileNameInput,")")
		if checkIfDataFileIsValidAndGetItsLength(dataFileNameInput) == True:
			size = (dataFileSizeInBytes - BLOCK_SIZE if dataFileSizeInBytes > BLOCK_SIZE else dataFileSizeInBytes - DISPLAY_BLOCK_WIDTH)
			if IN_DEMO:
				self.parent.title("%s - Demo"%(TOOL_NAME))
			else:
				self.parent.title("%s - %s"%(dataFileName, TOOL_NAME))
			self.fileOffsetSpinbox.config(to=max(size, 0))
	
			# MannaManna - BEGIN
			# If the code is already there, and we are just changing the data file, then we need to run the whole shebang
			if coloredVarsIdOffsetSize:
				dataBlock = readBytesFromFile(dataLocationOffset, totalBytesToReadFromDataFile)
#				displayBlock = readBytesFromFile(fileDisplayOffset, BLOCK_SIZE)		# MANNA_MANNA
				displayBlock = readBytesFromFile(fileDisplayOffset, max(0, min(dataFileSizeInBytes-fileDisplayOffset,BLOCK_SIZE)))
			# MannaManna - END
			
			# Since changing dataOffset gives us new data (on which the selected variables are mapped), it's not different for having a new data file 
			if coloredVarsIdOffsetSize:
				PRINT("Changing data file - run everything")
				self.dataOffsetChange()
			else:
				PRINT("No previous map")
				self.displayAndColorDataWindows()
			
				
			if inputIsHexChar:
				warningMessage = "It appears that the input file is not a binary but rather a text file containing Hex representation of of binary data. Treating it accordingly."
				if not IN_DEMO:
					warningRoutine(warningMessage)
			
			self.dataOffsetEntry.config(state=tk.NORMAL)
			self.fileOffsetEntry.config(state=tk.NORMAL)
			
			return True
		else:
			return False

	def quit(self, event=None):
		self.parent.destroy()
		
	def removeColorTags(self, event=None):
		PRINT ("Removing any existing color tags (if any)...." )
		
		PRINT("Before removing, self.colorTagsFG =",self.colorTagsFG)
		for i in range(len(self.colorTagsFG)):
			self.interpretedCodeText.tag_delete(self.colorTagsFG[i])
			self.viewDataHexText.tag_delete(self.colorTagsFG[i])			# <==== Newly added
			self.viewDataAsciiText.tag_delete(self.colorTagsFG[i])			# <==== Newly added
		self.colorTagsFG = []
		PRINT("After removing, self.colorTagsFG =",self.colorTagsFG)
		
		PRINT("Before removing, self.colorTagsData =",self.colorTagsData)
		for i in range(len(self.colorTagsData)):
			self.viewDataHexText.tag_delete(self.colorTagsData[i])
			self.viewDataAsciiText.tag_delete(self.colorTagsData[i])
		self.colorTagsData = []
		PRINT("After removing, self.colorTagsData =",self.colorTagsData)

	def clearTreeView(self, event=None):
		
#		treeChildrenList = self.treeView.get_children()
#		for treeItem in treeChildrenList:
#			self.treeView.delete(treeItem)
#		selected_item = self.treeView.selection()[0] ## get selected item
#		self.treeView.delete(selected_item)
		
		PRINT ("Currently self.treeView.get_children() = ",self.treeView.get_children(), "len(self.treeView.get_children()) = ",len(self.treeView.get_children()))
		if len(self.treeView.get_children()) > 0:
			PRINT ("Deleting self.treeView.get_children()")
			try:
				currentChildren = self.treeView.get_children()
				for child in currentChildren:
					PRINT ("Just before deleting",child,", self.treeView.get_children() = ",self.treeView.get_children(), "len(self.treeView.get_children()) = ",len(self.treeView.get_children()))
					self.treeView.delete(child)
					PRINT ("Just after deleting",child,", self.treeView.get_children() = ",self.treeView.get_children(), "len(self.treeView.get_children()) = ",len(self.treeView.get_children()))
			except tk.TclError as e:
				sys.stderr.write(str(e)+"\n")
				errorMessage = "Tcl/Tk ERROR while trying to delete existing Tree children"
				errorRoutine(errorMessage)
				return False
			except:
				errorMessage = "Non-Tcl/Tk ERROR while trying to delete existing Tree children"
				errorRoutine(errorMessage)
				return False
				
			PRINT ("After deleting,  self.treeView.get_children() = ",self.treeView.get_children())
		return True

	def populateTreeView(self, event=None):
		PRINT ("Inside populateTreeView(), going to write the Root node")
		# The parameter in an insert statement are (parent, index, iid=None, **kw)	
		# Creates a new item and returns the item identifier of the newly created item.
		# parent is the item ID of the parent item, or the empty string to create a new top-level item. 
		# index is an integer, or the value "end", specifying where in the list of parent's children to insert the new item. 
		#     If index is less than or equal to zero, the new node is inserted at the beginning.
		#     If index is greater than or equal to the current number of children, it is inserted at the end. 
		# iid is the item identifier. If iid is specified, iid must not already exist in the tree. Otherwise, a new unique identifier is generated.
		
		PRINT("\n","=="*50,"\n","unraveled (",len(unraveled),"items) =")
		printUnraveled(unraveled)
		PRINT("\n","=="*50,"\n","Now going to populate the treeview")
		
		currentLevel = 0
		hierarchy = [""]	# The last item indicates what is the current parent
		for N in range(len(unraveled)):
			PRINT ("Before adding, self.treeView.get_children() =",self.treeView.get_children())
			PRINT ("Inserting following node into the treeView:",unraveled[N])
			if N==0 or unraveled[N][0] == unraveled[N-1][0]:	# Do not change the hierarchy
				pass
			elif unraveled[N][0] == unraveled[N-1][0] + 1:		# Add the last node to the hierarchy
				hierarchy.append(id)
			elif unraveled[N][0] < unraveled[N-1][0]:			# Delete the required number of parents until we have a common parent
				levelsToPopFromHierarchy = unraveled[N-1][0] - unraveled[N][0]
				del hierarchy[-levelsToPopFromHierarchy:]
			elif unraveled[N][0] > unraveled[N-1][0] + 1 :		# Should not happen
				errorMessage = "unraveled["+STR(N)+"][0] =",STR(unraveled[N][0]),"cannot be greater than unraveled[",STR(N),"-1][0]+1, which is ",STR(unraveled[N-1][0]+1)
				errorRoutine(errorMessage)
				return False
			levelIndent = "    " * unraveled[N][0]
			dataTypeText = unraveled[N][2] if not isinstance(unraveled[N][2],dict) else unraveled[N][2]["datatype"] if unraveled[N][2]["signedOrUnsigned"] != "unsigned" or unraveled[N][2]["datatype"] == "pointer" else unraveled[N][2]["signedOrUnsigned"] + " " + unraveled[N][2]["datatype"]
			if N<len(unraveled)-1 and unraveled[N][0]==unraveled[N+1][0]-1 and isinstance(unraveled[N][2],dict) and unraveled[N][2]["isArray"]:	# The current node is a parent - an array 
				dataTypeText += " array"
			if isinstance(unraveled[N][2],dict) and unraveled[N][2]["datatype"].startswith("function "):	# Hardcode it for functions
				dataTypeText = "function"
			try:
				if isinstance(unraveled[N][2],dict) and "isBitField" in getDictKeyList(unraveled[N][2]) and unraveled[N][2]["isBitField"]==True:
#					addrStart = hex(unraveled[N][3]+integerDivision(unraveled[N][2]["bitOffsetWithinStruct"],BITS_IN_BYTE)) + "." + STR(unraveled[N][2]["bitOffsetWithinStruct"]%BITS_IN_BYTE)
#					addrEnd = hex(unraveled[N][3]+integerDivision(unraveled[N][2]["bitOffsetWithinStruct"]+unraveled[N][2]["bitFieldWidth"],BITS_IN_BYTE)) + "." + STR((unraveled[N][2]["bitOffsetWithinStruct"]+unraveled[N][2]["bitFieldWidth"])%BITS_IN_BYTE)
					addrStart = hex(unraveled[N][3]  ) + "." + STR((unraveled[N][2]["bitOffsetWithinStruct"]                                   )%BITS_IN_BYTE)
#					addrEnd   = hex(unraveled[N][4]-1) + "." + STR((unraveled[N][2]["bitOffsetWithinStruct"]+unraveled[N][2]["bitFieldWidth"]-1)%BITS_IN_BYTE)
					addrEnd   = hex(unraveled[N][3]+bit2Byte((unraveled[N][2]["bitOffsetWithinStruct"]%BITS_IN_BYTE)+unraveled[N][2]["bitFieldWidth"]-1))+"." + STR((unraveled[N][2]["bitOffsetWithinStruct"]+unraveled[N][2]["bitFieldWidth"]-1)%BITS_IN_BYTE)
					
					PRINT("\n\n\n\n\n\n\n","===="*50,"\n","***"*50,"\n","===="*50,"\n\n\n\n")
					PRINT("For variable",variableDeclarations[unraveled[N][8][-1]][0],"unraveled[N][3] =",unraveled[N][3], "unraveled[N][4] =",unraveled[N][4], "addrStart =",addrStart,", addrEnd =",addrEnd)
					'''
					addrStartOld = hex(unraveled[N][3]+integerDivision(unraveled[N][2]["bitFieldInfo"]["currentBitFieldSequenceCurrentContainerBitIndexStart"],BITS_IN_BYTE)) + "." + STR(unraveled[N][2]["bitFieldInfo"]["currentBitFieldSequenceCurrentContainerBitIndexStart"]%BITS_IN_BYTE)
					addrEndOld = hex(unraveled[N][3]+integerDivision(unraveled[N][2]["bitFieldInfo"]["currentBitFieldSequenceCurrentContainerBitIndexEndInclusive"],BITS_IN_BYTE)) + "." + STR(unraveled[N][2]["bitFieldInfo"]["currentBitFieldSequenceCurrentContainerBitIndexEndInclusive"]%BITS_IN_BYTE)
					if addrStartOld != addrStart or addrEndOld != addrEnd:
						OUTPUT("Mismatch in populateTreeView() for unraveled[",N,"=",N,"] =",unraveled[N])
						OUTPUT("addrStartOld (",addrStartOld," != addrStart (",addrStart,"), or addrEndOld (",addrEndOld,") != addrEnd (",addrEnd,")")
						sys.exit()
					'''
				else:
					addrStart = hex(unraveled[N][3])
					addrEnd = hex(unraveled[N][4]-1)

				# Possibly, convert the values into enum literals.
				valueLE = unraveled[N][6]
				valueBE = unraveled[N][7]
				
				valueLE2Display = valueLE
				valueBE2Display = valueBE
				
				if PRINT_ENUM_LITERALS and variableDeclarations[unraveled[N][8][-1]][4]["enumType"]!=None:
					variableId = unraveled[N][8][-1]
					
					PRINT("Printing enum literals for variableId",variableId,", valueLE=",valueLE)
					returnEnumLiteralForValueResult = returnEnumLiteralForValue(variableId, valueLE)
					if returnEnumLiteralForValueResult[0]==False:
						errorMessage = "Error in populateTreeView(): Cannot enum literals for variableId "+STR(variableId)+", valueLE="+STR(valueLE)
						errorRoutine(errorMessage)
						return False
					else:
						valueLE2Display = returnEnumLiteralForValueResult[1]

					PRINT("Printing enum literals for variableId",variableId,", valueBE=",valueBE)
					returnEnumLiteralForValueResult = returnEnumLiteralForValue(variableId, valueBE)
					if returnEnumLiteralForValueResult[0]==False:
						errorMessage = "Error in populateTreeView(): Cannot enum literals for variableId "+STR(variableId)+", valueBE="+STR(valueBE)
						errorRoutine(errorMessage)
						return False
					else:
						valueBE2Display = returnEnumLiteralForValueResult[1]

				treeViewRowValues = (levelIndent+unraveled[N][1],dataTypeText,addrStart,addrEnd,unraveled[N][5],valueLE2Display,valueBE2Display)
				id = self.treeView.insert(hierarchy[-1], "end", iid=None, values=treeViewRowValues)
			except IndexError:
				OUTPUT ("IndexError in populateTreeView(): List index out of range for N = ",N)
				OUTPUT (unraveled[N])
				sys.exit()
			PRINT ("After adding, self.treeView.get_children() =",self.treeView.get_children())
		
	
	##############################################################################################
	# This function should get called every time the data offset changes, but not the file offset
	##############################################################################################

	def displayBottomTreeWindow(self, event=None):
		
		
		PRINT("\n\n\n","==="*50,"\nInside displayBottomTreeWindow()\n","==="*50)
		
		if lines==[]:
			return True

		self.clearTreeView()	# Moved from earlier place
		PRINT("\n","=="*50,"\n","Now going to populate the treeview")
		self.populateTreeView()
		
		# Print it on the console and the CSV file
		prettyPrintUnraveled()
		return True
			
	############################################################################################################################
	############################################################################################################################
	#
	# interpret
	#
	############################################################################################################################
	############################################################################################################################

	def interpret(self, event=None):
		global lines, lastActionWasInterpret, lastActionWasMap
		
		PRINT("\n\n\n","==="*50,"\nInside interpret()\n","==="*50)
		
#		self.parent.config(cursor="wait")		# MannaManna
		inputCodeContents = self.originalCodeText.get("1.0", "end")
		PRINT ("type(inputCodeContents) =", type(inputCodeContents) )	#Python 2 will have the type as unicode, Python 3 as bytes
		
		if PYTHON2x:
			inputCodeContents = inputCodeContents.encode("ascii","ignore")
		PRINT ("type(inputCodeContents) =", type(inputCodeContents) )	#Python 2 will have the type as unicode, Python 3 as bytes

		inputCodeContents = convert2Str(inputCodeContents)
		PRINT ("After convert2Str(inputCodeContents), type(inputCodeContents) =", type(inputCodeContents) )	#Now everything should be str

		
		# Verify that the inputCodeContents is indeed string
		if not checkIfString(inputCodeContents):
			errorMessage = "ERROR in coding: inputCodeContents is NOT string - type(inputCodeContents) = "+STR(type(inputCodeContents))
			errorRoutine(errorMessage)
			return False
		
		asciiLines = inputCodeContents.splitlines()
		if not checkIfStringOrListOfStrings(asciiLines):
			errorMessage = "ERROR in coding: asciiLines is NOT string - type(asciiLines) = "+STR(type(asciiLines))
			errorRoutine(errorMessage)
			return False
		
#		asciiLines = self.originalCodeText.get('1.0', 'end-1c').splitlines()
		PRINT ("Content of input code box =" )
		PRINT (inputCodeContents )
		PRINT ("asciiLines =",asciiLines )
		PRINT ("type(asciiLines) =",type(asciiLines) )
		# We need to check what is the type of individual lines of asciiLines
		PRINT ("type(asciiLines[0]) =",type(asciiLines[0]) )
#		sys.exit()
		
		# Empty the global variables
		self.removeColorTags()
		self.clearTreeView()
		
		# Empty the global variables
		lines=[]

		lastActionWasInterpret = True
		lastActionWasMap = False
		
		for line in asciiLines:
			lines.append(line+'\n')

		interpretBatchResult = interpretBatch()

		# Call the main module
		if interpretBatchResult == False:
			OUTPUT ("ERROR in interpret() after calling mainWork() - exiting" )
			self.parent.config(cursor="")		# MannaManna
			return False

		# Only after the interpretation goes through, enable the Interpreted code window
		self.interpretedCodeText.config(state=tk.NORMAL)
			
		PRINT ("lines =", lines )
		singleLine = ''.join(lines)
		PRINT ("singleLine =",singleLine )
		S = tk.StringVar()
		S.set(singleLine)
		PRINT ("StringVar S = <",S.get(),">" )
		self.interpretedCodeText.delete("1.0", "end")
		
		#self.interpretedCodeText.insert("end",inputCodeContents)
		self.interpretedCodeText.insert("end",S.get())
		
		# Now we are going to add code that will highlight the variable declarations with a suitable descriptions
		
		PRINT ("inside interpret(), gTokenLocationLinesChars = ",gTokenLocationLinesChars )
		for item in variableDeclarations:
			PRINT ("Variable declared is ...." )
			PRINT (item )
			try:
				variableDescription = item[4]["description"]
				variableTokenIndex = item[4]["globalTokenListIndex"]	# This is the ABOSLUTE index of the variable name token inside the whole tokenlist. 
												# Recall the item[3] is the relative index of the variable name within the variable declaration statement.
												# For cases where the statement does not exist inside the actual code file (like the builtin typedefs)
				if variableTokenIndex >= 0:
					variableLocationStart = gTokenLocationLinesChars[variableTokenIndex][0]
					variableLocationEnd   = gTokenLocationLinesChars[variableTokenIndex][1]
					PRINT ("variable", item[0],"starts from", variableLocationStart, "and ends at", variableLocationEnd )
					variableLocationStartStr = ""+ str(variableLocationStart[0]+1)+"."+str(variableLocationStart[1])	# Recall that on Text widget the line # starts from 1, not 0
					variableLocationEndStr   = ""+ str(variableLocationEnd[0]  +1)+"."+str(variableLocationEnd[1])	# Recall that on Text widget the line # starts from 1, not 0
					PRINT ("variable", item[0],"starts from", variableLocationStartStr, "and ends at", variableLocationEndStr )
			except IndexError:
				OUTPUT("Current item =",item)
				OUTPUT("variableTokenIndex =",variableTokenIndex)
				OUTPUT("gTokenLocationLinesChars[variableTokenIndex=%d]=%s"%(variableTokenIndex,STR(gTokenLocationLinesChars[variableTokenIndex])))
				sys.exit()
#		self.parent.config(cursor="")		# MannaManna
		return True

	##################################################################################################################
	#
	# The only purpose of this function is so see which all variables get selected.
	#
	##################################################################################################################
	
	def mapStructureToData(self, event=None):
		global variableSelectedIndices, lastActionWasInterpret, lastActionWasMap, gVerificationWarningCount

		gVerificationWarningCount = 0

		PRINT("\n\n\n","==="*50,"\n","///"*50,"\n","==="*50,"\n","\t"*7,"Inside mapStructureToData()\n","==="*50,"\n","\\\\\\"*50,"\n","==="*50,"\n\n\n")
		
		if lines==[]:
			return False
		elif dataFileName == None or dataFileName == "":
			errorMessage = "Cannot map structure without data"
			errorRoutine(errorMessage)
			return False
		
		for treeItem in self.treeView.get_children():
			self.treeView.delete(treeItem)
		
		try:
			selectionRanges = self.interpretedCodeText.tag_ranges(tk.SEL)
		except UnboundLocalError:
			PRINT ("ERROR in mapStructureToData() - no selection made - exiting" )
			return False
			sys.exit()
			
		if selectionRanges:	
			PRINT ("selectionRanges =",selectionRanges )
			PRINT ("tk.SEL_FIRST =",selectionRanges[0], "tk.SEL_LAST =",selectionRanges[1] )
			selectionRangeStart = "%s"%(selectionRanges[0])
			selectionRangeEnd = "%s"%(selectionRanges[1])
		else:
			PRINT ('NO Selected Text - assuming whole window is selected')
			selectionRangeStart = "1.0"
			selectionRangeEnd = str(len(lines))+"."+str(len(lines[-1])-1)

		selectionRangeStartLineNum = int(selectionRangeStart.split(".")[0])-1	# Remember that in Text widget the line # starts from 1, not 0
		selectionRangeStartCharNum = int(selectionRangeStart.split(".")[1])
		selectionRangeEndLineNum = int(selectionRangeEnd.split(".")[0])-1		# Remember that in Text widget the line # starts from 1, not 0
		selectionRangeEndCharNum = int(selectionRangeEnd.split(".")[1])
		PRINT ("selectionRangeStart =",selectionRangeStart,"<",selectionRangeStartLineNum,".", selectionRangeStartCharNum,">","type(selectionRangeStart) =",type(selectionRangeStart), "selectionRangeEnd =",selectionRangeEnd,"<",selectionRangeEndLineNum,".", selectionRangeEndCharNum,">","type(selectionRangeEnd) =",type(selectionRangeEnd) )
		PRINT ('SELECTED Text is %r' % self.interpretedCodeText.get(selectionRangeStart, selectionRangeEnd))
		
		lastActionWasInterpret = False
		lastActionWasMap = True

		
		PRINT ("Inside mapStructureToData(), gTokenLocationLinesChars =",gTokenLocationLinesChars )
		tokenListResult = tokenizeLines(lines)
		if tokenListResult == False:
			PRINT ("ERROR inside mapStructureToData after calling tokenizeLines(lines) for lines = ", lines )
			return False
		else:
			tokenList = tokenListResult[0]
			
		if len(tokenList) != len(gTokenLocationLinesChars):
			errorMessage = "ERROR in mapStructureToData() - somehow we have mismatching tokenList and gTokenLocationLinesChars - exiting" 
			errorRoutine(errorMessage)
			return False
			
		# Find index of the first token selected (this is the index of just tokens, not necessarily variable). Then we will compare it with the globalTokenListIndex for each variable
		selectionStartIndex = -100000
		i = 0
		for i in range(len(gTokenLocationLinesChars)):
			if (selectionRangeStartLineNum < gTokenLocationLinesChars[i][0][0]) or ((selectionRangeStartLineNum == gTokenLocationLinesChars[i][0][0]) and (selectionRangeStartCharNum < gTokenLocationLinesChars[i][0][1])):
				selectionStartIndex = i
				break
			elif ((gTokenLocationLinesChars[i][0][0] <= selectionRangeStartLineNum <= gTokenLocationLinesChars[i][1][0]) and
				  (gTokenLocationLinesChars[i][0][1] <= selectionRangeStartCharNum <= gTokenLocationLinesChars[i][1][1])):
				selectionStartIndex = i
				break
				
		# Find index of the last token selected (this is the index of just tokens, not necessarily variable). Then we will compare it with the globalTokenListIndex for each variable
		selectionEndIndex = -100000
		i = len(gTokenLocationLinesChars)-1
		while i >= 0:
			if (selectionRangeEndLineNum > gTokenLocationLinesChars[i][1][0]) or ((selectionRangeEndLineNum == gTokenLocationLinesChars[i][1][0]) and (selectionRangeEndCharNum > gTokenLocationLinesChars[i][1][1])):
				selectionEndIndex = i
				break
			elif ((gTokenLocationLinesChars[i][0][0] <= selectionRangeEndLineNum <= gTokenLocationLinesChars[i][1][0]) and
				  (gTokenLocationLinesChars[i][0][1] <= selectionRangeEndCharNum <= gTokenLocationLinesChars[i][1][1])):
				selectionEndIndex = i
				break
			i = i - 1

		variableSelectedIndices = []
		if (0 <= selectionStartIndex < len(gTokenLocationLinesChars)) and (0 <= selectionEndIndex < len(gTokenLocationLinesChars)):
			k = 0
			while k in range(len(variableDeclarations)):
				item = variableDeclarations[k]
				if variableDeclarations[k][4]["variableId"] != k:
					errorMessage = "ERROR - wrong value of variableId - exiting"
					errorRoutine(errorMessage)
					return False
				elif (selectionStartIndex <= item[4]["globalTokenListIndex"] <= selectionEndIndex):
					variableSelectedIndices.append(item[4]["variableId"])
				k += 1
		PRINT("variableSelectedIndices =",variableSelectedIndices)
		PRINT("variableIdsInGlobalScope[variableId, scopeStartVariableId, scopeEndVariableId] =",variableIdsInGlobalScope)
		dumpDetailsForDebug()
		
		self.selectVariablesAtGlobalScope()
		self.calculateColoredVarsIdOffsetSize()
		self.performInterpretedCodeColoring()
		self.displayAndColorDataWindows()
		self.displayBottomTreeWindow()
		
	#################################################################################################################################################
	#                                                                                                                        						#
	#	Calculate the coloredVarsIdOffsetSize and totalBytesToReadFromDataFile based on the variablesAtGlobalScopeSelected and dataLocationOffset   #
	#                                                                                                                        						#
	#################################################################################################################################################
		
	def selectVariablesAtGlobalScope(self, event=None):
		global variablesAtGlobalScopeSelected, globalScopesSelected
		
		# variableIdsInGlobalScope - the global variables that have level=0, including the typedefs. Its format is [variableId, scopeStartVariableId, scopeEndVariableId]
		# globalScopesSelected - A subset of the variableIdsInGlobalScope, excluding the builtin typedefs, and rest of the typedefs too depending on the value of the MAP_TYPEDEFS_TOO
		# variablesAtGlobalScopeSelected - A subset of globalScopesSelected, depending on the user selection (captured by variableSelectedIndices)
		
		globalScopesSelected = []
		PRINT ("Original variableIdsInGlobalScope = ", variableIdsInGlobalScope)
		for i in range(len(variableIdsInGlobalScope)):
			varIndex = variableIdsInGlobalScope[i][0]
			PRINT("i =",i,"variableDeclarations[varIndex] =",variableDeclarations[varIndex])
			if 'typedef' in variableDeclarations[varIndex][2]: 
				if MAP_TYPEDEFS_TOO:
					PRINT("Counting typedefs")
					# We can never select builtin typedefs since there is no code to color
					if variableDeclarations[varIndex][4]["globalTokenListIndex"] >= 0:
						globalScopesSelected.append(variableIdsInGlobalScope[i])
				else:	
					PRINT("Cannot count typedefs")
				pass
			else:
				PRINT("Counting non-typedef")
				globalScopesSelected.append(variableIdsInGlobalScope[i])
				
		PRINT ("variableIdsInGlobalScope = ", variableIdsInGlobalScope)
		PRINT ("Modified globalScopesSelected = ", globalScopesSelected)
		
		# We want to find out which all variable ids in a contiguous area will be included. Basically, if you select ANY variable under a global-scope-variable,
		# ALL the variables under that global scope get selected.
		
		variablesAtGlobalScopeSelected = []
		# Now check which all variables at the Global scope should be colored
		# Remember that variableIdsInGlobalScope list of the format [variableId, scopeStartVariableId, scopeEndVariableId]
		# So, the chosen varIndex must match either the global variable iteself, or must lie within its scope
		for varIndex in variableSelectedIndices:
			for item in globalScopesSelected:
				if varIndex == item[0] or (item[1] <= varIndex <= item[2]):
					if item[0] not in variablesAtGlobalScopeSelected:
						variablesAtGlobalScopeSelected.append(item[0])
		PRINT("\nNow variablesAtGlobalScopeSelected =",variablesAtGlobalScopeSelected)
		
		if not variablesAtGlobalScopeSelected:
			dumpDetailsForDebug(True)
		
		# This part below also gets copied identically in processBatch(). So, if you make any changes here, please also make changes there.
		
		# Now, if the variablesAtGlobalScopeSelected have some global-scoped variables that have global-scoped buddies, the buddies must get selected too.
		# This happens when we have #RUNTIME statements outside any struct definition
		if globalScopedBuddies:
			PRINT("\n\nThe current variablesAtGlobalScopeSelected =",variablesAtGlobalScopeSelected)
			selectTheseBuddiesToo = []
			for var in variablesAtGlobalScopeSelected:
				for buddyGroup in globalScopedBuddies:
					if var in buddyGroup:
						indexVal = buddyGroup.index(var)
						temp = buddyGroup[:indexVal]+buddyGroup[indexVal+1:]
						for t in temp:
							# Do not select something that is already selected (or will be selected)
							if t not in variablesAtGlobalScopeSelected and t not in selectTheseBuddiesToo:
								PRINT("Adding global-scoped varaible id",t,"because global-scoped variableId",var,"was chosen")
								selectTheseBuddiesToo.append(t)
			if selectTheseBuddiesToo:
				variablesAtGlobalScopeSelected.extend(selectTheseBuddiesToo)
				variablesAtGlobalScopeSelected.sort()
				PRINT("The final variablesAtGlobalScopeSelected =",variablesAtGlobalScopeSelected)
		else:
			PRINT("\n\nBlank globalScopedBuddies[] - unchanged variablesAtGlobalScopeSelected =",variablesAtGlobalScopeSelected)
		
	#####################################################################################################################################
	#                                                                                                                        			#
	#	Calculate the coloredVarsIdOffsetSize and totalBytesToReadFromDataFile based on the variablesAtGlobalScopeSelected and dataLocationOffset   #
	#                                                                                                                        			#
	#####################################################################################################################################
		
	def calculateColoredVarsIdOffsetSize(self, event=None):
		PRINT("\n\n\n","==="*50,"\nInside calculateColoredVarsIdOffsetSize()\n","==="*50)
		
		# Extra for GUI BEGIN
		self.removeColorTags()
		self.setDataOffsetToZeroIfBlank()
		# Extra for GUI END

		returnStatus = populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize()
		if returnStatus == False:
			OUTPUT("Error in calculateColoredVarsIdOffsetSize() after calling populateUnraveledReadDataBlockCalculateColoredVarsIdOffsetSize()")
			sys.exit()
		
		return True
		
	##########################################################################################################################
	#                                                                                                                        #
	#	Color-codes the Interpreted Code window  (it already assumes that coloredVarsIdOffsetSize has been re-calculated)    #
	#                                                                                                                        #
	##########################################################################################################################
	#
	# We must color the Code window first before we color the Data window. Why? Read below.
	#
	# A tag is how we associate certain characteristic of the displayed text (like what is the foreground, what is the background etc.) in a widget.
	# The way a widget identifies a tag is by its name, which is a string. So be extremely careful of what tag name you are using.
	#
	# There are two kinds of color tags we use for both the Code and Data windows (by "Data", we mean both "Hex" and "ASCII" windows since they go in lockstep):
	# 
	#  1. Fixed Foreground color tags - they change only the foreground color, and they are not transient (not dependent on cursor movement). They apply to both Code and Data. 
	#                                   They are different for different variables (the color changes). However, when the number of variables become too high, we reuse.
	#                                   The list colorTagsFG contains the names of all FG color tags, and they apply to both the Code and Data windows.
	#  2. Transient Background color tags - they change the background color, and they are transient (depends on cursor movement). They apply to both Code and Data.
	#                                       We use one single background color (Yellow currently, but changeable) for ALL such tags.
	#                                   Since they are not fixed, we "bind" them to fixed tags based on the cursor move.
	#									In the Code window,  we bind these transient tags onto the tags whose names are sored in colorTagsFG[].
	#									In the Data windows, we bind these transient tags onto the tags whose names are sored in colorTagsData[].
	#
	# 
	# 	Code window - Foreground (fixed) tag names are stored in the array colorTagsFG[]. Background (transient) tags bind to each FG tag.
	# 	Data window - Foreground (fixed) tag names are stored in the array colorTagsFG[]. Background (transient) tags bind to each tag in the array colorTagsData[]. 
	#
	# The dimension of both these colorTagsFG[] and colorTagsData[] is NOT the same. 
	# 	1. colorTagsFG[]   has same number of entries as coloredVarsIdOffsetSize[].
	# 	2. colorTagsData[] has same number of entries as coloredDataIdOffsetSize[].
	#
	# If there are any arrays, colorTagsData[] will have more entries. This is because if we have a code like "int var[3];", then in coloredVarsIdOffsetSize[]
	# we will have a single entry for the var with size 12. On the other hand, in coloredDataIdOffsetSize[] we will have four entries - one for the var with size 12,
	# and three more entries for var[0], var[1], and var[2]. Basically, in the Data window, we highlight every data region that can have a value. So each array element
	# will have its own row. However, since all these array elements are contiguous and they all have same foreground color, we can have a single entry for them
	# in the coloredVarsIdOffsetSize[]. This is why coloredVarsIdOffsetSize[] is a subset of coloredDataIdOffsetSize[].
	#
	# Once again - the FG tags (whose tagnames are stored in colorTagsFG[]) serve BOTH the Code and Data windows. However, the tags whose names are stored in colorTagsData[]
	# are kind of "dummy" tags - they are only used in the Data windows, they do NOT paint any FG color, all they do is to serve as an empty tag to which we can "bind"
	# the cursor movements ("Enter" and "Leave").
	#
	# One crucial point to remember - these two arrays do not store the actual tags - they just store the tag name strings to help as a reference.
	# In order words, just adding an entry to this array does not create the actual tag, and removing it from the array does not delete it.
	# Just make sure that we do not reuse the same tagnames. So, if we are using the "FGcolorTag" prefix for the tagnames stored in colorTagsFG[],
	# absolutely ensure that we use a different prefix (like "DataTagBG") for the colorTagsData[]. This is because while the tags from colorTagsData[]
	# are NOT used in the Code window (they are only used in the Data windows), the tags from colorTagsFG[] are used in BOTH Code and Data windows.
	# Therefore, if we use the same suffix for both colorTagsFG[] and colorTagsData[], we will be messing up the foreground colors.
	# 
	#
	# As an example, suppose we have the following code where coloredVarsIdOffsetSize contain these 4 variables: i, c, f and s.
	# Whenever we have an array, we have only the header row in colorTagsFG[], but for colorTagsData[], we have the header row plus one row per array element.
	#   ____________________________________________________________________________________________________________________________________
	#   |  Code                            |    colorTagsFG[]             |          colorTagsData[]
	#   |__________________________________|______________________________|__________________________________________________________________
	#   |                                  |   [             		      |     [
	#   |  int i;                          |     "FGcolorTag0",           |       "DataTagBG0",
	#   |  char c[2];                      |     "FGcolorTag1",           |       "DataTagBG1","DataTagBG2","DataTagBG3",
	#   |  float f;                        |     "FGcolorTag2",           |       "DataTagBG4",
	#   |  short s[2][3];                  |     "FGcolorTag3"            |       "DataTagBG5","DataTagBG6","DataTagBG7","DataTagBG8","DataTagBG9","DataTagBG10","DataTagBG11"
	#   |__________________________________|____]_________________________|______]____________________________________________________________
	#    
	#
	# Observe that we are using the same color tag (from colorTagsData[]) for both the Hex and ASCII window. That works, because Hex and ASCII go in lockstep.
	#
	# Regarding the Transient tags, when you hover cursor in the Code window, it causes transient tags to appear in the Data windows, and vice versa. 
	# So, in terms of the Transient tags, it does not matter whether you execute the routine of coloring the Code or Data first. However, about the fixed color tags,
	# you have to know how many tags to generate, and if it an array variable then there are multiple tags on the Data window for one single variable.
	# So, this is why we need to execute this routine first - so that we know which all Fixed color tags (for different variables) are to be generated.
	# And for this very reason performInterpretedCodeColoring() must be run before displayBottomTreeWindow().
	#
	# Now, for each mapped variable in the Code window, we want certain data to be displayed (Address start/end, LE/BE value, length, Description etc.). 
	# So, for each tag in colorTagsFG[], we bind the tag with "Enter" and "Leave" actions, which represent the actions to be taken when the cursor 
	# "enters" or "leaves" the variable space within the Code window. 
	#  - "Enter" - display  the information related to that variable (Address start/end, LE/BE value, length, Description etc.) just above the tree window.
	#  - "Leave" - Wipe out the information related to that variable (Address start/end, LE/BE value, length, Description etc.) just above the tree window.
	# Recall that this actions above has absolutely nothing to do with whether the data corresponding to the variable is currently being displayed in the Data window or not.
	# However, if the variable's data DOES get displayed within the current Data window, then we do the ADDITIONAL actions for the "Enter" and "Leave" events:
	#  - "Enter" - Add the "yellowbg" tag to a certain area of the Data windows (ASCII and Hex) that represents the the data corresponds to the variable
	#  - "Leave" - Delete the "yellowbg" tag from a certain area of the Data windows (ASCII and Hex) that represents the the data corresponds to the variable
	#
	# The same (actually reverse) kind of behavior happens for the dummy tags stored in colorTagsData[].
	#
	# Now, as stated earlier, just by storing the tag name in a user-defined array means nothing. If we want to see the effect of the tag, we have to do this:
	#  - tag_configure - this pretty much creates a color tag for a GUI object like the viewDataHexText. You tell what's the tag's names, what's its property (like color etc.)
	#  - tag_add       - this actually "applies" the tag (shows its effect) to that GUI object, for the area mentioned (start line/col #, end line/col #)
	#  - tag_remove    - this actually "removes" the tag (remotes its effect) from that GUI object, for the area mentioned (start line/col #, end line/col #)
	#
	########################################################################################################################################################################
		
	def performInterpretedCodeColoring(self, event=None):

		PRINT ("\n"*3,"==="*50,"\n Inside performInterpretedCodeColoring(), for data Offset =",dataLocationOffset)
		PRINT ("File Offset = self.fileOffset.get() =",self.fileOffset.get(),"\n","=="*50,"\n"*3)
		
		PRINT ("We have the coloredVarsIdOffsetSize =",coloredVarsIdOffsetSize)
		PRINT ("Recall that coloredVarsIdOffsetSize has absolute offsets, not relative to the display window")
		
		if not coloredVarsIdOffsetSize:
			return True

			
		# Recall that coloredVarsIdOffsetSize[] may contain multiple rows for the same variable( like for this case:   struct S{int i;} var[5];)
		# where there will be one row for var but 5 rows for i (because the variable i is being instantiated in 5 different places).
		# So, we want to find out how many unique variableIds are there. We do NOT want to have the same variable to have muliple colors in the Data windows.
		
		uniqueVariableIdList = []
		for row in coloredVarsIdOffsetSize:
			if row[0] not in uniqueVariableIdList:
				uniqueVariableIdList.append(row[0])

		# So, the number of unique variableIds could be less than the number of rows in coloredVarsIdOffsetSize[].
		# Even that reduced number might be so big that we may need to reuse colors.
		if len(uniqueVariableIdList) <= 10:
			self.COLORS = COLORS_10
		elif len(uniqueVariableIdList) <= 20:
			self.COLORS = COLORS_20
		else:
			self.COLORS = COLORS_ALL
			
		# So, number of colors used 		<= 		number of rows in uniqueVariableIdList 			<= 			number of rows in coloredVarsIdOffsetSize
		
		PRINT ("Number of color tags to be created = ", len(uniqueVariableIdList) )
		self.removeColorTags()

		# Iterate over all the rows in coloredVarsIdOffsetSize. Find its variableId, find the associated FG color tag, and color the Code, Hex and ASCII windows with that FG.
		
		for i in range(len(coloredVarsIdOffsetSize)):
		
			variableId 			= coloredVarsIdOffsetSize[i][0]
			variableName 		= variableDeclarations[variableId][0]
			variableDescription = variableDeclarations[variableId][4]["description"] 
			signedOrUnsigned 	= variableDeclarations[variableId][4]["signedOrUnsigned"]
			datatype 			= variableDeclarations[variableId][4]["datatype"]
			isArray 			= variableDeclarations[variableId][4]["isArray"]
			arrayDimensions 	= variableDeclarations[variableId][4]["arrayDimensions"] if isArray else []
			isBitField 			= variableDeclarations[variableId][4]["isBitField"]
			
			# We follow the convension that the variables will pick their color from the color list (self.COLORS) exactly in the same order as in uniqueVariableIdList.
			# Which means, if a variableId comes in the third position in the uniqueVariableIdList, then it will pick up the third color in self.COLORS.
			try:
				indexInUniqueVariableIdList = uniqueVariableIdList.index(variableId)
			except ValueError:
				OUTPUT("Error in coding performInterpretedCodeColoring() - while processing coloredVarsIdOffsetSize[i=",i,"], somehow cannot find variableId =",variableId,"in uniqueVariableIdList =",uniqueVariableIdList)
				sys.exit()
				
			# Now, iterate over all the unique variableIds to assign a color tage to them, so that all the rows in coloredVarsIdOffsetSize with the same variableId
			# will use that exact FG color tag.
			self.colorTagsFG.append("FGcolorTag"+str(i))
			self.interpretedCodeText.tag_configure	(self.colorTagsFG[i], foreground=self.COLORS[indexInUniqueVariableIdList%len(self.COLORS)])
			self.viewDataHexText.tag_configure  	(self.colorTagsFG[i], foreground=self.COLORS[indexInUniqueVariableIdList%len(self.COLORS)])
			self.viewDataAsciiText.tag_configure	(self.colorTagsFG[i], foreground=self.COLORS[indexInUniqueVariableIdList%len(self.COLORS)])
				
			currentFGcolorTagName = self.colorTagsFG[i]
			
			PRINT("Coloring variable",variableName,"with FG color tag",currentFGcolorTagName,", which corresponds to FG color", self.COLORS[indexInUniqueVariableIdList%len(self.COLORS)])
			
			# Now, up to this point, we have merely created ALL the FG color tags for the Code and Data windows. But we do not know exactly where they will apply.
			
			# For the Interpreted code window, find out the locations of the variable names (to which the tag would apply) and apply the FG color. 
			# Since the FULL interpreted code is loaded here (along with a scrollbar), we do not need to worry whether the variable is visible or not.
			# We treat every variable in the Interpreted code window as visible, and color them.
			tokenStartLineNum = gTokenLocationLinesChars[variableDeclarations[variableId][4]["globalTokenListIndex"]][0][0]
			tokenStartCharNum = gTokenLocationLinesChars[variableDeclarations[variableId][4]["globalTokenListIndex"]][0][1]
			tokenEndLineNum = gTokenLocationLinesChars[variableDeclarations[variableId][4]["globalTokenListIndex"]][1][0]
			tokenEndCharNum = gTokenLocationLinesChars[variableDeclarations[variableId][4]["globalTokenListIndex"]][1][1]
			codeVarStart = str(tokenStartLineNum+1)+"."+str(tokenStartCharNum)		# Remember that on Text the line number starts from 1, not 0
			codeVarEnd   = str(tokenEndLineNum  +1)+"."+str(tokenEndCharNum+1)		# Remember that on Text the line number starts from 1, not 0
			
			# Color the foreground of the variable location within the Code window. We will FG color the appropriate regions of the Data (Hex/ASCII) windows later,
			# since we first need to know if the current display window actually holds the data corresponding to the variable or not. Remember that there is no 
			# scrollbar on the Data windows - we load only DISPLAY_BLOCK sized data everytime.
			PRINT ("Going to apply the tag",self.colorTagsFG[i],"in interpreted code window from",codeVarStart,"to", codeVarEnd, "for variable",i,variableDeclarations[variableId][0],", with variableDescription =",variableDescription )
			self.interpretedCodeText.tag_add(self.colorTagsFG[i], codeVarStart, codeVarEnd)
			
			# Now, we know exactly where the fixed tags of the Interpreted Code window will apply, but we haven't associated that with the tags yet.

			# Next, populate the fields that pop up when you hover the cursor above the variable. Below we populate the Addr start, Addr end, and length
			unraveledRowNumber = coloredVarsIdOffsetSize[i][3]
			if isBitField:
				actualDataAddrStart = "0x{:08X}".format(unraveled[unraveledRowNumber][3])+"."+STR((unraveled[unraveledRowNumber][2]["bitOffsetWithinStruct"])%BITS_IN_BYTE)
				actualDataAddrEnd   = "0x{:08X}".format(unraveled[unraveledRowNumber][3]+bit2Byte((unraveled[unraveledRowNumber][2]["bitOffsetWithinStruct"]%BITS_IN_BYTE)+unraveled[unraveledRowNumber][2]["bitFieldWidth"]-1))+"."+STR((unraveled[unraveledRowNumber][2]["bitOffsetWithinStruct"]+unraveled[unraveledRowNumber][2]["bitFieldWidth"]-1)%BITS_IN_BYTE)		# This byte is INCLUDED
				dataLengthValue = STR(unraveled[unraveledRowNumber][2]["bitFieldWidth"]) + " bit" + ("" if unraveled[unraveledRowNumber][2]["bitFieldWidth"] <=1 else "s")
			else:
				actualDataAddrStart = "0x{:010X}".format(unraveled[unraveledRowNumber][3])
				actualDataAddrEnd = "0x{:010X}".format(unraveled[unraveledRowNumber][4]-1)		# This byte is INCLUDED
				dataLengthValue = STR(coloredVarsIdOffsetSize[i][2])+" byte" + ("s" if coloredVarsIdOffsetSize[i][2] > 1 else "")
			
			valueLE = unraveled[unraveledRowNumber][6]
			valueBE = unraveled[unraveledRowNumber][7]
			valueLEStr = str(valueLE)
			valueBEStr = str(valueBE)

			if PRINT_ENUM_LITERALS and variableDeclarations[variableId][4]["enumType"]!=None:
				
				PRINT("Printing enum literals for variableId",variableId,", valueLE=",valueLE)
				returnEnumLiteralForValueResult = returnEnumLiteralForValue(variableId, valueLE)
				if returnEnumLiteralForValueResult[0]==False:
					errorMessage = "Error in performInterpretedCodeColoring(): Cannot find enum literals for variableId "+STR(variableId)+", valueLE="+STR(valueLE)
					errorRoutine(errorMessage)
					return False
				else:
					valueLEStr = returnEnumLiteralForValueResult[1]
					#if the valueLEStr is too big to show, we truncate it
					if len(valueLEStr) > PRINT_ENUM_LITERALS_MAX_SIZE_CHAR:
						valueLEStr = valueLEStr[0:PRINT_ENUM_LITERALS_MAX_SIZE_CHAR] + "..."

				PRINT("Printing enum literals for variableId",variableId,", valueBE=",valueBE)
				returnEnumLiteralForValueResult = returnEnumLiteralForValue(variableId, valueBE)
				if returnEnumLiteralForValueResult[0]==False:
					errorMessage = "Error in performInterpretedCodeColoring(): Cannot find enum literals for variableId "+STR(variableId)+", valueBE="+STR(valueBE)
					errorRoutine(errorMessage)
					return False
				else:
					valueBEStr = returnEnumLiteralForValueResult[1]
					#if the valueBEStr is too big to show, we truncate it
					if len(valueBEStr) > PRINT_ENUM_LITERALS_MAX_SIZE_CHAR: 
						valueBEStr = valueBEStr[0:PRINT_ENUM_LITERALS_MAX_SIZE_CHAR] + "..."




			# Now time to add the cursor-movement on Code window, that will do the following:
			# 	1) Add the background color to the Hex and ASCII windows
			# 	2) Display the Start/End addresses, Datalength, and LE/BE values in the thin frame (right above the bottom tree window)
			
			# We check if the value corresponding to the variable exists within the current display window (whether the return value from getDataCoordinates() is true or not)
			# If the return value from getDataCoordinates() is False, that means the data corresponding to this variable does not exist within the current display window.

			getDataCoordinatesResult = self.getDataCoordinates( coloredVarsIdOffsetSize[i][1], coloredVarsIdOffsetSize[i][1]+coloredVarsIdOffsetSize[i][2] )
			
			if getDataCoordinatesResult == False:
				# If the data corresponding to the variable is not within the Displayed Hex/ASCII window, do nothing more in the Code or Data window, and 
				# populate the hovertexts (like start- and end-address, BE/LE values, length etc.). Don't do ANYTHING within the Data windows.
				PRINT ("Data for Variable <",variableName,"> located at File[",  coloredVarsIdOffsetSize[i][1],":", coloredVarsIdOffsetSize[i][1]+coloredVarsIdOffsetSize[i][2], "] is NOT displayable within current window.")
				PRINT ("data offset = ",dataLocationOffset,"and file offset =",fileDisplayOffset,". Hence just being content with the variable description, Start/End Addr, LE/BE values and datalength.")
				PRINT ("Going to apply the tag",self.colorTagsFG[i],"in interpreted code window from",codeVarStart,"to", codeVarEnd, "for variable #",i,variableDeclarations[variableId][0],", with variableDescription =",variableDescription )
				
				self.interpretedCodeText.tag_bind(self.colorTagsFG[i], "<Enter>", 
					lambda event, textValue=variableDescription, addrValueStart=actualDataAddrStart, addrValueEnd=actualDataAddrEnd, 
					lengthValue=dataLengthValue, dataValueLEValue=valueLEStr, dataValueBEValue=valueBEStr, codeVarStartValue=codeVarStart, codeVarEndValue=codeVarEnd:
					[self.CodeDataMeaningText.configure(text=textValue), 
					 self.dataAddressStartText.configure(text=addrValueStart),
					 self.dataAddressEndText.configure(text=addrValueEnd),
					 self.dataLengthText.configure(text=lengthValue),
					 self.dataValueLEText.configure(text=dataValueLEValue),
					 self.dataValueBEText.configure(text=dataValueBEValue),
					 self.interpretedCodeText.tag_add("yellowbg", codeVarStartValue, codeVarEndValue)])		# Newly added

				self.interpretedCodeText.tag_bind(self.colorTagsFG[i], "<Leave>", 
					lambda event, codeVarStartValue=codeVarStart, codeVarEndValue=codeVarEnd:
					[self.CodeDataMeaningText.configure(text=""), 
					 self.dataAddressStartText.configure(text=""), 
					 self.dataAddressEndText.configure(text=""), 
					 self.dataLengthText.configure(text=""), 
					 self.dataValueLEText.configure(text=""),
					 self.dataValueBEText.configure(text=""),
					 self.interpretedCodeText.tag_remove("yellowbg", codeVarStartValue, codeVarEndValue)])		# Newly added

			else: 	# The current display block indeed contains the data corresponding to the current variable.
				printMessage = "For data item # i=<%d>, %s, getDataCoordinates(dataByteStartOffset=%d, dataByteEndOffsetExclusive=%d) = %s!"%(i, variableDescription, coloredVarsIdOffsetSize[i][1], coloredVarsIdOffsetSize[i][1]+coloredVarsIdOffsetSize[i][2], STR(getDataCoordinatesResult))
				PRINT (printMessage )
				PRINT ("Data for Variable <",variableName,"> located at File[",coloredVarsIdOffsetSize[i][1],":", coloredVarsIdOffsetSize[i][1]+coloredVarsIdOffsetSize[i][2], "] is displayable within current window.")
				PRINT ("data offset = ",dataLocationOffset,"file offset =",fileDisplayOffset,"Hence doing all the foreground and background coloring stuff")
				
				# First get the location (line#, char#) of the Data region corresponding to the colored variable
				startStrHex   = getDataCoordinatesResult[0][0]
				endStrHex     = getDataCoordinatesResult[0][1]
				startStrAscii = getDataCoordinatesResult[1][0]
				endStrAscii   = getDataCoordinatesResult[1][1]
				
				# Apply the same FG color to the regions of the Data (Hex/ASCII) windows that correspond to the current variable
				PRINT ("Going to apply the tag",self.colorTagsFG[i],"in Hex window from",startStrHex,"to", endStrHex, "for variable",i,variableDeclarations[variableId][0],", with variableDescription =",variableDescription )
				self.viewDataHexText.tag_add(self.colorTagsFG[i], startStrHex, endStrHex)
				PRINT ("Going to apply the tag",self.colorTagsFG[i],"in Ascii window from",startStrAscii,"to", endStrAscii, "for variable",i,variableDeclarations[variableId][0],", with variableDescription =",variableDescription )
				self.viewDataAsciiText.tag_add(self.colorTagsFG[i], startStrAscii, endStrAscii)

				# By now, the FG coloring has been done for both the interpreted and Data (Hex/ASCII) windows.
				
				# We Now also add the background tags ("yellowbg") for the Hex/ASCII windows only.
				# When we hover over a variable in the Interpreted Code window, its corresponding data in the Hex/ASCII also gets highlighted.
				# We note that the variable in the Code window iteself does NOT get highlighted (this is slightly different behavior from the Data window).
				# When you hover in the Data window, the smallest data item itself gets highlighted too, along with its corresponding variable(s) in the Code window.
				# This difference is because there is no need to highlight the variable in the Code window, since we know exactly which variable we are hovering on.
				# On the other hand, when we are hovering over Data window, we do not know which data item we are hovering upon.
			
				# This is no real list. We just create a fake list so that individual list items (each one is a statement) gets executed.
				# This is a dirty hack, but I don't know how to do it the pythonic way to make multi-statement Lambda functions.
				self.interpretedCodeText.tag_bind(self.colorTagsFG[i], "<Enter>", 
					lambda event, textValue=variableDescription, addrValueStart=actualDataAddrStart, addrValueEnd=actualDataAddrEnd, 
					lengthValue=dataLengthValue, dataValueLEValue=valueLEStr, dataValueBEValue=valueBEStr, 
					HexVarStart=startStrHex, HexVarEnd=endStrHex, AsciiVarStart=startStrAscii, AsciiVarEnd=endStrAscii, codeVarStartValue=codeVarStart, codeVarEndValue=codeVarEnd:
					[self.CodeDataMeaningText.configure(text=textValue), 
					 self.dataAddressStartText.configure(text=addrValueStart),
					 self.dataAddressEndText.configure(text=addrValueEnd),
					 self.dataLengthText.configure(text=lengthValue),
					 self.dataValueLEText.configure(text=dataValueLEValue),
					 self.dataValueBEText.configure(text=dataValueBEValue),
					 self.interpretedCodeText.tag_add("yellowbg", codeVarStartValue, codeVarEndValue),		# Newly added
					 self.viewDataHexText.tag_add("yellowbg", HexVarStart, HexVarEnd),
					 self.viewDataAsciiText.tag_add("yellowbg", AsciiVarStart, AsciiVarEnd)])

					 
				self.interpretedCodeText.tag_bind(self.colorTagsFG[i], "<Leave>", 
					lambda event, HexVarStart=startStrHex, HexVarEnd=endStrHex, AsciiVarStart=startStrAscii, AsciiVarEnd=endStrAscii, codeVarStartValue=codeVarStart, codeVarEndValue=codeVarEnd:
					[self.CodeDataMeaningText.configure(text=""), 
					 self.dataAddressStartText.configure(text=""), 
					 self.dataAddressEndText.configure(text=""), 
					 self.dataLengthText.configure(text=""), 
					 self.dataValueLEText.configure(text=""),
					 self.dataValueBEText.configure(text=""),
					 self.interpretedCodeText.tag_remove("yellowbg", codeVarStartValue, codeVarEndValue),		# Newly added
					 self.viewDataHexText.tag_remove("yellowbg", HexVarStart, HexVarEnd),
					 self.viewDataAsciiText.tag_remove("yellowbg", AsciiVarStart, AsciiVarEnd)])
			
		# After all the tags have been created, do some sanity checks.
		if len(coloredVarsIdOffsetSize) != len(self.colorTagsFG):
			dumpDetailsForDebug()
			errorMessage("Mismatching size of self.colorTagsFG and coloredVarsIdOffsetSize")
			errorRoutine(errorMessage)
			return False

		return True

		
	##########################################################################################################################
	#                                                                                                                        #
	#	Run a Demo                                                                                                           #
	#                                                                                                                        #
	##########################################################################################################################
	def runDemo(self, event=None):
		global IN_DEMO
		IN_DEMO = True
		# 1.0 features
		warningMessage = "First we are going to demonstrate the ParseAndC 1.0 features. \n\n(This is for users who may not be familiar with this tool beforehand)."		\
						+"\n\nThere will be a lot of pop-up messages, but I would really appreciate if you actually read the entirety of those messages before "		\
						+"pressing the OK to continue."
		warningRoutine(warningMessage)
		warningMessage = "The biggest problem with writing a C parser is that even when you use the correct input data format (a C structure), there is no guarantee that "	\
						+"the parser's output will be correct. This is because while C allows to read a whole structure in one go, it does not have any function that can "	\
						+"print all the contents of a structure individually - one must manually write individual printf() statements for each struct member "				\
						+"(and do it recursively if the struct member is a struct itself)."																					\
						+"\n\nThis process is error-prone. What we want is a way where just by giving a correct input structure, we are somehow guaranteed to be able to "	\
						+"see all the individual struct member values correctly.\n\nThis is not a trivial problem, and it is exactly what we solved in 1.0 version."
		warningRoutine(warningMessage)
		warningMessage = "Let's see that in action. First we are going to use an arbitrary datastream to be parsed (contained within this program). \n\nPress OK to continue."
		warningRoutine(warningMessage)
		demoIndex = 0
		self.openDataFile(demoIndex)
		warningMessage = "You can see that the datastream has been loaded on the Data windows on the right. "		\
						+"\n\nNext we are going to use some code as the input format of the datastream to be parsed. \n\nPress OK to continue."
		warningRoutine(warningMessage)
		self.openCodeFile(demoIndex)
		warningMessage = "Now that you can see the code on the left and the data on the right, we are going to interpret the code. \n\nPress OK to continue."
		warningRoutine(warningMessage)
		self.interpret()
		warningMessage = "Now you can see the interpreted code in the middle window, we are going to map the interpreted code to the data. Press OK to continue."
		warningRoutine(warningMessage)
		self.mapStructureToData()
		warningMessage = "We map the data format from the offset of 0 by default. Of course, we can change that. \n\nLet's see what happens when we map it from one-fourth "	\
						+"of a Kilobyte. You can specify this in any format, as pure 256, or 0x100, or even 1KB/4, which is very much human readable. Press OK to continue."
		warningRoutine(warningMessage)
		self.dataOffsetEntry.insert(tk.END,"1KB/4")
		self.dataOffset.set(256)
		self.mapStructureToData()
		warningMessage = "Now you see, that data mapping is happening from the offset of 0x100. Press OK to continue."
		warningRoutine(warningMessage)
#		warningMessage = "We selected ALL the gloabal-level variables for mapping. But, during regular run (not in Demo) you could also select any Interpreted code segment using your mouse and click on the Map button, and all the top-level global variables within that selection will get mapped. Press OK to continue."
#		warningRoutine(warningMessage)
#		self.interpretedCodeText.see("1000.0")
#		self.interpretedCodeText.see("65.0")
		warningMessage = "At the end of the demo (not now), once all these warning windows go away, you will be able to take your cursor above various colored items "	\
						+"in the interpreted code window and the data window and see how the Description, Address and Values are shown below. \n\nYou will also be "	\
						+"able to play with the Expand/Collapse buttons to see the internals of the mapped variables.\n\nPress OK to continue."
		warningRoutine(warningMessage)
		
		# 2.0 features
		self.clearDemo()

		warningMessage = "Till now, what you saw was ParseAndC 1.0 features. Next we are going to show you 2.0 features." 					\
						+"\n\nWe will first summarize the deltas (new features), and then go through demo of each feature one by one. "		\
						+"\n\nPlease bear with me for a few more clicks. Press OK to continue."
		warningRoutine(warningMessage)
		warningMessage = "We make a rather tall claim with ParseAndC 2.0 - whatever we can do in a regular C program for parsing, we can do it via sheer Structure "	\
						+"definition alone - NO separate parser program needed. \n\nSounds crazy, right?"
		warningRoutine(warningMessage)
		warningMessage = "How is that even possible? In a C program, we can do stuff that is not possible to do statically. For example, while parsing a network packet, "	\
						+"we might first parse the field designating the packet header length, and only after we deduce the header length, "								\
						+"we get to know how many more bytes to read for decoding the full header. How would we do that statically, by a single structure definition alone?"
		warningRoutine(warningMessage)

		warningMessage = "We achieve it via introducing the following new features in ParseAndC 2.0:\n" 	\
						+"\n1. Dynamic structures with runtime branching "									\
						+"\n2. Variable-length arrays "														\
						+"\n3. Variable-width bitfields"													\
						+"\n4. Verification via Initialization"												\
						+"\n5. Looping and Dimension-less array"											\
						+"\n6. Speculative execution and C strings"											\
						+"\n7. Unknown data offset? No problem!"											\
						+"\n\nAnd the best part - we do ALL these while NOT changing the C syntax!!!"		\
						+"\n\nNow we will demo each of these features in detail."
		warningRoutine(warningMessage)
		'''
		warningMessage = "With ParseAndC 2.0, we introduce the concept of \"Dynamic\" structures. They look very much like C structures, with some hidden extra powers." 	\
						+"\n\n1) The biggest difference is, anything that is supposed to be a constant in a C structre (like array dimension, bitfield width etc.) "		\
						+"is now allowed to be an expression involving prior variables."																					\
						+"\n\nThis captures the information-flow-capability of C programs, where we assign values to later variables based on the value of the prior variables."
		warningRoutine(warningMessage)
		warningMessage = "The second additional power of dynamic structures is that, just like we have preprocessing commands (like #define/#if/#elif/#else/#endif) in C, "	\
						+"in Dynamic structures we have #RUNTIME commands that operates on runtime variables rather than compile-time constants."							\
						+"\n\nThis captures the branching capability of C programs."
		warningRoutine(warningMessage)
		warningMessage = "The third additional power of dynamic structures is verification, where we re-use the C's initialization statement and use it as an "				\
						+"assert statement instead. \n\nIn Dynamic structures, we can have complex conditions to tell if our struct fields have their intended value(s)."	\
						+"\n\nThis is very helpful to see if our data makes sense or not."
		warningRoutine(warningMessage)
		warningMessage = "The fourth and final new power of dynamic structures is speculative execution and dimension-less arrays. "									\
						+"\n\nDimension-less arrays are nothing but arrays with dimension value of inifinity, which means they will never terminate." 					\
						+"\n\nSo, we provide a verifification statement as the termination criteria, and speculatively execute all possible array dimension values "	\
						+"until that termination criteria gets satisfied. This allows us to parse even when we do not know from offset to parse from, as long as we "	\
						+"know the expected values of certain key fields."
		warningRoutine(warningMessage)
		warningMessage = "Sorry about the wall of text. Now let's see these features in action.\n\n\n (drum roll) "									
		warningRoutine(warningMessage)
		'''
		# Feature # 1: Branching
		self.clearDemo()
		warningMessage = "Feature # 1: Braching. "			\
						+"\n\nWith ParseAndC 2.0, we introduce the concept of \"Dynamic\" structures. They look very much like C structures, with some hidden extra powers." 	\
						+"\n\nNow let's look at some branching capability, where the same strucure may contain different set of member variables at runtime."
		warningRoutine(warningMessage)
		demoIndex = 1
		self.openCodeFile(demoIndex)
		self.openDataFile(demoIndex)
		warningMessage = "Please pay close attention to the #commands. In C, a conditional preprocessor command may only contain fields who values are known statically, "	\
						+"i.e during compile time. However, in this code, the condition (#if parentCount == 2) contains a variable whose value would only be known "		\
						+"at the runtime.\n\nThat is why when we will compile this code, these #if-#else-#endif statements will persist. \n\nPress OK to interpret."
		warningRoutine(warningMessage)
		self.interpret()
		warningMessage = "As expected, these #if-#else-#endif statements did not go away even in the interpreted code. We call these as \"Runtime statements\". "			\
						+"\n\nPress OK to map this data."
		warningRoutine(warningMessage)
		self.mapStructureToData()
		warningMessage = "As you can see, depending on the runtime data, only one side of the decision tree got executed. "		\
						+"\n\nLet's change the mapping offset so that we can see how the other branch of the branch condition also gets executed."
		warningRoutine(warningMessage)
		self.dataOffsetEntry.insert(tk.END,"12")
		self.dataOffset.set(12)
		self.mapStructureToData()
		warningMessage = "So, the same structure can now behave differently based on the runtime data. Who would have thunk!!"
		warningRoutine(warningMessage)
		warningMessage = "Now, we would like to remind that Dynamic structures can have both statically-resolvable preprocessor commands and dynamically-resolvable "	\
						+"Runtime statements. They can absolutely coexit Let's see that in the next example.!!"
		warningRoutine(warningMessage)
		self.clearDemo()
		
		# Both statically and dynamically coexiting
		demoIndex = 2
		self.openCodeFile(demoIndex)
		self.openDataFile(demoIndex)
		warningMessage = "We have loaded a new Dynamic structure that contains BOTH Regular preprocessing commands and Runtime statements. "		\
						+"\n\nWhen we interpret this, we will see that the compile-time preprocessor statements will no longer exist in the interpreted code, "		\
						+"but runtime statements will continue to be there."
		warningRoutine(warningMessage)
		self.interpret()
		warningMessage = "As predicted, after inpretation, only the runtime statements remain. Press OK to map the data."
		warningRoutine(warningMessage)
		self.mapStructureToData()
		warningMessage = "Again, only one side of the decision tree got executed. "		\
						+"\n\nLet's change the mapping offset so that we can see how the other branch of the branch condition also gets executed."
		warningRoutine(warningMessage)
		self.dataOffsetEntry.insert(tk.END,"12")
		self.dataOffset.set(12)
		self.mapStructureToData()
		warningMessage = "So, the same structure can now behave differently based on the runtime data.!!"
		warningRoutine(warningMessage)



		# Feature # 2: Variable length array 
		
		self.clearDemo()
		warningMessage = "Feature # 2: Variable-length array\n\nIn C structures, all array dimensions must be constant - it cannot be coming from another runtime variable. "	\
						+"\n\nAgain, we are talking about C structures, not general C programs."
		warningRoutine(warningMessage)
		demoIndex = 3
		self.openCodeFile(demoIndex)
		self.openDataFile(demoIndex)
		warningMessage = "The array dimension of packet_data is one plus \"packet_length\", which is the previous struct member. \n\nWe cannot do this in C structure."		\
						+"\n\nPress OK to interpret and map this Dynamic structure on the data."
		warningRoutine(warningMessage)
		self.interpret()
		self.mapStructureToData()
		warningMessage = "You can see that inside the data, the size of the packet_data is indeed designated by the value of packet_length ("+STR(getRuntimeValue(['packet_length'])[1])+")"
		warningRoutine(warningMessage)
		warningMessage = "Caveat: With great power, comes great responsibility.\n\nEarlier, the C compiler mandated that an array dimension of a struct member variable "		\
						+"must be a non-negative integer constant (NOT a runtime variable), but Dynamic strucures allow that. However, now it is the job of the coder "			\
						+"to ensure that the array dimension value (that gets resolved during runtime) is indeed a positive integer."
		warningRoutine(warningMessage)

		self.clearDemo()
		
		# Feature # 3: Variable length Bitfield 
		
		warningMessage = "Feature # 3: Variable-width Bitfield\n\nIn C structures, all bitfield widths must be constant - it cannot be coming from another runtime variable."
		warningRoutine(warningMessage)
		demoIndex = 4
		self.openCodeFile(demoIndex)
		self.openDataFile(demoIndex)
		warningMessage = "Here the bitfield width (num_flags) for the struct member variable bit_flags - it comes from the "	\
						+"previous struct member variable num_flags. \n\nWe cannot do this in C structure."
		warningRoutine(warningMessage)
		self.interpret()
		self.mapStructureToData()
		warningMessage = "You can see that inside the data, the size of the bit_flags is indeed designated by the value of num_flags ("+STR(getRuntimeValue(['num_flags'])[1])+")."
		warningRoutine(warningMessage)

		
		self.clearDemo()

		# Feature # 4: Verification via Initialization

		warningMessage = "Feature # 4: Verification via Initialization.\n\nIn C, when we declare a variable, we can initialialize it to a value. "						\
						+"\n\nHowever, when we declare a C struct for parsing (reading) some data, initialization makes no sense (as there is no writing involved)."	\
						+"\n\nPress OK to continue."
		warningRoutine(warningMessage)
		demoIndex = 5
		self.openCodeFile(demoIndex)
		self.openDataFile(demoIndex)
		self.interpret()
		warningMessage = "We turn the tables here. We use the \"initialization\" as \"verification\", i.e., if a variable var_A is initialized to some value val_A in the "	\
						+"struct definition, we expect var_A to have the value of val_A after parsing. If not, a warning will be issued. "									\
						+"\n\nNow that you can see the code on the left describing the ELF identification header and a sample a.out file on the right, we are going to "	\
						+"map this this ELF header onto the data. If the magic number indeed matches, no warning would be issued."
		warningRoutine(warningMessage)
		self.mapStructureToData()
		warningMessage = "As you saw, the initialization value check did succeed (no warning message popped up). Let's re-map the data from a wrong offset (0x10). "	\
						+"and see what happens"	
		warningRoutine(warningMessage)
		self.dataOffsetEntry.insert(tk.END,"0x10")
		self.dataOffset.set(16)
		warningMessage = "Now you see, the initialization value check did NOT succeed (warning message popped up). \n\nWe will use this initialzation / verification "	\
						+"feature as a building block for another powerful feature later. \n\nFor now, press OK to continue."
		warningRoutine(warningMessage)
		
		self.clearDemo()
		
		# Feature # 5: Looping and Dimension-less array:
		
		warningMessage = "Feature # 5: Looping and Dimension-less array. \n\nIn C structures, array dimensions must be provided at compile-time. The C99 does allow "		\
						+"flexible arrays, but puts a constrint that it must be the last member in a C struct. \n\nHere, we allow arrays to be dimension-less and "			\
						+"treat it is an infinite-dimension array. This essentially can serve as a do/while loop that are one of the most essential building blocks "		\
						+"of any imperative programing language like C. (we will discuss the termination condition for infinite loops later)"
		warningRoutine(warningMessage)
		
		demoIndex = 6
		self.openCodeFile(demoIndex)
		self.openDataFile(demoIndex)
		warningMessage = "Suppose a datastream is simply many packets coming one after another, where each packet header contains a single \"packet_length\" field "		\
						+"followed by that many bytes of data. In ParseAndC 2.0, the code on the left is akin to an infinite loop until the datastream is exhausted."		
		warningRoutine(warningMessage)
		self.interpret()
		self.mapStructureToData()
		warningMessage = "Now that you can see the alternate-colored \"packet_length\" and \"packet_data\" fields.\n\nPress OK to continue."
		warningRoutine(warningMessage)
		
		self.clearDemo()
		
	
		warningMessage = "We just saw that using dimensionless arrays can be used for looping endlessly. However, looping endlessly is only of limited use."		\
						+"What we want is smart looping, where we stop after certain criteria is met. This is very similar to while(condition) { } loop in C."		\
						+"Unfortunately, we committed to NOT changing the C syntax, so we needed to devise a special way to mention the termination condition "		\
						+"while using the existing C syntax only.\n\nWould you like to know more? Press OK."
		warningRoutine(warningMessage)
		warningMessage = "For any dimensionless array, we can specify its termination critera by the lexically closest subsequent initialization statement. "		\
						+"What this means is that, instead of looping endlessly, now the tool will speculatively loop for different array dimension values "		\
						+"until the termination condition gets satisfied. \n\nLet's take a very practical example of this feature. "		
		warningRoutine(warningMessage)
		
		# Feature # 6:	Speculative execution and C strings:
		
		warningMessage = "Feature # 6: Speculative execution and C strings\n\nC does not have any special class for strings (character arrays ending with the null "	\
						+"character). However, we have C strings in nearly every real-life data (section names, program names, variable names etc.). So, if there is "	\
						+"a C string field in the incoming datastream, but we do not know its length beforehand, then we cannot capture it via a regular C structure. "	\
						+"\n\n(Sure, we can write a C program to figure that out easily, but here we are talking about capturing it via the structure definition alone.)"
		warningRoutine(warningMessage)
		demoIndex = 7
		self.openCodeFile(demoIndex)
		self.openDataFile(demoIndex)
		warningMessage = "Interestingly, we observe that the way C strings are constructed (a stream of non-null characters followed by the null character) makes it a "		\
						+"tailor-made case for dimensionless array with termination criteria. \n\nIn the code on the left, the tool will speculatively try all "		\
						+"possible values (1,2,3, ...) of dimension for the array variable Char[] until the subsequent nullChar gets a value of '\0' in the datastream. "	\
						+"\n\nSo, we can use this to map C strings whose length we do not know beforehand. Press OK to continue."
		warningRoutine(warningMessage)
		
		self.interpret()
		self.mapStructureToData()
		
		warningMessage = "As you see, this tool indeed found the C string. Let's try to map a lot more C strings at a time. "		\
						+"Since we will be doing a lot of speculative execution, this step will take a bit of time. \n\nPress OK to continue. "	
		warningRoutine(warningMessage)
		
		self.clearDemo()

		demoIndex = 8
		self.openCodeFile(demoIndex)
		self.openDataFile(demoIndex)
		self.interpret()
		self.mapStructureToData()
		warningMessage = "We deliberately chose to code an array of names treating the structure almost like a \"class\". "	\
						+"\n\nAs you see, this tool indeed found all the C strings.\n\nPress OK to continue."	
		warningRoutine(warningMessage)
		
		self.clearDemo()
		
		# Feature # 7: Unknown Offset? No problem! Parse even without knowing which data offset to parse from:

		# Variable-length arrays (speculative execution)
		warningMessage = "Feature # 7: Unknown data offset? No problem!\n\nUsually, in order to parse a datastream, We to know from which data offset we should start parsing. "	\
						+"But, what if we do not know where the data is? \n\nAmazingly, the new features (Dimensionless arrays with termination conditions via  "	\
						+"initialization) can help us there. \n\nLet's take an example to illustrate this."
		warningRoutine(warningMessage)
		demoIndex = 9
		self.openCodeFile(demoIndex)
		self.openDataFile(demoIndex)
		warningMessage = "On the code window, we see the struct Initialization_tester, which describes the data format for the packet that we are looking for. "	\
						+"Unfortunately, we do not know what offset it appears at. \n\nIf we blindly try to map from offset 0, it will throw warning messages "		\
						+"informing us that the \"magic_number\" field does NOT hold the intended value (0x0400FEFF) in the data. "									\
						+"\n\nPress OK to see that in action."
		warningRoutine(warningMessage)
		self.interpret()
		self.mapStructureToData()
						
		warningMessage = "As expected, we were hit with warning messages informing that the initialization (verification) statement did not succeed. "	\
						+"\n\nLuckily, using our keen eyesight, we observe that if we just mapped from the offset of 16 instead of 0, the \"magic_number\" would have "		\
						+"held the intended value (0x0400FEFF). Let's do that and verify."
		warningRoutine(warningMessage)
		self.dataOffsetEntry.insert(tk.END,"16")
		self.dataOffset.set(16)
		self.mapStructureToData()
		warningMessage = "As expected, this time we were NOT hit with any warning messages since the initialization (verification) statement did succeed: "		\
						+"when mapped from the offset of 16 instead of 0, the \"magic_number\" indeed held the intended value (0x0400FEFF).	"					\
						+"\n\nHowever, this was more of a lucky break. We cannot really rely upon human ability to look at the raw binary data and still be "	\
						+"able to identify the intended value. We would rather expect the tool to do the job for us."
		warningRoutine(warningMessage)
		
		self.clearDemo()
		demoIndex = 10
		self.openCodeFile(demoIndex)
		self.openDataFile(demoIndex)
		warningMessage = "That is precisely what we achieve here. Take a look at the Code window, where we have added a new line at the top. "							\
						+"\n\nThis new line \"int filler_junk [ ];\" is a variable-length array, where we do NOT mention the array dimension. "							\
						+"\n\nIn our tool, we treat the very next (lexically closest) initialization statement (magic_number=0x0400FEFF) as its termination condition."	\
						+"\n\nSo, this tool will start parsing from offset 0, but it will speculatively execute all the possible array dimension values (1 through "	\
						+"infinity) for filler_junk [ ] until that initialization test succeeds."	
		warningRoutine(warningMessage)
		self.interpret()
		self.mapStructureToData()
		warningMessage = "As you can see, the tool did the speculative execution and found the correct offset so that the target termination criteria got met. "		\
						+"This is an extremely powerful feature, where we can parse even witout knowing where to parse from (as long as we have some apriori knowlege"	\
						+"about what the data from the correct offset would look like.\n\nPress OK to continue."
		warningRoutine(warningMessage)
		
		self.clearDemo()
		warningMessage = "OK, enough with all these \"test\" data. Let's see this tool in action on some REAL data (network packet headers captured via Wireshark)."					
		warningRoutine(warningMessage)
		
		# Real-life example for network packet header parsing using Dynamic structure:
		demoIndex = 11
		self.openCodeFile(demoIndex)
		self.openDataFile(demoIndex)
		warningMessage = "What we have on the right are real Ethernet II frame headers followed by IPv4 header, and then TCP/UDP/ICMP headers after that."		\
						+"\n\nWe will be using a SINGLE Dynamic structure to decode all of it."
		warningRoutine(warningMessage)
		warningMessage = "In the bottom of the code, we have a single NW_pkt_hdr[3] array for the three different headers (TCP, UDP and ICMP)"
		warningRoutine(warningMessage)
		self.interpret()
		self.mapStructureToData()
		warningMessage = "Et voila!! (Pardon my French)"	\
						+ "\n\nThis marks the end of the demo, once you click OK, you will be able to take your cursor above various colored items in the "		\
						+"interpreted code window and the data window and see how the Description, Address and Values are shown below. \n\nYou will also be "	\
						+"able to play with the Expand/Collapse buttons to see the internals of the mapped variables."
		warningRoutine(warningMessage)
		
		return True

	############################################################################################################################
	############################################################################################################################
	#
	# clearDemo
	#
	############################################################################################################################
	############################################################################################################################

	def clearEverything(self, event=None):

		global codeFileName, lines, dataFileName, dataBlock, displayBlock, macroDefinitions, currentMacroNames, fileDisplayOffset, dataLocationOffset
		global lines, variableDeclarations, gTokenLocationLinesChars, enums, enumFieldValues, typedefs, structuresAndUnions, suDict, unraveled
		global dummyVariableCount, totalVariableCount, variableIdsInGlobalScope, coloredVarsIdOffsetSize, coloredDataIdOffsetSize, variablesAtGlobalScopeSelected
		global pragmaPackCurrentValue, pragmaPackStack, blankArraysAndTerminationInfo, dummyZeroWidthBitfieldVariableCount, variableSelectedIndices
		global dataFileSizeInBytes, inputIsHexChar, binaryArray, hexCharArray, totalBytesToReadFromDataFile, inputVariables, executionStateStack, runtimeStatementLineNumbers
		global runtimeStatementLocationsInGlobalScope, runtimeStatementOrGlobalScopedVariableIdOrStructId, globalScopedBuddies, globalScopedRuntimeBlocks, globalScopesSelected

		PRINT ("\n\n\n============ Entered ClearDemo() ==================\n\n\n")
		
		self.removeColorTags()
		self.clearTreeView()

		# First delete the Interpreted variables
		pragmaPackCurrentValue = None
		pragmaPackStack = []
		gTokenLocationLinesChars = []
		variableDeclarations = []
		unraveled = []
		enums.clear()
		enumFieldValues.clear()
		typedefs.clear()
		suDict.clear()
		structuresAndUnions = []
		dummyVariableCount = 0
		dummyZeroWidthBitfieldVariableCount = 0
		totalVariableCount = 0
		variableIdsInGlobalScope = []
		coloredVarsIdOffsetSize = []
		variablesAtGlobalScopeSelected = []
		blankArraysAndTerminationInfo = {}
		macroDefinitions = []
		currentMacroNames = []
		fileDisplayOffset = 0 	
		dataLocationOffset = 0	
		runtimeStatementLocationsInGlobalScope = [] 
		runtimeStatementLineNumbers = []
		runtimeStatementOrGlobalScopedVariableIdOrStructId = [] 
		globalScopedBuddies = []	
		globalScopedRuntimeBlocks = [] 
		#allPossibleQualifiedNames = [] 
		globalScopesSelected = []
		variableSelectedIndices = [] 
		inputVariables = []	
		executionStateStack = []	


		# Then delete the code and data window variables
		codeFileName ="" 
		lines =[]
		dataFileName = ""
		dataBlock = []
		displayBlock = []
		inputIsHexChar = False
		binaryArray = ""
		hexCharArray = []
		totalBytesToReadFromDataFile = 0
		

		# Then delete the code and data windows
		self.dataOffsetEntry.delete(0, tk.END)
		self.fileOffsetEntry.delete(0, tk.END)
		self.originalCodeText.delete("1.0", "end")
		self.interpretedCodeText.delete("1.0", "end")
		self.addressColumnText.delete("1.0", "end")
		self.viewDataHexText.delete("1.0", "end")
		self.viewDataAsciiText.delete("1.0", "end")
		if fileDisplayOffset != 0:
			self.fileOffset.set(0)
		if dataLocationOffset != 0:
			self.dataOffset.set(0)

		self.originalCodeText.delete("1.0", "end")
		self.interpretedCodeText.delete("1.0", "end")
		self.addressColumnText.delete("1.0", "end")
		self.viewDataHexText.delete("1.0", "end")
		self.viewDataAsciiText.delete("1.0", "end")

		# Just to make doubly sure
		self.colorTagsFG = []	
		self.colorTagsData = []
		self.COLORS = []
		self.currentCoordinates = ""
		self.interpretedCodeVariablesHighlightedStartEndCoordinates = []

	def clearDemo(self, event=None):
		self.clearEverything()
		
if __name__ == "__main__":
	main()


'''
The Batch flow:

processBatch() - gets called from main() if BATCHMODE. No other invocation. So exclusive for batch.
 - reads code file, calls interpretBatch(), which also gets called from GUI routine interpret()
 - creates variablesAtGlobalScopeSelected[] from variableIdsInGlobalScope[] and inputVariables[] (if provided). variableIdsInGlobalScope[] comes from parseCodeSnippet().
   variablesAtGlobalScopeSelected[] also gets populated by GUI routine selectVariablesAtGlobalScope(), which is called from mapStructureToData()
 - calls calculateSizeOffsetsBatch(), which also gets called from GUI routine calculateSizeOffsets(), which gets called from dataOffsetChange() and mapStructureToData()
 - calls checkIfDataFileIsValidAndGetItsLength(dataFileName) 
 - populates dataBlock by calling readBytesFromFile(dataLocationOffset, totalBytesToReadFromDataFile)
 - calls populateUnraveled(),    which is also called from GUI routine displayBottomTreeWindow(), which is called from dataOffsetChange() and mapStructureToData()
 - calls prettyPrintUnraveled(), which is also called from GUI routine displayBottomTreeWindow(), which is called from dataOffsetChange() and mapStructureToData()



BUG:

Gives an error if put a value in the Data offset before even interpreting.




'''

